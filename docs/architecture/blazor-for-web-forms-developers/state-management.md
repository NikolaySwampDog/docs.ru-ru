---
title: Управление данными о состоянии
description: Сведения о различных подходах к управлению состоянием в ASP.NET Web Forms и Blazor.
author: csharpfritz
ms.author: jefritz
ms.date: 05/15/2020
ms.openlocfilehash: 2ca811f886c6a245ac16c2bd66a68ff16e5bfc44
ms.sourcegitcommit: 05d0087dfca85aac9ca2960f86c5efd218bf833f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/30/2021
ms.locfileid: "88267728"
---
# <a name="state-management"></a>Управление данными о состоянии

Управление состоянием — это ключевая концепция приложений веб-форм, реализуемая посредством функций состояния просмотра, состояния сеанса, состояния приложения и обратной передачи. Эти функции с отслеживанием состояния, доступные на данной платформе, помогли скрыть необходимое для приложения управление состоянием и позволяют разработчикам приложений сосредоточиться на их функциональности. Для ASP.NET Core и Blazor некоторые из этих функций были перемещены, а некоторые полностью удалены. В этой главе рассматриваются способы сохранения состояния и предоставления тех же функциональных возможностей с помощью новых функций в Blazor.

## <a name="request-state-management-with-viewstate"></a>Запрос на управление состоянием с помощью ViewState

При обсуждении управления состоянием в приложении веб-форм многим разработчикам на ум сразу приходит ViewState. В веб-формах ViewState управляет состоянием содержимого между HTTP-запросами, отправляя большой кодированный блок текста вперед и назад в браузер. Поле ViewState может быть перегружено содержимым страницы, содержащей множество элементов, в результате чего размер может увеличиться до нескольких мегабайт.

При использовании Blazor Server приложение сохраняет текущее подключение к серверу. Состояние приложения, называемое *цепью*, хранится в памяти сервера, пока подключение считается активным. Состояние будет удалено, только когда пользователь покидает приложение или переходит на определенную страницу в нем. Все члены активных компонентов доступны между взаимодействиями с сервером.

Эта функция имеет несколько преимуществ:

- Состояние компонента легко доступно и не перестраивается между взаимодействиями.
- Состояние не передается в браузер.

Однако существуют некоторые недостатки сохранения состояния компонента в памяти, которые следует учитывать:

- Если сервер перезапускается между запросами, состояние теряется.
- Решение для балансировки нагрузки веб-сервера приложения должно включать в себя прикрепленные сеансы, чтобы все запросы из одного браузера возвращались на один и тот же сервер. В случае перехода запроса на другой сервер состояние будет потеряно.
- Сохранение состояния компонента на сервере может привести к нехватке памяти на веб-сервере.

По указанным выше причинам не следует полагаться на то, что состояние компонента всегда находится в памяти на сервере. Приложение также должно использовать резервное хранилище данных для размещения данных между запросами. Вот несколько простых примеров такой стратегии.

- В приложении корзины для покупок содержимое новых элементов, добавленных в корзину, сохраняется в записи базы данных. Если состояние на сервере потеряно, его можно восстановить из записей базы данных.
- При работе с многокомпонентной веб-формой пользователи ожидают, что ваше приложение запомнит значения между каждым запросом. Записывайте данные в хранилище данных между каждой записью пользователя, чтобы их можно было извлечь и собрать в итоговую структуру ответа формы после заполнения многокомпонентной формы.

Дополнительные сведения об управлении состоянием в приложениях Blazor см. в разделе [Управление состоянием Blazor в ASP.NET Core](/aspnet/core/blazor/state-management).

## <a name="maintain-state-with-session"></a>Сохранение состояния с помощью сеанса

Разработчики веб-форм могут сохранять сведения об активном в данный момент пользователе с помощью объекта словаря <xref:Microsoft.AspNetCore.Http.ISession?displayProperty=nameWithType>. Достаточно просто добавить объект со строковым ключом в `Session`, и этот объект будет доступен позже во время взаимодействия пользователя с приложением. Объект `Session` в результате попытки исключить управление взаимодействием с HTTP обеспечил простоту сохранения состояния.

Подпись объекта `Session` платформы .NET Framework не совпадает с подписью объекта `Session` ASP.NET Core. Изучите [документацию по новому объекту Session ASP.NET Core](/dotnet/api/microsoft.aspnetcore.http.isession), прежде чем принимать решение о переносе и использовании новой функции состояния сеанса.

Сеанс доступен в ASP.NET Core и Blazor Server, однако его не рекомендуется использовать вместо надлежащего сохранения данных в репозитории данных. Состояние сеанса также не работает, если посетители не соглашаются использовать файлы cookie HTTP в приложении из соображений конфиденциальности.

Конфигурация ASP.NET Core и состояние сеанса приведена в статье [Управление сеансами и состояниями в ASP.NET Core](/aspnet/core/fundamentals/app-state#session-state).

## <a name="application-state"></a>Состояние приложения

Объект `Application` в платформе веб-форм предоставляет обширный и поддерживающий различные запросы репозиторий для взаимодействия с конфигурацией и состоянием, относящимся к области определения приложения. Состояние приложения было оптимальным местом для хранения различных свойств конфигурации приложения, на которые могут ссылаться все запросы, независимо от пользователя, выполняющего такой запрос. Проблема с объектом `Application` заключается в том, что данные не сохранялись между разными серверами. Состояние объекта приложения терялось между перезапусками.

Как и в случае с `Session`, рекомендуется перемещать данные в постоянное резервное хранилище, доступное нескольким экземплярам сервера. Если имеются непостоянные данные, к которым вы хотите обеспечить доступ разным запросам и пользователям, можно легко сохранить их в отдельной службе, которую можно внедрить в компоненты, нуждающиеся в такой информации или таком взаимодействии.

Создание объекта для сохранения состояния приложения и его использование могут напоминать следующую реализацию:

```csharp
public class MyApplicationState
{
    public int VisitorCounter { get; private set; } = 0;

    public void IncrementCounter() => VisitorCounter += 1;
}
```

```csharp
app.AddSingleton<MyApplicationState>();
```

```razor
@inject MyApplicationState AppState

<label>Total Visitors: @AppState.VisitorCounter</label>
```

Объект `MyApplicationState` создается на сервере только один раз, и значение `VisitorCounter` извлекается и выводится в метке компонента. Значение `VisitorCounter` должно сохраняться в резервном хранилище данных и извлекаться из него для обеспечения устойчивости и масштабируемости.

## <a name="in-the-browser"></a>В браузере

Данные приложений также могут храниться на стороне клиента, а именно на устройстве пользователя, чтобы они были доступны позже. Существует две функции браузера, позволяющие сохранять данные в разных областях браузера пользователя:

- `localStorage` — относится к области всего браузера пользователя. При перезагрузке страницы браузер закрывается и открывается повторно, либо открывается другая вкладка с тем же URL-адресом, после чего та же `localStorage` предоставляется в браузере.
- `sessionStorage` — относится к области текущей вкладки браузера пользователя. При перезагрузке вкладки состояние сохраняется. Однако если пользователь откроет другую вкладку для приложения или закроет и снова откроет браузер, состояние будет потеряно.

Вы можете написать специальный код JavaScript для взаимодействия с этими функциями, кроме того, существует ряд пакетов NuGet, которые можно использовать для предоставления подобных функциональных возможностей. Одним из таких пакетов является [Microsoft.AspNetCore.ProtectedBrowserStorage](https://www.nuget.org/packages/Microsoft.AspNetCore.ProtectedBrowserStorage).

Инструкции по использованию этого пакета для взаимодействия с `localStorage` и `sessionStorage` см. в статье [Управление состоянием Blazor ](/aspnet/core/blazor/state-management#protected-browser-storage-experimental-package).

>[!div class="step-by-step"]
>[Назад](pages-routing-layouts.md)
>[Вперед](forms-validation.md)
