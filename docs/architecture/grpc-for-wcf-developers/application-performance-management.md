---
title: Управление производительностью приложений — gRPC для разработчиков WCF
description: Ведение журнала, метрики и трассировка для ASP.NET Core gRPC приложений.
ms.date: 12/15/2020
ms.openlocfilehash: 06515762e3e5febf2d11dea14524d5e3f586a760
ms.sourcegitcommit: c7f0beaa2bd66ebca86362ca17d673f7e8256ca6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/23/2021
ms.locfileid: "104874554"
---
# <a name="application-performance-management"></a>Управление производительностью приложений

В рабочих средах, таких как Kubernetes, важно отслеживать приложения, чтобы обеспечить их оптимальное выполнение. Журнал и метрики важны в частности. ASP.NET Core, включая gRPC, предоставляет встроенную поддержку для создания сообщений журнала и данных метрик и управления ими, а также для *трассировки* данных.

## <a name="the-difference-between-logging-and-metrics"></a>Разница между ведением журнала и метриками

*Ведение журнала* касается текстовых сообщений, которые записывают подробные сведения о том, что произошло в системе. Сообщения журнала могут содержать данные об исключениях, например трассировки стека, или структурированные данные, предоставляющие контекст сообщения. Вывод журнала обычно записывается в хранилище текста с возможностью поиска.

*Метрики* — это числовые данные, предназначенные для агрегирования и представления с помощью диаграмм и графиков на панели мониторинга. Панель мониторинга предоставляет общее представление о работоспособности и производительности приложения. Данные метрик можно также использовать для активации автоматических оповещений при превышении порогового значения. Ниже приведены некоторые примеры данных метрик.

- Время, затраченное на обработку запросов.
- Количество запросов в секунду, обрабатываемых экземпляром службы.
- Количество неудачных запросов в экземпляре.

## <a name="logging-in-aspnet-core-grpc"></a>Вход в систему ASP.NET Core gRPC

ASP.NET Core предоставляет встроенную поддержку ведения журнала в виде пакета NuGet [Microsoft. Extensions. Logging](https://www.nuget.org/packages/Microsoft.Extensions.Logging) . Основные части этой библиотеки включены в веб-пакет SDK, поэтому нет необходимости устанавливать его вручную. По умолчанию сообщения журнала записываются в стандартный вывод ("консоль") и в любой подключенный отладчик. Для записи журналов в постоянные внешние хранилища данных может потребоваться импортировать [Дополнительные пакеты приемника журнала](/aspnet/core/fundamentals/logging/?view=aspnetcore-3.0#third-party-logging-providers).

ASP.NET Core gRPC Framework записывает подробные сообщения журнала диагностики в эту платформу ведения журналов, чтобы их можно было обрабатывать и хранить вместе с собственными сообщениями приложения.

### <a name="produce-log-messages"></a>Создание сообщений журнала

Расширение ведения журнала регистрируется автоматически в системе внедрения зависимостей ASP.NET Core, поэтому можно указать средства ведения журнала в качестве параметра конструктора для типов служб gRPC.

```csharp
public class StockData : Stocks.StocksBase
{
    private readonly ILogger<StockData> _logger;

    public StockData(ILogger<StockData> logger)
    {
        _logger = logger;
    }
}
```

Многие сообщения журнала, такие как запросы и исключения, предоставляются компонентами платформы ASP.NET Core и gRPC. Добавьте собственные сообщения журнала, чтобы предоставить подробные сведения и контекст о логике приложения, а не о проблемах низкого уровня.

Дополнительные сведения о написании сообщений журнала и доступных приемников ведения журнала и целевых объектах см.  [в разделе Ведение журнала в .NET Core и ASP.NET Core](/aspnet/core/fundamentals/logging/).

## <a name="metrics-in-aspnet-core-grpc"></a>Метрики в ASP.NET Core gRPC

Среда выполнения .NET Core предоставляет набор компонентов для выдачи и наблюдения за метриками. К ним относятся интерфейсы API, такие как <xref:System.Diagnostics.Tracing.EventSource> <xref:System.Diagnostics.Tracing.EventCounter> классы и. Эти API-интерфейсы могут выдавать базовые числовые данные, которые могут использоваться внешними процессами, например, [глобальным инструментом DotNet-Counters](../../core/diagnostics/dotnet-counters.md)или трассировкой событий для Windows. Дополнительные сведения об использовании `EventCounter` в собственном коде см. в разделе [евенткаунтер введение](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Diagnostics.Tracing/documentation/EventCounterTutorial.md).

Для более сложных метрик и для записи данных метрик в более широкий спектр хранилищ данных можно попробовать проект с открытым исходным кодом, именуемый [метриками приложения](https://www.app-metrics.io). Этот набор библиотек предоставляет обширный набор типов для инструментирования кода. Он также предоставляет пакеты для записи метрик в различные типы целевых объектов, которые включают базы данных временных рядов, такие как Prometheus и InfluxDB, и [Application Insights](/azure/azure-monitor/app/app-insights-overview). Пакет NuGet [app. Metrics. AspNetCore. MVC](https://www.nuget.org/packages/App.Metrics.AspNetCore.Mvc/) даже добавляет всеобъемлющий набор базовых метрик, которые автоматически создаются с помощью интеграции с ASP.NET Core Framework. Веб-сайт проекта содержит [шаблоны](https://www.app-metrics.io/samples/grafana/) для отображения этих метрик с помощью платформы визуализации [Grafana](https://grafana.com/) .

### <a name="produce-metrics"></a>Создание метрик

Большинство платформ метрик поддерживают следующие типы:

| Тип метрики | Описание |
| ----------- | ----------- |
| Счетчик     | Отслеживает, как часто происходит нечто, например запросы и ошибки. |
| Датчик       | Записывает одно значение, которое изменяется со временем, например активные соединения. |
| Гистограмма   | Измеряет распределение значений по произвольным ограничениям. Например, гистограмма может отформатировать размер набора данных, подсчитать, сколько содержалось <10 записей, сколько содержало 11-100 записей, сколько содержало записей 101-1000, а сколько со>1000 записей. |
| средство измерения.       | Измеряет скорость, с которой событие происходит в различные промежутки времени. |
| Таймер       | Отслеживает длительность событий и скорость их возникновения, хранящуюся в виде гистограммы. |

С помощью *метрик приложения* `IMetrics` интерфейс можно получить с помощью внедрения зависимостей и использовать для записи любой из этих метрик для службы gRPC. В следующем примере показано, как подсчитать количество `Get` запросов, выполненных с течением времени:

```csharp
public class StockData : Stocks.StocksBase
{
    private static readonly CounterOptions GetRequestCounter = new CounterOptions
    {
        Name = "StockData_Get_Requests",
        MeasurementUnit = Unit.Calls
    };

    private readonly IStockRepository _repository;
    private readonly IMetrics _metrics;

    public StockData(IStockRepository repository, IMetrics metrics)
    {
        _repository = repository;
        _metrics = metrics;
    }

    public override async Task<GetResponse> Get(GetRequest request, ServerCallContext context)
    {
        _metrics.Measure.Counter.Increment(GetRequestCounter);

        // Serve request...
    }
}
```

### <a name="store-and-visualize-metrics-data"></a>Хранение и визуализация данных метрик

Лучшим способом хранения данных метрик является *база данных временных рядов*, специализированное хранилище данных, предназначенное для записи числовых рядов данных, помеченных метками времени. Самыми популярными из этих баз данных являются [Prometheus](https://prometheus.io/) и [InfluxDB](https://www.influxdata.com/products/influxdb-overview/). Microsoft Azure также предоставляет хранилище выделенных метрик через службу [Azure Monitor](/azure/azure-monitor/overview) .

Текущим решением для визуализации данных метрик является [Grafana](https://grafana.com), которое работает с широким спектром поставщиков хранилища. На следующем рисунке показан пример панели мониторинга Grafana, отображающей метрики из сетки службы Linkerd с примером Стоккдата:

![Снимок экрана панели мониторинга Grafana](media/application-performance-management/grafana-screenshot.png)

### <a name="metrics-based-alerting"></a>Оповещения на основе метрик

Числовой характер данных метрик означает, что он идеально подходит для создания систем предупреждений, уведомления разработчиков или инженеров технической поддержки, когда значение выходит за пределы определенного периода. Уже упомянутые платформы обеспечивают поддержку предупреждений с помощью различных параметров, включая сообщения электронной почты, текстовые сообщения или визуализации панелей мониторинга.

## <a name="distributed-tracing"></a>Распределенная трассировка

Распределенная трассировка — это относительно недавняя разработка в мониторинге, которая возникли сомнения от увеличения использования микрослужб и распределенных архитектур. Один запрос от клиентского браузера, приложения или устройства может быть разбит на несколько шагов и подзапросов, что требует использования множества служб в сети. Это действие затрудняет сопоставление сообщений журнала и метрик с конкретным запросом, который их инициировал. Распределенная трассировка применяет идентификаторы к запросам и позволяет сопоставлять журналы и метрики с определенной операцией. Эта трассировка похожа на [сквозную трассировку WCF](../../framework/wcf/diagnostics/tracing/end-to-end-tracing.md), но применяется на нескольких платформах.

Распределенная трассировка быстро увеличилась в популярности и начинается стандартизации. Облачная инфраструктура машинного кода создала [открытый стандарт трассировки](https://opentracing.io), пытаясь предоставить независимые от поставщика библиотеки для работы с серверными элементами, такими как [жаежер](https://www.jaegertracing.io/) и [эластичная APM](https://www.elastic.co/products/apm). В то же время Google создал [проект опенценсус](https://opencensus.io/) для решения того же набора проблем. Эти два проекта объединяются в новый проект, [опентелеметри](https://opentelemetry.io), который является отраслевым стандартом будущего.

### <a name="how-distributed-tracing-works"></a>Как работает Распределенная трассировка

Распределенная трассировка основана на концепции *диапазонов*: именованных, временных операций, которые являются частью одной *трассировки*, которая может включать обработку на нескольких узлах системы. При запуске новой операции создается трассировка с уникальным идентификатором. Для каждой вложенной операции создается диапазон с собственным идентификатором и идентификатором трассировки. По мере прохождения запроса вокруг системы различные компоненты могут создавать *дочерние* диапазоны, включающие идентификатор своего *родителя*. Диапазон имеет *контекст*, который содержит идентификаторы трассировки и диапазонов, а также полезные данные в виде пар "ключ — значение" (называется *багажа*).

### <a name="distributed-tracing-with-diagnosticsource"></a>Распределенная трассировка с помощью `DiagnosticSource`

.NET имеет внутренний модуль, который хорошо сопоставляется с распределенными трассировками и охватывает диапазоны: [DiagnosticSource](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md#diagnosticsource-users-guide). Кроме простого способа создания и использования диагностики внутри процесса, `DiagnosticSource` модуль имеет концепцию *действия*. Действие фактически является реализацией распределенной трассировки или диапазоном в трассировке. Внутренние компоненты модуля принимают на себя действия родительских и дочерних элементов, включая выделение идентификаторов. Дополнительные сведения об использовании `Activity` типа см. в разделе [действие пользователя в GitHub](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Diagnostics.DiagnosticSource/src/ActivityUserGuide.md#activity-user-guide).

Поскольку `DiagnosticSource` является частью основной платформы и более поздних версий, она поддерживается несколькими основными компонентами. К ним относятся <xref:System.Net.Http.HttpClient> , Entity Framework Core и ASP.NET Core, включая явную поддержку в gRPC Framework. Когда ASP.NET Core получает запрос, он проверяет наличие пары HTTP-заголовков, соответствующих стандарту [контекста трассировки W3C](https://www.w3.org/TR/trace-context) . Если заголовки найдены, действие запускается с использованием значений идентификаторов и контекста из заголовков. Если заголовки не найдены, действие запускается с созданными значениями идентификаторов, которые соответствуют стандартному формату. Любая диагностика, создаваемая платформой или кодом приложения в течение времени существования этого действия, может быть помечена идентификаторами трассировки и диапазона. `HttpClient`Поддержка этой функции расширяется за счет проверки текущего действия при каждом запросе и автоматического добавления заголовков трассировки к исходящему запросу.

Клиентские и серверные библиотеки ASP.NET Core gRPC включают в себя явную поддержку и и создание действий, а также `DiagnosticSource` `Activity` Автоматическое применение и использование сведений о заголовках.

> [!NOTE]
> Все это происходит только в том случае, если прослушиватель использует диагностические данные. Если прослушиватель отсутствует, диагностика не записывается и действия не создаются.

### <a name="add-your-own-diagnosticsource-and-activity"></a>Добавьте собственные `DiagnosticSource` и `Activity`

Чтобы добавить собственную диагностику или создать явные диапазоны в коде приложения, ознакомьтесь с руководством [пользователя DiagnosticSource](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md#instrumenting-with-diagnosticsourcediagnosticlistener) и сведениями о [действии](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Diagnostics.DiagnosticSource/src/ActivityUserGuide.md#activity-usage).

### <a name="store-distributed-trace-data"></a>Хранение распределенных данных трассировки

На момент написания статьи проект Опентелеметри по-прежнему находится на ранних стадиях, и для приложений .NET доступны только пакеты с альфа-качеством. В настоящее время проект ОпентраЦинг предлагает более зрелые библиотеки.

API ОпентраЦинг описывается в следующем разделе. Если вместо этого вы хотите использовать API Опентелеметри в приложении, обратитесь к [репозиторию пакета SDK для опентелеметри .NET](https://github.com/open-telemetry/opentelemetry-dotnet) на сайте GitHub.

#### <a name="use-the-opentracing-package-to-store-distributed-trace-data"></a>Использование пакета ОпентраЦинг для хранения распределенных данных трассировки

[Пакет NuGet опентраЦинг](https://www.nuget.org/packages/OpenTracing/) поддерживает все серверные конечные точки, соответствующие опентраЦинг (которые могут использоваться независимо от `DiagnosticSource` ). Существует дополнительный пакет из проекта публикаций ОпентраЦинг API, [опентраЦинг. от участников сообщества. NetCore](https://www.nuget.org/packages/OpenTracing.Contrib.NetCore/). Этот пакет добавляет `DiagnosticSource` прослушиватель и автоматически записывает события и действия в серверную части. Включить этот пакет так же просто, как установить его из NuGet и добавить в качестве службы в `Startup` класс.

```csharp
public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddOpenTracing();
    }
}
```

Пакет ОпентраЦинг является уровнем абстракции, и поэтому он требует реализации, характерной для серверной части. Реализации API ОпентраЦинг доступны для следующих серверных интерфейсов с открытым исходным кодом.

| Имя | Пакет | Веб-сайт |
| ---- | ------- | -------- |
| Jaeger | [Jaeger](https://www.nuget.org/packages/Jaeger/) | [jaegertracing.io](https://jaegertracing.io) |
| Эластичная APM | [Эластичный. APM. Неткореалл](https://www.nuget.org/packages/Elastic.Apm.NetCoreAll/) | [elastic.co/products/apm](https://www.elastic.co/products/apm) |

Дополнительные сведения об API ОпентраЦинг для .NET см. в разделе [опентраЦинг for c#](https://github.com/opentracing/opentracing-csharp) и [опентраЦинг от участников сообщества c#/.NET Core](https://github.com/opentracing-contrib/csharp-netcore) репозитории на сайте GitHub.

>[!div class="step-by-step"]
>[Назад](load-balancing.md)
>[Вперед](appendix.md)
