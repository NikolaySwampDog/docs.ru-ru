---
title: Пример миграции на .NET 5
description: Демонстрация миграции примеров приложений, предназначенных для платформы .NET Framework, на .NET 5.
ms.date: 01/19/2021
ms.openlocfilehash: 02a45859dfca891598e235e3de1ed968aefb5bf4
ms.sourcegitcommit: 46cfed35d79d70e08c313b9c664c7e76babab39e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/10/2021
ms.locfileid: "102605169"
---
# <a name="example-of-migrating-to-net"></a>Пример миграции на .NET

В этой главе представлены практические рекомендации, которые помогут выполнить миграцию имеющегося приложения с платформы .NET Framework на .NET.

Мы представим хорошо структурированный процесс, который вы сможете выполнить, а также наиболее важные моменты, которые следует учитывать на каждом этапе.

Затем мы задокументируем пошаговый процесс миграции для примера классического приложения из версий WinForms и WPF.

## <a name="migration-process-overview"></a>Общие сведения о процессе миграции

Процесс миграции состоит из четырех последовательных шагов:

1. **Подготовка**. Изучите зависимости, которые проект должен учитывать при дальнейших действиях. На этом шаге вы переведете текущий проект в состояние, которое упрощает точку запуска миграции.

2. **Миграция файла проекта.** В проектах .NET используется новый формат проекта в стиле пакета SDK. Создайте новый файл проекта с этим форматом или обновите его, чтобы использовать стиль пакета SDK.

3. **Исправление кода и сборки.** Создайте код в .NET для устранения различий на уровне API между платформой .NET Framework и .NET. При необходимости обновите сторонние пакеты до поддерживаемых версий .NET.

4. **Запуск и тестирование.** Могут возникнуть различия, которые не отображаются до времени выполнения. Поэтому не забудьте запустить приложение и проверить, чтобы все работало должным образом.

### <a name="preparation"></a>Подготовка

#### <a name="migrate-packagesconfig-file"></a>Миграция файла packages.config

В приложении .NET Framework все ссылки на внешние пакеты объявляются в файле *packages.config*. В .NET больше не нужно использовать файл *packages.config*. Вместо него используйте свойство [PackageReference](../../core/project-sdk/msbuild-props.md#packagereference) в файле проекта, чтобы указать пакеты NuGet для приложения.

Поэтому необходимо перейти от одного формата к другому. Обновление можно выполнить вручную, используя зависимости, содержащиеся в файле *packages.config*. Перенесите их в файл проекта в формате `PackageReference`. Вы также можете использовать Visual Studio: щелкните правой кнопкой мыши файл *packages.config* и выберите пункт **Migrate packages.config to PackageReference** (Перенос packages.config в PackageReference).

#### <a name="verify-every-dependency-compatibility-in-net"></a>Проверка совместимости всех зависимостей в .NET

После переноса ссылок на пакеты необходимо проверить каждую ссылку на совместимость. Изучить зависимости всех пакетов NuGet, используемых вашим приложением, можно на сайте [nuget.org](https://www.nuget.org/). Если пакет имеет зависимости .NET Standard, он будет работать в .NET 5.0, так как .NET [поддерживает](../../standard/net-standard.md#net-implementation-support) все версии .NET Standard. На следующем изображении показаны зависимости для пакета `Castle.Windsor`:

![Снимок экрана зависимостей NuGet для пакета Castle.Windsor](./media/example-migration-core/nuget-dependencies.png)

Для проверки совместимости пакета можно использовать средство <https://fuget.org>, предоставляющее более подробные сведения о версиях и зависимостях.

Возможно, проект ссылается на старые версии пакетов, которые не поддерживают .NET. Вы можете найти более новые версии, поддерживающие платформу. Поэтому рекомендуется обновить пакеты до более новых версий. Однако следует учитывать, что обновление версии пакета может повлечь за собой некоторые критические изменения, которые требуют обновления кода.

Что, если вы не нашли совместимую версию? Что делать, если вы не хотите обновлять версию пакета из-за этих критических изменений? Не беспокойтесь, так как приложение .NET может зависеть от пакетов .NET Framework. Обязательно протестируйте сборку, так как она может вызвать ошибки во время выполнения, если внешний пакет вызывает API, недоступный в .NET. Это отлично подходит для тех случаев, когда вы используете старый пакет, который не будет обновляться, и вы можете просто перенастроить его на работу в .NET.

#### <a name="check-for-api-compatibility"></a>Проверка на совместимость API

Так как поверхность API в платформах .NET Framework и .NET похожа, но не идентична, необходимо проверить, какие интерфейсы API доступны в .NET, а какие нет. Средство "Анализатор переносимости .NET" можно использовать для отображения API-интерфейсов, отсутствующих в .NET. Он просматривает двоичный уровень приложения, извлекает все вызываемые API, а затем выводит список недоступных в целевой платформе интерфейсов API (в данном случае это .NET 5.0).

Дополнительные сведения об этом средстве можно найти по адресу:

<https://docs.microsoft.com/dotnet/standard/analyzers/portability-analyzer>

Интересной особенностью этого средства является то, что оно выявляет лишь отличия от вашего собственного кода, а не кода из внешних пакетов, который невозможно изменить. Помните, что большинство этих пакетов следует обновить для работы с .NET.

### <a name="migrate-with-try-convert-tool"></a>Миграция с помощью средства Try Convert

Средство [Try Convert](https://github.com/dotnet/try-convert/releases) — отличный способ миграции проекта. Это глобальное средство, которое пытается обновить файл проекта со старого стиля до нового стиля пакета SDK и настраивает применимые проекты на работу с .NET 5. После установки можно выполнить следующие команды:

```dotnetcli
try-convert -p "<path to your project file>"
```

Или сделайте так:

```dotnetcli
try-convert -w "<path to your solution>"
```

> [!NOTE]
> Средство try-convert запускается автоматически в рамках [помощника по обновлению .NET](https://aka.ms/dotnet-upgrade-assistant). Рекомендуется запустить помощник по обновлению, а не просто средство Try Convert.

После того как средство предпримет попытку преобразования, перезагрузите файлы в Visual Studio для запуска и тестирования. Существует вероятность неуспешного выполнения попытки преобразования из-за особенностей проекта. В этом случае вы можете ознакомиться с приведенными ниже шагами.

#### <a name="migrate-manually"></a>Миграция вручную

1. Создание проекта .NET

В большинстве случаев необходимо обновить имеющийся проект до нового формата .NET. Однако можно также создать проект, сохранив старый. Основной недостаток обновления старого проекта заключается в том, что вы потеряете поддержку конструктора, которая может быть важной для вас и вашей команды разработчиков. Если вы хотите продолжить работу с конструктором, необходимо создать проект .NET параллельно со старым и совместно использовать ресурсы. Если необходимо изменить элементы пользовательского интерфейса в конструкторе, можно переключиться на старый проект, чтобы сделать это. Так как ресурсы связаны, они также будут обновлены в проекте .NET.

[Проект в стиле пакета SDK](../../core/project-sdk/msbuild-props.md) для .NET гораздо проще, чем формат проекта платформы .NET Framework. Помимо упомянутых выше записей `PackageReference`, это не будет существенно сложнее. Новый формат проекта [содержит файлы с определенными расширениями по умолчанию](../../core/project-sdk/overview.md#default-includes-and-excludes), например файлы `.cs` и `.xaml`. Нет необходимости явно включать их в файл проекта.

#### <a name="assemblyinfo-considerations"></a>Рекомендации по AssemblyInfo

В проектах .NET атрибуты создаются автоматически. Если проект содержит файл *AssemblyInfo.cs*, определения будут дублироваться, что приведет к конфликтам компиляции. Вы можете удалить старый файл *AssemblyInfo.CS* или отключить автоматическое создание, добавив следующую запись в файл проекта .NET:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <GenerateAssemblyInfo>false</GenerateAssemblyInfo>
  </PropertyGroup>
</Project>
```

#### <a name="resources"></a>Ресурсы

Внедренные ресурсы включаются автоматически, но ресурсы — нет, поэтому ресурсы необходимо перенести в новый файл проекта.

#### <a name="package-references"></a>Ссылки на пакеты

С помощью параметра **Migrate packages.config to PackageReference** (Перенос packages.config в PackageReference) можно легко переместить ссылки на внешние пакеты в новый формат, как упоминалось ранее.

#### <a name="update-package-references"></a>Обновление ссылок на пакеты

Обновите версии совместимых пакетов, как показано в предыдущем разделе.

### <a name="fix-the-code-and-build"></a>Исправление кода и сборки

#### <a name="microsoftwindowscompatibility"></a>Microsoft.Windows.Compatibility

Если приложение зависит от интерфейсов API, которые недоступны в .NET, таких как реестр, списки ACL или WCF, необходимо включить ссылку на пакет `Microsoft.Windows.Compatibility`, чтобы добавить эти интерфейсы API для Windows. Они работают на платформе .NET, но не включены в нее, так как не являются кросс-платформенными.

Существует средство, именуемое анализатором API (<https://docs.microsoft.com/dotnet/standard/analyzers/api-analyzer>), помогающее определить интерфейсы API, которые не совместимы с кодом.

#### <a name="use-if-directives"></a>Использование директив \#if

Если требуются разные пути выполнения при нацеливании на платформу .NET Framework и .NET, следует использовать константы компиляции. Добавьте в код несколько директив \#if, чтобы иметь одинаковую базу кода для обеих целей.

#### <a name="technologies-not-available-on-net"></a>Технологии, недоступные в .NET

Некоторые технологии недоступны в .NET, например:

* Домены приложений
* Удаленное взаимодействие
* Управление доступом для кода
* Сервер WCF
* Рабочий процесс Windows

Именно поэтому необходимо найти замену этих технологий, если вы используете их в своем приложении. Дополнительные сведения см. в статье [Технологии .NET Framework, недоступные в .NET Core и .NET 5 и более поздних версий](../../core/porting/net-framework-tech-unavailable.md).

#### <a name="regenerate-autogenerated-clients"></a>Повторное создание автоматически созданных клиентов

Если приложение использует автоматически созданный код, например клиент WCF, может потребоваться повторно создать этот код для .NET. Иногда можно найти некоторые отсутствующие ссылки, так как они могут быть не включены в набор сборок .NET по умолчанию. С помощью такого средства как <https://apisof.net/> можно легко найти сборку, в которой находится отсутствующая ссылка, и добавить ее из NuGet.

#### <a name="rolling-back-package-versions"></a>Откат версий пакета

Как мы уже упоминали, лучше обновить каждую версию пакета, чтобы она была совместима с .NET. Однако вы можете обнаружить, что нацеливание на обновленную и совместимую версию сборки просто нецелесообразно. Если стоимость изменения не является приемлемой, можно рассмотреть возможность отката версий пакета с сохранением тех, которые используются на платформе .NET Framework. Хотя они и не предназначены для .NET, они должны работать, если не вызывают некоторые неподдерживаемые API.

### <a name="run-and-test"></a>Запуск и тестирование

После создания приложения без ошибок можно запустить последний шаг миграции, проверив все функциональные возможности.

На этом заключительном этапе может возникнуть несколько различных проблем в зависимости от сложности приложения и используемых зависимостей и интерфейсов API.

Например, при использовании файлов конфигурации (*app.config*) могут возникнуть ошибки во время выполнения, например отсутствие разделов конфигурации. Использование пакета NuGet `Microsoft.Extensions.Configuration` должно исправить эту ошибку.

Другой причиной ошибок является использование методов `BeginInvoke` и `EndInvoke`, так как они не поддерживаются в .NET. Они не поддерживаются в .NET, так как имеют зависимость от удаленного взаимодействия, которое не существует в .NET. Чтобы решить эту проблему, попробуйте использовать ключевое слово `await` (если доступно) или метод <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType>.

Анализаторы совместимости можно использовать для выявления интерфейсов API и шаблонов кода в коде, которые могут вызывать проблемы во время выполнения с помощью .NET. Перейдите на страницу <https://github.com/dotnet/platform-compat> и используйте анализатор API .NET для своего проекта.

## <a name="migrating-a-windows-forms-application"></a>Миграция приложения Windows Forms

Чтобы продемонстрировать полный процесс миграции приложения Windows Forms, мы решили перенести пример приложения eShop, доступного по адресу <https://github.com/dotnet-architecture/eShopModernizing/tree/master/eShopLegacyNTier/src/eShopWinForms>. Полный результат миграции можно найти по адресу <https://github.com/dotnet-architecture/eShopModernizing/tree/master/eShopModernizedNTier/src/eShopWinForms>.

Это приложение показывает каталог продуктов и позволяет пользователю перемещаться по ним, фильтровать их и выполнять поиск. С точки зрения архитектуры, приложение использует внешнюю службу WCF, которая служит интерфейсом для серверной базы данных.

Главное окно приложения можно увидеть на следующем изображении:

![Главное окно приложения](./media/example-migration-core/main-application-window.png)

Открыв файл проекта *.csproj*, вы увидите примерно следующее:

![Снимок экрана содержимого файла csproj](./media/example-migration-core/csproj-file.png)

Как упоминалось ранее, проект .NET имеет более компактный стиль, поэтому необходимо перенести структуру проекта в новый стиль пакета SDK для .NET.

В Обозревателе решений щелкните правой кнопкой мыши проект Windows Forms и выберите **Выгрузить проект** > **Изменить**.

Теперь можно обновить файл .csproj. Удалите все содержимое, заменив его следующим кодом:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net5.0-windows</TargetFramework>
    <UseWindowsForms>true</UseWindowsForms>
    <GenerateAssemblyInfo>false</GenerateAssemblyInfo>
  </PropertyGroup>
</Project>
```

Сохраните и перезагрузите проект. Теперь обновление файла проекта завершено и проект нацелен на .NET.

Скомпилировав проект на этом этапе, вы обнаружите некоторые ошибки, связанные со ссылкой на клиент WCF. Поскольку этот код создается автоматически, его необходимо создать заново для .NET.

![Список ошибок в Visual Studio](./media/example-migration-core/winforms-compilation-errors.png)

Удалите файл *Reference.cs* и создайте клиент службы.

Щелкните правой кнопкой мыши **Подключенные службы** и выберите пункт **Добавить подключенную службу**.

![Снимок экрана меню "Подключенные службы" с выбранным параметром "Добавить подключенную службу"](./media/example-migration-core/add-connected-service.png)

Откроется окно "Подключенные службы". Выберите параметр **Microsoft WCF Web Service**.

![Снимок экрана окна "Подключенные службы"](./media/example-migration-core/connected-services-window.png)

Если у вас есть служба WCF в том же решении, что и в этом примере, вместо указания URL-адреса службы можно выбрать параметр **Обнаружение**.

![Снимок экрана окна "Настройка ссылки на веб-службу WCF"](./media/example-migration-core/configure-wcf-reference.png)

После обнаружения службы средство отражает контракт API, реализованный службой. Измените имя пространства имен на `eShopServiceReference`, как показано на следующем изображении:

![Снимок экрана изменение пространства имен и контракта API](./media/example-migration-core/api-contract-namespace.png)

Нажмите кнопку **Готово**. Через некоторое время отобразится созданный код.

Вы должны увидеть три автоматически созданных файла:

1. *Getting Started*: ссылка на GitHub с информацией о WCF.
2. *ConnectedService.json*: параметры конфигурации для подключения к службе.
3. *Reference.cs*: фактический код клиента WCF.

![Снимок экрана окна обозревателя решений с тремя автоматически созданными файлами](./media/example-migration-core/autogenerated-files.png)

При повторной компиляции отобразится множество ошибок, поступающих из файлов *.cs* в папку *Helper*. Эта папка присутствовала в версии .NET Framework, но не была включена в старую версию файла *.csproj*. Однако при использовании нового проекта в стиле пакета SDK каждый файл кода, который находится под расположением файла проекта, включается по умолчанию. То есть новый проект .NET Core пытается скомпилировать файлы в папке *Helper*. Так как эта папка не требуется, ее можно безопасно удалить.

Если скомпилировать проект еще раз и выполнить его, образы продукта не будут отображаться. Проблема заключается в том, что теперь путь к файлам немного изменился. Чтобы устранить эту проблему, добавьте в путь другой уровень глубины, обновив в файле `CatalogView.cs` строку:

```csharp
string image_name = Environment.CurrentDirectory + "\\..\\..\\Assets\\Images\\Catalog\\" + catalogItems.Picturefilename;
```

значение

```csharp
string image_name = Environment.CurrentDirectory + "\\..\\..\\..\\Assets\\Images\\Catalog\\" + catalogItems.Picturefilename;
```

Внеся это изменение, проверьте, чтобы приложение запускалось и работало в .NET Core должным образом.

## <a name="migrating-a-wpf-application"></a>Миграция приложения WPF

Для выполнения миграции мы будем использовать пример приложения `Shop.ClassicWPF`. На следующем изображении показан снимок экрана приложения перед миграцией:

![Пример приложения перед миграцией](./media/example-migration-core/app-before-migration.png)

Это приложение использует локальную базу данных SQL Server Express для хранения сведений о каталоге продуктов. Доступ к этой базе данных осуществляется непосредственно из приложения WPF.

Сначала необходимо обновить файл *.csproj* до нового стиля пакета SDK, используемого приложениями .NET Core. Выполните те же действия, которые описаны в разделе о миграции Windows Forms: выгрузите проект, откройте файл *.csproj*, обновите его содержимое и перезагрузите проект.

В этом случае удалите все содержимое файла *.csproj* и замените его следующим кодом:

```xml
 <Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net5.0-windows</TargetFramework>
    <UseWpf>true</UseWpf>
    <GenerateAssemblyInfo>false</GenerateAssemblyInfo>
  </PropertyGroup>
</Project>
```

Если перезагрузить проект и скомпилировать его, отобразится следующая ошибка:

![Список ошибок в Visual Studio, в котором отображается единственная ошибка CS0234](./media/example-migration-core/wpf-compilation-error.png)

Удалив все содержимое файла *.csproj*, вы потеряли спецификацию ссылок на проект, присутствующую в старом проекте. Необходимо просто добавить эту строку в файл *.csproj*, чтобы включить ссылку на проект.

```xml
<ItemGroup>
    <ProjectReference Include="..\\eShop.SqlProvider\\eShop.SqlProvider.csproj" />
<ItemGroup>
```

Кроме того, для этого можно использовать Visual Studio, щелкнув правой кнопкой мыши узел **Зависимости** и выбрав пункт **Добавить ссылку на проект**. Выберите проект из решения и нажмите кнопку **ОК**:

![Снимок экрана диалогового окна "Диспетчер ссылок" с выбранным проектом eShop.SqlProvider](./media/example-migration-core/reference-manager.png)

После добавления отсутствующей ссылки на проект приложение компилируется и запускается в .NET должным образом.

>[!div class="step-by-step"]
>[Назад](windows-migration.md)
>[Вперед](deploy-modern-applications.md)
