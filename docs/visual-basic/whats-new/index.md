---
description: 'Узнайте подробнее о: Новые возможности Visual Basic'
title: Новые возможности
ms.date: 10/24/2018
f1_keywords:
- VB.StartPage.WhatsNew
helpviewer_keywords:
- new features, Visual Basic
- what's new [Visual Basic]
- Visual Basic, what's new
ms.assetid: d7e97396-7f42-4873-a81c-4ebcc4b6ca02
ms.openlocfilehash: 222c92413bd12e1769376c0f6eef7e34d7d5182e
ms.sourcegitcommit: 42d436ebc2a7ee02fc1848c7742bc7d80e13fc2f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/04/2021
ms.locfileid: "102106570"
---
# <a name="whats-new-for-visual-basic"></a><span data-ttu-id="aba77-103">Новые возможности Visual Basic</span><span class="sxs-lookup"><span data-stu-id="aba77-103">What's new for Visual Basic</span></span>

<span data-ttu-id="aba77-104">В этой статье перечислены названия основных возможностей в каждой версии Visual Basic, а также подробно описаны новые и усовершенствованные возможности в самых поздних версиях этого языка программирования.</span><span class="sxs-lookup"><span data-stu-id="aba77-104">This topic lists key feature names for each version of Visual Basic, with detailed descriptions of the new and enhanced features in the latest versions of the language.</span></span>

## <a name="current-version"></a><span data-ttu-id="aba77-105">Текущая версия</span><span class="sxs-lookup"><span data-stu-id="aba77-105">Current version</span></span>

<span data-ttu-id="aba77-106">Visual Basic 16.9 / Visual Studio 2019 версии 16.9</span><span class="sxs-lookup"><span data-stu-id="aba77-106">Visual Basic 16.9 / Visual Studio 2019 version 16.9</span></span>\
<span data-ttu-id="aba77-107">Описание новых функций см. в статье о [Visual Basic 16.9](#visual-basic-169).</span><span class="sxs-lookup"><span data-stu-id="aba77-107">For new features, see [Visual Basic 16.9](#visual-basic-169).</span></span>

<span data-ttu-id="aba77-108">Вы можете скачать последний пакет SDK для .NET на странице [скачиваемых файлов .NET](https://dotnet.microsoft.com/download).</span><span class="sxs-lookup"><span data-stu-id="aba77-108">You can download the latest .NET SDK from the [.NET downloads page](https://dotnet.microsoft.com/download).</span></span>

## <a name="previous-versions"></a><span data-ttu-id="aba77-109">Предыдущие версии</span><span class="sxs-lookup"><span data-stu-id="aba77-109">Previous versions</span></span>

<span data-ttu-id="aba77-110">Visual Basic 16.0/Visual Studio 2019 версии 16.0</span><span class="sxs-lookup"><span data-stu-id="aba77-110">Visual Basic 16.0 / Visual Studio 2019 version 16.0</span></span>\
<span data-ttu-id="aba77-111">Описание новых функций см. в статье о [Visual Basic 16.0](#visual-basic-160).</span><span class="sxs-lookup"><span data-stu-id="aba77-111">For new features, see [Visual Basic 16.0](#visual-basic-160).</span></span>

<span data-ttu-id="aba77-112">Visual Basic 15.8/Visual Studio 2017 версии 15.8</span><span class="sxs-lookup"><span data-stu-id="aba77-112">Visual Basic 15.8 / Visual Studio 2017 version 15.8</span></span>\
<span data-ttu-id="aba77-113">Описание новых функций см. в статье о [Visual Basic 15.8](#visual-basic-158).</span><span class="sxs-lookup"><span data-stu-id="aba77-113">For new features, see [Visual Basic 15.8](#visual-basic-158).</span></span>

<span data-ttu-id="aba77-114">Visual Basic 15.5/Visual Studio 2017 версии 15.5</span><span class="sxs-lookup"><span data-stu-id="aba77-114">Visual Basic 15.5 / Visual Studio 2017 version 15.5</span></span>\
<span data-ttu-id="aba77-115">Описание новых функций см. в статье о [Visual Basic 15.5](#visual-basic-155).</span><span class="sxs-lookup"><span data-stu-id="aba77-115">For new features, see [Visual Basic 15.5](#visual-basic-155).</span></span>

<span data-ttu-id="aba77-116">Visual Basic 15.3/Visual Studio 2017 версии 15.3</span><span class="sxs-lookup"><span data-stu-id="aba77-116">Visual Basic 15.3 / Visual Studio 2017 version 15.3</span></span>\
<span data-ttu-id="aba77-117">Описание новых функций см. в статье о [Visual Basic 15.3](#visual-basic-153).</span><span class="sxs-lookup"><span data-stu-id="aba77-117">For new features, see [Visual Basic 15.3](#visual-basic-153).</span></span>

<span data-ttu-id="aba77-118">Visual Basic 2017/Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="aba77-118">Visual Basic 2017 / Visual Studio 2017</span></span>\
<span data-ttu-id="aba77-119">Описание новых функций см. в статье о [Visual Basic 2017](#visual-basic-2017).</span><span class="sxs-lookup"><span data-stu-id="aba77-119">For new features, see [Visual Basic 2017](#visual-basic-2017).</span></span>

<span data-ttu-id="aba77-120">Visual Basic/Visual Studio 2015</span><span class="sxs-lookup"><span data-stu-id="aba77-120">Visual Basic / Visual Studio 2015</span></span>\
<span data-ttu-id="aba77-121">Описание новых функций см. в статье о [Visual Basic 14](#visual-basic-14).</span><span class="sxs-lookup"><span data-stu-id="aba77-121">For new features, see [Visual Basic 14](#visual-basic-14).</span></span>

<span data-ttu-id="aba77-122">Visual Basic/Visual Studio 2013</span><span class="sxs-lookup"><span data-stu-id="aba77-122">Visual Basic / Visual Studio 2013</span></span>\
<span data-ttu-id="aba77-123">CTP-версии платформы компиляции .NET (Roslyn)</span><span class="sxs-lookup"><span data-stu-id="aba77-123">Technology previews of the .NET Compiler Platform ("Roslyn")</span></span>

<span data-ttu-id="aba77-124">Visual Basic/Visual Studio 2012</span><span class="sxs-lookup"><span data-stu-id="aba77-124">Visual Basic / Visual Studio 2012</span></span>\
<span data-ttu-id="aba77-125">Ключевые слова `Async` и `await`, итераторы, атрибуты сведений о вызывающем объекте</span><span class="sxs-lookup"><span data-stu-id="aba77-125">`Async` and `await` keywords, iterators, caller info attributes</span></span>

<span data-ttu-id="aba77-126">Visual Basic, Visual Studio 2010</span><span class="sxs-lookup"><span data-stu-id="aba77-126">Visual Basic, Visual Studio 2010</span></span>\
<span data-ttu-id="aba77-127">Автоматически реализуемые свойства, инициализаторы коллекций, неявное продолжение строки, динамические типы, универсальная ковариантность и контрвариантность, доступ к глобальному пространству имен</span><span class="sxs-lookup"><span data-stu-id="aba77-127">Auto-implemented properties, collection initializers, implicit line continuation, dynamic, generic co/contra variance, global namespace access</span></span>

<span data-ttu-id="aba77-128">Visual Basic/Visual Studio 2008</span><span class="sxs-lookup"><span data-stu-id="aba77-128">Visual Basic / Visual Studio 2008</span></span>\
<span data-ttu-id="aba77-129">Интегрированные запросы языка (LINQ), XML-литералы, определение локального типа, инициализаторы объектов, анонимные типы, методы расширений, определение локального типа `var`, лямбда-выражения, оператор `if`, типы значений, допускающие значение NULL</span><span class="sxs-lookup"><span data-stu-id="aba77-129">Language Integrated Query (LINQ), XML literals, local type inference, object initializers, anonymous types, extension methods, local `var` type inference, lambda expressions, `if` operator, partial methods, nullable value types</span></span>

<span data-ttu-id="aba77-130">Visual Basic/Visual Studio 2005</span><span class="sxs-lookup"><span data-stu-id="aba77-130">Visual Basic / Visual Studio 2005</span></span>\
<span data-ttu-id="aba77-131">Тип `My` и вспомогательные типы (доступ к приложению, компьютеру, файловой системе, сети)</span><span class="sxs-lookup"><span data-stu-id="aba77-131">The `My` type and helper types (access to app, computer, files system, network)</span></span>

<span data-ttu-id="aba77-132">Visual Basic/Visual Studio .NET 2003</span><span class="sxs-lookup"><span data-stu-id="aba77-132">Visual Basic / Visual Studio .NET 2003</span></span>\
<span data-ttu-id="aba77-133">Операторы поразрядного сдвига, объявление переменных цикла</span><span class="sxs-lookup"><span data-stu-id="aba77-133">Bit-shift operators, loop variable declaration</span></span>

<span data-ttu-id="aba77-134">Visual Basic/Visual Studio .NET 2002</span><span class="sxs-lookup"><span data-stu-id="aba77-134">Visual Basic / Visual Studio .NET 2002</span></span>\
<span data-ttu-id="aba77-135">Первый выпуск Visual Basic .NET</span><span class="sxs-lookup"><span data-stu-id="aba77-135">The first release of Visual Basic .NET</span></span>

## <a name="visual-basic-169"></a><span data-ttu-id="aba77-136">Visual Basic 16.9</span><span class="sxs-lookup"><span data-stu-id="aba77-136">Visual Basic 16.9</span></span>

<span data-ttu-id="aba77-137">Visual Basic 16.9 позволяет использовать свойства только для инициализации.</span><span class="sxs-lookup"><span data-stu-id="aba77-137">Visual Basic 16.9 enables consumption of init-only properties.</span></span>

## <a name="visual-basic-160"></a><span data-ttu-id="aba77-138">Visual Basic 16.0</span><span class="sxs-lookup"><span data-stu-id="aba77-138">Visual Basic 16.0</span></span>

<span data-ttu-id="aba77-139">Visual Basic 16.0 фокусируется на предоставлении большего числа функций среды выполнения Visual Basic (microsoft.visualbasic.dll) в .NET Core и является первой версией Visual Basic, ориентированной на .NET Core.</span><span class="sxs-lookup"><span data-stu-id="aba77-139">Visual Basic 16.0 focuses on supplying more of the features of the Visual Basic Runtime (microsoft.visualbasic.dll) to .NET Core and is the first version of Visual Basic focused on .NET Core.</span></span> <span data-ttu-id="aba77-140">Многие части среды выполнения Visual Basic зависят от WinForms и будут добавлены в более поздней версии Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="aba77-140">Many portions of the Visual Basic Runtime depend on WinForms and these will be added in a later version of Visual Basic.</span></span>

<span data-ttu-id="aba77-141">**Комментарии можно использовать в большем количестве мест внутри операторов**.</span><span class="sxs-lookup"><span data-stu-id="aba77-141">**Comments allowed in more places within statements**</span></span>

<span data-ttu-id="aba77-142">В Visual Basic 15.8 и более ранних версиях комментарии можно использовать только в пустых строках, в конце оператора или в определенных местах внутри оператора, где разрешено неявное продолжение строки.</span><span class="sxs-lookup"><span data-stu-id="aba77-142">In Visual Basic 15.8 and earlier versions, comments are only allowed on blank lines, at the end of a statement, or in specific places within a statement where an implicit line continuation is allowed.</span></span> <span data-ttu-id="aba77-143">Начиная с Visual Basic 16.0 комментарии также допускаются после явных продолжений строк и внутри оператора в строке, начинающейся с пробела, за которым следует символ подчеркивания.</span><span class="sxs-lookup"><span data-stu-id="aba77-143">Starting with Visual Basic 16.0, comments are also allowed after explicit line continuations and within a statement on a line beginning with a space followed by an underscore.</span></span>

```vb
Public Sub Main()
    cmd.CommandText = ' Comment is allowed here without _
        "SELECT * FROM Titles JOIN Publishers " _ ' This is a comment
        & "ON Publishers.PubId = Titles.PubID " _
 _ ' This is a comment on a line without code
        & "WHERE Publishers.State = 'CA'"
End Sub
```

## <a name="visual-basic-158"></a><span data-ttu-id="aba77-144">Visual Basic 15.8</span><span class="sxs-lookup"><span data-stu-id="aba77-144">Visual Basic 15.8</span></span>

<span data-ttu-id="aba77-145">**Оптимизированное преобразование чисел с плавающей запятой в целые числа**</span><span class="sxs-lookup"><span data-stu-id="aba77-145">**Optimized floating-point to integer conversion**</span></span>

<span data-ttu-id="aba77-146">В предыдущих версиях Visual Basic преобразование значений [Double](../language-reference/data-types/double-data-type.md) и [Single](../language-reference/data-types/single-data-type.md) в целые числа обеспечивало относительно низкую производительность.</span><span class="sxs-lookup"><span data-stu-id="aba77-146">In previous versions of Visual Basic, conversion of [Double](../language-reference/data-types/double-data-type.md) and [Single](../language-reference/data-types/single-data-type.md) values to integers offered relatively poor performance.</span></span> <span data-ttu-id="aba77-147">Visual Basic 15.8 значительно повышает производительность преобразования чисел с плавающей запятой в целые числа, когда вы передаете значение, возвращаемое любым из следующих методов одной из [встроенных функций преобразования целого числа в Visual Basic](../language-reference/functions/type-conversion-functions.md) (CByte, CShort, CInt, CLng, CSByte, CUShort, CUInt, CULng), или когда значение, возвращаемое любым из следующих методов, неявно приводится к целочисленному типу, когда для [Option Strict](../language-reference/statements/option-strict-statement.md) задано значение `Off`:</span><span class="sxs-lookup"><span data-stu-id="aba77-147">Visual Basic 15.8 significantly enhances the performance of floating-point conversions to integers when you pass the value returned by any of the following methods to one of the [intrinsic Visual Basic integer conversion functions](../language-reference/functions/type-conversion-functions.md) (CByte, CShort, CInt, CLng, CSByte, CUShort, CUInt, CULng), or when the value returned by any of the following methods is implicitly cast to an integral type when [Option Strict](../language-reference/statements/option-strict-statement.md) is set to `Off`:</span></span>

- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Double)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Object)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Single)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Double)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Object)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Single)?displayProperty=nameWithType>
- <xref:System.Math.Ceiling(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Floor(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Round(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Truncate(System.Double)?displayProperty=nameWithType>

<span data-ttu-id="aba77-148">Эта оптимизация позволяет коду выполняться быстрее — до двух раз быстрее для кода, который выполняет большое количество преобразований в целочисленные типы.</span><span class="sxs-lookup"><span data-stu-id="aba77-148">This optimization allows code to run faster -- up to twice as fast for code that does a large number of conversions to integer types.</span></span> <span data-ttu-id="aba77-149">В следующем примере показано несколько простых вызовов методов, которые затрагивает эта оптимизация:</span><span class="sxs-lookup"><span data-stu-id="aba77-149">The following example illustrates some simple method calls that are affected by this optimization:</span></span>

```vb
Dim s As Single = 173.7619
Dim d As Double = s

Dim i1 As Integer = CInt(Fix(s))               ' Result: 173
Dim b1 As Byte = CByte(Int(d))                 ' Result: 173
Dim s1 AS Short = CShort(Math.Truncate(s))     ' Result: 173
Dim i2 As Integer = CInt(Math.Ceiling(d))      ' Result: 174
Dim i3 As Integer = CInt(Math.Round(s))        ' Result: 174
```

<span data-ttu-id="aba77-150">Обратите внимание, что значения с плавающей запятой усекаются, а не округляются.</span><span class="sxs-lookup"><span data-stu-id="aba77-150">Note that this truncates rather than rounds floating-point values.</span></span>

## <a name="visual-basic-155"></a><span data-ttu-id="aba77-151">Visual Basic 15.5</span><span class="sxs-lookup"><span data-stu-id="aba77-151">Visual Basic 15.5</span></span>

[<span data-ttu-id="aba77-152">Неконечные именованные аргументы</span><span class="sxs-lookup"><span data-stu-id="aba77-152">Non-trailing named arguments</span></span>](../programming-guide/language-features/procedures/passing-arguments-by-position-and-by-name.md#mixing-arguments-by-position-and-by-name)

<span data-ttu-id="aba77-153">В Visual Basic 15.3 и более ранних версиях при включении в вызов метода аргументов по положению и по имени позиционные аргументы должны были предшествовать именованным.</span><span class="sxs-lookup"><span data-stu-id="aba77-153">In Visual Basic 15.3 and earlier versions, when a method call included arguments both by position and by name, positional arguments had to precede named arguments.</span></span> <span data-ttu-id="aba77-154">Начиная с Visual Basic 15.5, позиционные и именованные аргументы могут появляться в любом порядке при условии, что все аргументы до последнего позиционного аргумента находятся в правильном положении.</span><span class="sxs-lookup"><span data-stu-id="aba77-154">Starting with Visual Basic 15.5, positional and named arguments can appear in any order as long as all arguments up to the last positional argument are in the correct position.</span></span> <span data-ttu-id="aba77-155">Это особенно полезно, если именованные аргументы используются, чтобы сделать код более удобочитаемым.</span><span class="sxs-lookup"><span data-stu-id="aba77-155">This is particularly useful when named arguments are used to make code more readable.</span></span>

<span data-ttu-id="aba77-156">Например, следующий вызов метода имеет два позиционных аргумента между именованным аргументом.</span><span class="sxs-lookup"><span data-stu-id="aba77-156">For example, the following method call has two positional arguments between a named argument.</span></span> <span data-ttu-id="aba77-157">Именованный аргумент показывает, что значение 19 представляет возраст.</span><span class="sxs-lookup"><span data-stu-id="aba77-157">The named argument makes it clear that the value 19 represents an age.</span></span>

```vb
StudentInfo.Display("Mary", age:=19, #9/21/1998#)
```

[<span data-ttu-id="aba77-158">Модификатор доступа к члену `Private Protected`</span><span class="sxs-lookup"><span data-stu-id="aba77-158">`Private Protected` member access modifier</span></span>](../language-reference/modifiers/private-protected.md)

<span data-ttu-id="aba77-159">Это новое сочетание ключевых слов определяет член, доступный для всех членов содержащего его класса, а также типы, производные от содержащего член класса, но только в том случае, если они присутствуют и в сборке, содержащей член.</span><span class="sxs-lookup"><span data-stu-id="aba77-159">This new keyword combination defines a member that is accessible by all members in its containing class as well as by types derived from the containing class, but only if they are also found in the containing assembly.</span></span> <span data-ttu-id="aba77-160">Так как структуры нельзя наследовать, `Private Protected` можно применять только к членам класса.</span><span class="sxs-lookup"><span data-stu-id="aba77-160">Because structures cannot be inherited, `Private Protected` can only be applied to the members of a class.</span></span>

<span data-ttu-id="aba77-161">**Начальный шестнадцатеричный/двоичный/восьмеричный разделитель**</span><span class="sxs-lookup"><span data-stu-id="aba77-161">**Leading hex/binary/octal separator**</span></span>

<span data-ttu-id="aba77-162">В Visual Basic 2017 поддерживается использование подчеркивания (`_`) в качестве разделителя цифр.</span><span class="sxs-lookup"><span data-stu-id="aba77-162">Visual Basic 2017 added support for the underscore character (`_`) as a digit separator.</span></span> <span data-ttu-id="aba77-163">Начиная с Visual Basic 15.5, в качестве начального разделителя между префиксом и двоичными, шестнадцатеричными или восьмеричными цифрами можно использовать знак подчеркивания.</span><span class="sxs-lookup"><span data-stu-id="aba77-163">Starting with Visual Basic 15.5, you can use the underscore character as a leading separator between the prefix and hexadecimal, binary, or octal digits.</span></span> <span data-ttu-id="aba77-164">В следующем примере начальный разделитель цифр используется для определения 3 271 948 384 в качестве шестнадцатеричного числа:</span><span class="sxs-lookup"><span data-stu-id="aba77-164">The following example uses a leading digit separator to define 3,271,948,384 as a hexadecimal number:</span></span>

```vb
Dim number As Integer = &H_C305_F860
```

<span data-ttu-id="aba77-165">Чтобы использовать символ подчеркивания в качестве начального разделителя, нужно добавить в файл проекта Visual Basic (\*.vbproj) следующий элемент:</span><span class="sxs-lookup"><span data-stu-id="aba77-165">To use the underscore character as a leading separator, you must add the following element to your Visual Basic project (\*.vbproj) file:</span></span>

```xml
<PropertyGroup>
  <LangVersion>15.5</LangVersion>
</PropertyGroup>
```

## <a name="visual-basic-153"></a><span data-ttu-id="aba77-166">Visual Basic 15.3</span><span class="sxs-lookup"><span data-stu-id="aba77-166">Visual Basic 15.3</span></span>

[<span data-ttu-id="aba77-167">**Вывод именованного кортежа**</span><span class="sxs-lookup"><span data-stu-id="aba77-167">**Named tuple inference**</span></span>](../programming-guide/language-features/data-types/tuples.md#inferred-tuple-element-names)

<span data-ttu-id="aba77-168">При присвоении значения элементов кортежа из переменных Visual Basic выводит имя элементов кортежа из соответствующих имен переменных; нет необходимости явно называть элемент кортежа.</span><span class="sxs-lookup"><span data-stu-id="aba77-168">When you assign the value of tuple elements from variables, Visual Basic infers the name of tuple elements from the corresponding variable names; you do not have to explicitly name a tuple element.</span></span> <span data-ttu-id="aba77-169">В следующем примере вывод используется для создания кортежа с тремя именованными элементами: `state`, `stateName` и `capital`.</span><span class="sxs-lookup"><span data-stu-id="aba77-169">The following example uses inference to create a tuple with three named elements, `state`, `stateName`, and `capital`.</span></span>

[!code-vb[Inferred tuple names](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]

<span data-ttu-id="aba77-170">**Дополнительные параметры компилятора**</span><span class="sxs-lookup"><span data-stu-id="aba77-170">**Additional compiler switches**</span></span>

<span data-ttu-id="aba77-171">Теперь компилятор командной строки Visual Basic поддерживает параметры [ **-refout**](../reference/command-line-compiler/refout-compiler-option.md) и [ **-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) для управления выводом базовых сборок.</span><span class="sxs-lookup"><span data-stu-id="aba77-171">The Visual Basic command-line compiler now supports the [**-refout**](../reference/command-line-compiler/refout-compiler-option.md) and [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) compiler options to control the output of reference assemblies.</span></span> <span data-ttu-id="aba77-172">**-refout** определяет выходной каталог базовой сборки, а **-refonly** указывает, что в результате компиляции будет выводиться только базовая сборка.</span><span class="sxs-lookup"><span data-stu-id="aba77-172">**-refout** defines the output directory of the reference assembly, and **-refonly** specifies that only a reference assembly is to be output by compilation.</span></span>

## <a name="visual-basic-2017"></a><span data-ttu-id="aba77-173">Visual Basic 2017</span><span class="sxs-lookup"><span data-stu-id="aba77-173">Visual Basic 2017</span></span>

[<span data-ttu-id="aba77-174">**Кортежи**</span><span class="sxs-lookup"><span data-stu-id="aba77-174">**Tuples**</span></span>](../programming-guide/language-features/data-types/tuples.md)

<span data-ttu-id="aba77-175">Кортежи представляют собой облегченную структуру данных, которая обычно используется для получения сразу нескольких значений за один вызов метода.</span><span class="sxs-lookup"><span data-stu-id="aba77-175">Tuples are a lightweight data structure that most commonly is used to return multiple values from a single method call.</span></span> <span data-ttu-id="aba77-176">Как правило, для получения нескольких значений с помощью одного метода необходимо выполнить одно из следующих действий:</span><span class="sxs-lookup"><span data-stu-id="aba77-176">Ordinarily, to return multiple values from a method, you have to do one of the following:</span></span>

- <span data-ttu-id="aba77-177">Определить пользовательский тип (`Class` или `Structure`).</span><span class="sxs-lookup"><span data-stu-id="aba77-177">Define a custom type (a `Class` or a `Structure`).</span></span> <span data-ttu-id="aba77-178">Это трудоемкое решение.</span><span class="sxs-lookup"><span data-stu-id="aba77-178">This is a heavyweight solution.</span></span>

- <span data-ttu-id="aba77-179">Определить один или несколько параметров `ByRef` помимо возврата значения из метода.</span><span class="sxs-lookup"><span data-stu-id="aba77-179">Define one or more `ByRef` parameters, in addition to returning a value from the method.</span></span>

<span data-ttu-id="aba77-180">Поддержка кортежей в Visual Basic позволяет быстро определить кортеж, при необходимости назначить его значениям семантические имена и быстро извлечь его значения.</span><span class="sxs-lookup"><span data-stu-id="aba77-180">Visual Basic's support for tuples lets you quickly define a tuple, optionally assign semantic names to its values, and quickly retrieve its values.</span></span> <span data-ttu-id="aba77-181">В следующем примере показан вызов метода <xref:System.Int32.TryParse%2A> и получение кортежа.</span><span class="sxs-lookup"><span data-stu-id="aba77-181">The following example wraps a call to the <xref:System.Int32.TryParse%2A> method and returns a tuple.</span></span>

[!code-vb[Tuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]

<span data-ttu-id="aba77-182">После этого можно вызвать метод и обработать возвращенный кортеж в коде следующего вида.</span><span class="sxs-lookup"><span data-stu-id="aba77-182">You can then call the method and handle the returned tuple with code like the following.</span></span>

[!code-vb[ReturnTuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)]

<span data-ttu-id="aba77-183">**Двоичные литералы и разделители разрядов**</span><span class="sxs-lookup"><span data-stu-id="aba77-183">**Binary literals and digit separators**</span></span>

<span data-ttu-id="aba77-184">Двоичный литерал можно определить с помощью префикса `&B` или `&b`.</span><span class="sxs-lookup"><span data-stu-id="aba77-184">You can define a binary literal by using the prefix `&B` or `&b`.</span></span> <span data-ttu-id="aba77-185">Для повышения удобочитаемости в качестве разделителя разрядов можно использовать символ подчеркивания (`_`).</span><span class="sxs-lookup"><span data-stu-id="aba77-185">In addition, you can use the underscore character, `_`, as a digit separator to enhance readability.</span></span> <span data-ttu-id="aba77-186">В следующем примере обе эти функции используют для того, чтобы назначить значение `Byte` и отобразить его как десятичное, шестнадцатеричное или двоичное число.</span><span class="sxs-lookup"><span data-stu-id="aba77-186">The following example uses both features to assign a `Byte` value and to display it as a decimal, hexadecimal, and binary number.</span></span>

[!code-vb[Binary](../../../samples/snippets/visualbasic/getting-started/bin-example.vb#1)]

<span data-ttu-id="aba77-187">Дополнительные сведения см. в разделе "Назначения литералов" статей, посвященных типам данных [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments) и [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments).</span><span class="sxs-lookup"><span data-stu-id="aba77-187">For more information, see the "Literal assignments" section of the [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments), and [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) data types.</span></span>

[<span data-ttu-id="aba77-188">**Поддержка значений C#, возвращаемых по ссылке**</span><span class="sxs-lookup"><span data-stu-id="aba77-188">**Support for C# reference return values**</span></span>](../programming-guide/language-features/procedures/ref-return-values.md)

<span data-ttu-id="aba77-189">Начиная с версии 7.0 C# поддерживает значения, возвращаемые по ссылке.</span><span class="sxs-lookup"><span data-stu-id="aba77-189">Starting with C# 7.0, C# supports reference return values.</span></span> <span data-ttu-id="aba77-190">Это значит, что в случае, если вызывающий метод получает значение, возвращаемое по ссылке, он может изменить значение ссылки.</span><span class="sxs-lookup"><span data-stu-id="aba77-190">That is, when the calling method receives a value returned by reference, it can change the value of the reference.</span></span> <span data-ttu-id="aba77-191">Visual Basic не позволяет создавать методы со значениями, возвращаемыми по ссылке, но разрешает получать и изменять такие значения.</span><span class="sxs-lookup"><span data-stu-id="aba77-191">Visual Basic does not allow you to author methods with reference return values, but it does allow you to consume and modify the reference return values.</span></span>

<span data-ttu-id="aba77-192">Например, следующий класс `Sentence`, написанный на языке C#, включает метод `FindNext`, который выполняет поиск следующего слова в предложении, которое начинается с заданной подстроки.</span><span class="sxs-lookup"><span data-stu-id="aba77-192">For example, the following `Sentence` class written in C# includes a `FindNext` method that finds the next word in a sentence that begins with a specified substring.</span></span> <span data-ttu-id="aba77-193">Строка возвращается как значение, возвращаемое по ссылке, а переменная `Boolean`, переданная в метод по ссылке, показывает, дал ли поиск какие-то результаты.</span><span class="sxs-lookup"><span data-stu-id="aba77-193">The string is returned as a reference return value, and a `Boolean` variable passed by reference to the method indicates whether the search was successful.</span></span> <span data-ttu-id="aba77-194">Это означает, что вызывающий объект может не только читать, но и изменять возвращаемое значение, а внесенные изменения отражаются в классе `Sentence`.</span><span class="sxs-lookup"><span data-stu-id="aba77-194">This means that in addition to reading the returned value, the caller can also modify it, and that modification is reflected in the `Sentence` class.</span></span>

[!code-csharp[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-returns.cs)]

<span data-ttu-id="aba77-195">Проще всего изменить найденное в предложении слово с помощью представленного ниже кода.</span><span class="sxs-lookup"><span data-stu-id="aba77-195">In its simplest form, you can modify the word found in the sentence by using code like the following.</span></span> <span data-ttu-id="aba77-196">Обратите внимание на то, что при этом значение назначается не методу, а выражению, которое возвращается этим методом и представляет собой значение, возвращаемое по ссылке.</span><span class="sxs-lookup"><span data-stu-id="aba77-196">Note that you are not assigning a value to the method, but rather to the expression that the method returns, which is the reference return value.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#1)]

<span data-ttu-id="aba77-197">Проблема этого кода состоит в том, что в случае, если совпадений нет, метод возвращает первое слово.</span><span class="sxs-lookup"><span data-stu-id="aba77-197">A problem with this code, though, is that if a match is not found, the method returns the first word.</span></span> <span data-ttu-id="aba77-198">Поскольку код в этом примере не проверяет значение аргумента `Boolean`, чтобы определить наличие совпадений, в случае, если совпадений нет, он изменяет первое слово.</span><span class="sxs-lookup"><span data-stu-id="aba77-198">Since the example does not examine the value of the `Boolean` argument to determine whether a match is found, it modifies the first word if there is no match.</span></span> <span data-ttu-id="aba77-199">В следующем примере эта проблема решена — если совпадений нет, первое слово заменяется само на себя.</span><span class="sxs-lookup"><span data-stu-id="aba77-199">The following example corrects this by replacing the first word with itself if there is no match.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#2)]

<span data-ttu-id="aba77-200">Лучше использовать вспомогательный метод, в который значение, возвращаемое по ссылке, передается по ссылке.</span><span class="sxs-lookup"><span data-stu-id="aba77-200">A better solution is to use a helper method to which the reference return value is passed by reference.</span></span> <span data-ttu-id="aba77-201">Впоследствии вспомогательный метод сможет изменить аргумент, передаваемый ему по ссылке.</span><span class="sxs-lookup"><span data-stu-id="aba77-201">The helper method can then modify the argument passed to it by reference.</span></span> <span data-ttu-id="aba77-202">Эту задачу решает следующий код.</span><span class="sxs-lookup"><span data-stu-id="aba77-202">The following example does that.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return-helper.vb#1)]

<span data-ttu-id="aba77-203">Дополнительные сведения см. в разделе [Значения, возвращаемые по ссылке](../programming-guide/language-features/procedures/ref-return-values.md).</span><span class="sxs-lookup"><span data-stu-id="aba77-203">For more information, see [Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md).</span></span>

## <a name="visual-basic-14"></a><span data-ttu-id="aba77-204">Visual Basic 14</span><span class="sxs-lookup"><span data-stu-id="aba77-204">Visual Basic 14</span></span>

[<span data-ttu-id="aba77-205">NameOf</span><span class="sxs-lookup"><span data-stu-id="aba77-205">NameOf</span></span>](../language-reference/operators/nameof.md)

<span data-ttu-id="aba77-206">Можно получить неполное имя строки типа или элемента для использования в сообщении об ошибке, не выполняя жесткого программирования строки.</span><span class="sxs-lookup"><span data-stu-id="aba77-206">You can get the unqualified string name of a type or member for use in an error message without hard coding a string.</span></span>  <span data-ttu-id="aba77-207">Это позволяет сохранить правильный код при рефакторинге.</span><span class="sxs-lookup"><span data-stu-id="aba77-207">This allows your code to remain correct when refactoring.</span></span>  <span data-ttu-id="aba77-208">Эта возможность также полезна для прикрепления связей MVC контроллера model-view-controller и инициирования событий изменения свойств.</span><span class="sxs-lookup"><span data-stu-id="aba77-208">This feature is also useful for hooking up model-view-controller MVC links and firing property changed events.</span></span>

[<span data-ttu-id="aba77-209">Интерполяция строк</span><span class="sxs-lookup"><span data-stu-id="aba77-209">String interpolation</span></span>](../programming-guide/language-features/strings/interpolated-strings.md)

<span data-ttu-id="aba77-210">Для создания строк можно использовать выражения интерполяции строк.</span><span class="sxs-lookup"><span data-stu-id="aba77-210">You can use string interpolation expressions to construct strings.</span></span>  <span data-ttu-id="aba77-211">Интерполированное строковое выражение выглядит как шаблонная строка, которая содержит выражения.</span><span class="sxs-lookup"><span data-stu-id="aba77-211">An interpolated string expression looks like a template string that contains expressions.</span></span>  <span data-ttu-id="aba77-212">Интерполированную строку проще понять с точки зрения аргументов, чем [составное форматирование](../../standard/base-types/composite-formatting.md).</span><span class="sxs-lookup"><span data-stu-id="aba77-212">An interpolated string is easier to understand with respect to arguments than [Composite Formatting](../../standard/base-types/composite-formatting.md).</span></span>

[<span data-ttu-id="aba77-213">Доступ к членам и индексация с проверкой на значение NULL</span><span class="sxs-lookup"><span data-stu-id="aba77-213">Null-conditional member access and indexing</span></span>](../language-reference/operators/null-conditional-operators.md)

<span data-ttu-id="aba77-214">Прежде чем осуществлять доступ к элементу (`?.`) или выполнять операцию с индексом (`?[]`), можно протестировать значение null в очень простой синтаксической конструкции.</span><span class="sxs-lookup"><span data-stu-id="aba77-214">You can test for null in a very light syntactic way before performing a member access (`?.`) or index (`?[]`) operation.</span></span>  <span data-ttu-id="aba77-215">Эти операторы позволяют писать меньше кода для проверок значений null, особенно если речь идет о внедрении в структуры данных.</span><span class="sxs-lookup"><span data-stu-id="aba77-215">These operators help you write less code to handle null checks, especially for descending into data structures.</span></span>  <span data-ttu-id="aba77-216">Если левый операнд или объектная ссылка имеет значение null, операция также возвращает значение null.</span><span class="sxs-lookup"><span data-stu-id="aba77-216">If the left operand or object reference is null, the operations returns null.</span></span>

[<span data-ttu-id="aba77-217">Многострочные строковые литералы</span><span class="sxs-lookup"><span data-stu-id="aba77-217">Multi-line string literals</span></span>](../programming-guide/language-features/strings/string-basics.md)

<span data-ttu-id="aba77-218">Строковые литералы могут содержать последовательности новых строк.</span><span class="sxs-lookup"><span data-stu-id="aba77-218">String literals can contain newline sequences.</span></span>  <span data-ttu-id="aba77-219">Прежний обходной путь, связанный с использованием `<xml><![CDATA[...text with newlines...]]></xml>.Value`, больше не потребуется.</span><span class="sxs-lookup"><span data-stu-id="aba77-219">You no longer need the old work around of using `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span></span>

<span data-ttu-id="aba77-220">**Комментарии**</span><span class="sxs-lookup"><span data-stu-id="aba77-220">**Comments**</span></span>

<span data-ttu-id="aba77-221">Комментарии можно поместить после неявных продолжений строк, внутри выражений инициализатора и среди условий выражения LINQ.</span><span class="sxs-lookup"><span data-stu-id="aba77-221">You can put comments after implicit line continuations, inside initializer expressions, and among LINQ expression terms.</span></span>

<span data-ttu-id="aba77-222">**Оптимизированное разрешение полных доменных имен**</span><span class="sxs-lookup"><span data-stu-id="aba77-222">**Smarter fully-qualified name resolution**</span></span>

<span data-ttu-id="aba77-223">Имея код, например `Threading.Thread.Sleep(1000)`, Visual Basic выполняла поиск пространства имен «Потоки», обнаруживала, что это пространство имен было неоднозначным в потоках System.Threading и System.Windows.Threading, и сообщала об ошибке.</span><span class="sxs-lookup"><span data-stu-id="aba77-223">Given code such as `Threading.Thread.Sleep(1000)`, Visual Basic used to look up the namespace "Threading", discover it was ambiguous between System.Threading and System.Windows.Threading, and then report an error.</span></span>  <span data-ttu-id="aba77-224">Теперь Visual Basic рассматривает оба возможных пространства имен одновременно.</span><span class="sxs-lookup"><span data-stu-id="aba77-224">Visual Basic now considers both possible namespaces together.</span></span>  <span data-ttu-id="aba77-225">При отображении списка завершения редактор Visual Studio отображает в нем элементы обоих типов.</span><span class="sxs-lookup"><span data-stu-id="aba77-225">If you show the completion list, the Visual Studio editor lists members from both types in the completion list.</span></span>

<span data-ttu-id="aba77-226">**Литералы даты с годом на первом месте**</span><span class="sxs-lookup"><span data-stu-id="aba77-226">**Year-first date literals**</span></span>

<span data-ttu-id="aba77-227">Литералы даты могут быть указаны в формате гггг-мм-дд, `#2015-03-17 16:10 PM#`.</span><span class="sxs-lookup"><span data-stu-id="aba77-227">You can have date literals in yyyy-mm-dd format, `#2015-03-17 16:10 PM#`.</span></span>

<span data-ttu-id="aba77-228">**Свойства интерфейса Readonly**</span><span class="sxs-lookup"><span data-stu-id="aba77-228">**Readonly interface properties**</span></span>

<span data-ttu-id="aba77-229">С помощью свойства readwrite можно реализовать свойства интерфейса readonly.</span><span class="sxs-lookup"><span data-stu-id="aba77-229">You can implement readonly interface properties using a readwrite property.</span></span> <span data-ttu-id="aba77-230">Интерфейс гарантирует минимальную функциональность и не препятствует функционированию реализующего класса, который разрешает задавать значения для свойства.</span><span class="sxs-lookup"><span data-stu-id="aba77-230">The interface guarantees minimum functionality, and it does not stop an implementing class from allowing the property to be set.</span></span>

[<span data-ttu-id="aba77-231">TypeOf \<expr> IsNot \<type></span><span class="sxs-lookup"><span data-stu-id="aba77-231">TypeOf \<expr> IsNot \<type></span></span>](../language-reference/operators/typeof-operator.md)

<span data-ttu-id="aba77-232">Для удобства чтения кода `TypeOf` теперь можно использовать с `IsNot`.</span><span class="sxs-lookup"><span data-stu-id="aba77-232">For more readability of your code, you can now use `TypeOf` with `IsNot`.</span></span>

[<span data-ttu-id="aba77-233">#Disable Warning \<ID> и #Enable Warning \<ID></span><span class="sxs-lookup"><span data-stu-id="aba77-233">#Disable Warning \<ID> and #Enable Warning \<ID></span></span>](../language-reference/directives/disable-enable.md)

<span data-ttu-id="aba77-234">Можно отключить и включить конкретные предупреждения для областей в исходном файле.</span><span class="sxs-lookup"><span data-stu-id="aba77-234">You can disable and enable specific warnings for regions within a source file.</span></span>

<span data-ttu-id="aba77-235">**Усовершенствования комментариев XML-документации**</span><span class="sxs-lookup"><span data-stu-id="aba77-235">**XML doc comment improvements**</span></span>

<span data-ttu-id="aba77-236">При написании комментариев к документу разработчик получает доступ к интеллектуальному редактору и поддержку при сборке, что позволяет проверять названия параметров, грамотно обрабатывать `crefs` (универсальные типы, операторы и т. д.), выделение цветом и рефакторинг.</span><span class="sxs-lookup"><span data-stu-id="aba77-236">When writing doc comments, you get smart editor and build support for validating parameter names, proper handling of `crefs` (generics, operators, etc.), colorizing, and refactoring.</span></span>

[<span data-ttu-id="aba77-237">Определения частичных модулей и интерфейсов</span><span class="sxs-lookup"><span data-stu-id="aba77-237">Partial module and interface definitions</span></span>](../language-reference/modifiers/partial.md)

<span data-ttu-id="aba77-238">Помимо классов и структур можно также объявлять частичные модули и интерфейсы.</span><span class="sxs-lookup"><span data-stu-id="aba77-238">In addition to classes and structs, you can declare partial modules and interfaces.</span></span>

[<span data-ttu-id="aba77-239">Директивы #Region внутри основной части метода</span><span class="sxs-lookup"><span data-stu-id="aba77-239">#Region directives inside method bodies</span></span>](../language-reference/directives/region-directive.md)

<span data-ttu-id="aba77-240">Разделители #Region... #End Region можно поместить в любом месте файла, внутри функций и даже в основной части функции.</span><span class="sxs-lookup"><span data-stu-id="aba77-240">You can put #Region…#End Region delimiters anywhere in a file, inside functions, and even spanning across function bodies.</span></span>

[<span data-ttu-id="aba77-241">Определения переопределений являются неявными перегрузками</span><span class="sxs-lookup"><span data-stu-id="aba77-241">Overrides definitions are implicitly overloads</span></span>](../language-reference/modifiers/overrides.md)

<span data-ttu-id="aba77-242">Если добавить в определение модификатор `Overrides`, компилятор неявно добавляет `Overloads`, чтобы в общих случаях можно было вводить меньше кода.</span><span class="sxs-lookup"><span data-stu-id="aba77-242">If you add the `Overrides` modifier to a definition, the compiler implicitly adds `Overloads` so that you can type less code in common cases.</span></span>

<span data-ttu-id="aba77-243">**В аргументах атрибутов можно использовать объекты CObj**</span><span class="sxs-lookup"><span data-stu-id="aba77-243">**CObj allowed in attributes arguments**</span></span>

<span data-ttu-id="aba77-244">Компилятор, используемый для вывода ошибки, связанной с тем, что при использовании в конструкциях атрибутов CObj(...) не являлся константой.</span><span class="sxs-lookup"><span data-stu-id="aba77-244">The compiler used to give an error that CObj(…) was not a constant when used in attribute constructions.</span></span>

<span data-ttu-id="aba77-245">**Объявление и использование неоднозначных методов из разных интерфейсов**</span><span class="sxs-lookup"><span data-stu-id="aba77-245">**Declaring and consuming ambiguous methods from different interfaces**</span></span>

<span data-ttu-id="aba77-246">Ранее следующий код выдавал ошибки, которые не позволяли объявить `IMock` или вызвать `GetDetails` (если эти значения были объявлены в C#).</span><span class="sxs-lookup"><span data-stu-id="aba77-246">Previously the following code yielded errors that prevented you from declaring `IMock` or from calling `GetDetails` (if these had been declared in C#):</span></span>

```vb
Interface ICustomer
  Sub GetDetails(x As Integer)
End Interface

Interface ITime
  Sub GetDetails(x As String)
End Interface

Interface IMock : Inherits ICustomer, ITime
  Overloads Sub GetDetails(x As Char)
End Interface

Interface IMock2 : Inherits ICustomer, ITime
End Interface
```

<span data-ttu-id="aba77-247">Теперь компилятор использует стандартные правила разрешения перегрузки, чтобы выбрать оптимальную `GetDetails` для вызова, а в Visual Basic можно объявить связи интерфейса, как показано в примере.</span><span class="sxs-lookup"><span data-stu-id="aba77-247">Now the compiler will use normal overload resolution rules to choose the most appropriate `GetDetails` to call, and you can declare interface relationships in Visual Basic like those shown in the sample.</span></span>

## <a name="see-also"></a><span data-ttu-id="aba77-248">См. также</span><span class="sxs-lookup"><span data-stu-id="aba77-248">See also</span></span>

- [<span data-ttu-id="aba77-249">Новые возможности Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="aba77-249">What's New in Visual Studio 2017</span></span>](/visualstudio/ide/whats-new-visual-studio-2017)
- [<span data-ttu-id="aba77-250">Новые возможности Visual Studio 2019</span><span class="sxs-lookup"><span data-stu-id="aba77-250">What's New in Visual Studio 2019</span></span>](/visualstudio/ide/whats-new-visual-studio-2019)
