---
title: Обзор языка C# — руководство по C#
description: Вы еще не знакомы с C#? Изучите основы этого языка. Начните с этого обзора.
ms.date: 01/28/2021
ms.openlocfilehash: b58aed5e75be8c71df295506480a2d97c22675aa
ms.sourcegitcommit: 42d436ebc2a7ee02fc1848c7742bc7d80e13fc2f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/04/2021
ms.locfileid: "102104917"
---
# <a name="a-tour-of-the-c-language"></a><span data-ttu-id="4bdbe-105">Краткий обзор языка C#</span><span class="sxs-lookup"><span data-stu-id="4bdbe-105">A tour of the C# language</span></span>

<span data-ttu-id="4bdbe-106">C# (произносится как "си шарп") — современный объектно-ориентированный и типобезопасный язык программирования.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-106">C# (pronounced "See Sharp") is a modern, object-oriented, and type-safe programming language.</span></span> <span data-ttu-id="4bdbe-107">C# позволяет разработчикам создавать множество типов безопасных и надежных приложений, работающих в экосистеме .NET.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-107">C# enables developers to build many types of secure and robust applications that run in the .NET ecosystem.</span></span> <span data-ttu-id="4bdbe-108">C# относится к широко известному семейству языков C, и покажется хорошо знакомым любому, кто работал с C, C++, Java или JavaScript.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-108">C# has its roots in the C family of languages and will be immediately familiar to C, C++, Java, and JavaScript programmers.</span></span> <span data-ttu-id="4bdbe-109">Здесь представлен обзор основных компонентов языка C# 8 и более ранних версий.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-109">This tour provides an overview of the major components of the language in C# 8 and earlier.</span></span> <span data-ttu-id="4bdbe-110">Если вы хотите изучить язык с помощью интерактивных примеров, рекомендуем поработать с [вводными руководствами по C#](./tutorials/index.md).</span><span class="sxs-lookup"><span data-stu-id="4bdbe-110">If you want to explore the language through interactive examples, try the [introduction to C#](./tutorials/index.md) tutorials.</span></span>

<span data-ttu-id="4bdbe-111">C# — это объектно- и ***компонентно-ориентированный*** язык программирования.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-111">C# is an object-oriented, ***component-oriented*** programming language.</span></span> <span data-ttu-id="4bdbe-112">C# предоставляет языковые конструкции для непосредственной поддержки такой концепции работы. Благодаря этому C# подходит для создания и применения программных компонентов.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-112">C# provides language constructs to directly support these concepts, making C# a natural language in which to create and use software components.</span></span> <span data-ttu-id="4bdbe-113">С момента создания язык C# обогатился функциями для поддержки новых рабочих нагрузок и современными рекомендациями по разработке ПО.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-113">Since its origin, C# has added features to support new workloads and emerging software design practices.</span></span>

<span data-ttu-id="4bdbe-114">Вот лишь несколько функций языка C#, которые позволяют создавать надежные и устойчивые приложения.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-114">Several C# features help create robust and durable applications.</span></span> <span data-ttu-id="4bdbe-115">[\***Сборка мусора** _](../../standard/garbage-collection/index.md) автоматически освобождает память, занятую недоступными неиспользуемыми объектами.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-115">[\***Garbage collection** _](../../standard/garbage-collection/index.md) automatically reclaims memory occupied by unreachable unused objects.</span></span> <span data-ttu-id="4bdbe-116">[_\*_Типы, допускающие значение null,_\*_](../nullable-references.md) обеспечивают защиту от переменных, которые не ссылаются на выделенные объекты.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-116">[_*_Nullable types_*_](../nullable-references.md) guard against variables that don't refer to allocated objects.</span></span> <span data-ttu-id="4bdbe-117">[_\*_Обработка исключений_\*_](../programming-guide/exceptions/index.md) предоставляет структурированный и расширяемый подход к обнаружению ошибок и восстановлению после них.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-117">[_*_Exception handling_*_](../programming-guide/exceptions/index.md) provides a structured and extensible approach to error detection and recovery.</span></span> <span data-ttu-id="4bdbe-118">[_\*_Лямбда-выражения_\*_](../language-reference/operators/lambda-expressions.md) поддерживают приемы функционального программирования.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-118">[_*_Lambda expressions_*_](../language-reference/operators/lambda-expressions.md) support functional programming techniques.</span></span> <span data-ttu-id="4bdbe-119">[_\*_Синтаксис LINQ_\*_](../linq/index.md) создает общий шаблон для работы с данными из любого источника.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-119">[_*_Language Integrated Query (LINQ)_*_](../linq/index.md) syntax creates a common pattern for working with data from any source.</span></span> <span data-ttu-id="4bdbe-120">Поддержка языков для [_\*_асинхронных операций_\*_](../programming-guide/concepts/async/index.md) предоставляет синтаксис для создания распределенных систем.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-120">Language support for [_*_asynchronous operations_*_](../programming-guide/concepts/async/index.md) provides syntax for building distributed systems.</span></span> <span data-ttu-id="4bdbe-121">В C# действует [_ *_единая система типов_*\*](../programming-guide/types/index.md).</span><span class="sxs-lookup"><span data-stu-id="4bdbe-121">C# has a [_ *_unified type system_*\*](../programming-guide/types/index.md).</span></span> <span data-ttu-id="4bdbe-122">Все типы C#, включая типы-примитивы, такие как `int` и `double`, наследуют от одного корневого типа `object`.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-122">All C# types, including primitive types such as `int` and `double`, inherit from a single root `object` type.</span></span> <span data-ttu-id="4bdbe-123">Все типы используют общий набор операций,</span><span class="sxs-lookup"><span data-stu-id="4bdbe-123">All types share a set of common operations.</span></span> <span data-ttu-id="4bdbe-124">а значения любого типа можно хранить, передавать и обрабатывать схожим образом.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-124">Values of any type can be stored, transported, and operated upon in a consistent manner.</span></span> <span data-ttu-id="4bdbe-125">Более того, C# поддерживает как определяемые пользователями [ссылочные типы](../language-reference/builtin-types/reference-types.md), так и [типы значений](../language-reference/builtin-types/value-types.md).</span><span class="sxs-lookup"><span data-stu-id="4bdbe-125">Furthermore, C# supports both user-defined [reference types](../language-reference/builtin-types/reference-types.md) and [value types](../language-reference/builtin-types/value-types.md).</span></span> <span data-ttu-id="4bdbe-126">C# позволяет динамически выделять объекты и хранить упрощенные структуры в стеке.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-126">C# allows dynamic allocation of objects and in-line storage of lightweight structures.</span></span> <span data-ttu-id="4bdbe-127">C# поддерживает универсальные методы и типы, обеспечивающие повышенную безопасность типов и производительность.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-127">C# supports generic methods and types, which provide increased type safety and performance.</span></span> <span data-ttu-id="4bdbe-128">C# предоставляет итераторы, которые позволяют разработчикам классов коллекций определять пользовательские варианты поведения для клиентского кода.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-128">C# provides iterators, which enable implementers of collection classes to define custom behaviors for client code.</span></span>

<span data-ttu-id="4bdbe-129">В C# особое внимание уделяется ***управлению версиями*** для обеспечения совместимости программ и библиотек при их изменении.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-129">C# emphasizes ***versioning*** to ensure programs and libraries can evolve over time in a compatible manner.</span></span> <span data-ttu-id="4bdbe-130">Вопросы управления версиями существенно повлияли на такие аспекты разработки C#, как раздельные модификаторы `virtual` и `override`, правила разрешения перегрузки методов и поддержка явного объявления членов интерфейса.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-130">Aspects of C#'s design that were directly influenced by versioning considerations include the separate `virtual` and `override` modifiers, the rules for method overload resolution, and support for explicit interface member declarations.</span></span>

## <a name="net-architecture"></a><span data-ttu-id="4bdbe-131">Архитектура .NET</span><span class="sxs-lookup"><span data-stu-id="4bdbe-131">.NET architecture</span></span>

<span data-ttu-id="4bdbe-132">Программы C# выполняются в .NET, виртуальной системе выполнения, вызывающей общеязыковую среду выполнения (CLR) и набор библиотек классов.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-132">C# programs run on .NET, a virtual execution system called the common language runtime (CLR) and a set of class libraries.</span></span> <span data-ttu-id="4bdbe-133">Среда CLR — это реализация общеязыковой инфраструктуры языка (CLI), являющейся международным стандартом, от корпорации Майкрософт.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-133">The CLR is the implementation by Microsoft of the common language infrastructure (CLI), an international standard.</span></span> <span data-ttu-id="4bdbe-134">CLI является основой для создания сред выполнения и разработки, в которых языки и библиотеки прозрачно работают друг с другом.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-134">The CLI is the basis for creating execution and development environments in which languages and libraries work together seamlessly.</span></span>

<span data-ttu-id="4bdbe-135">Исходный код, написанный на языке C# компилируется в [промежуточный язык (IL)](../../standard/managed-code.md), который соответствует спецификациям CLI.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-135">Source code written in C# is compiled into an [intermediate language (IL)](../../standard/managed-code.md) that conforms to the CLI specification.</span></span> <span data-ttu-id="4bdbe-136">Код на языке IL и ресурсы, в том числе растровые изображения и строки, сохраняются в сборке, обычно с расширением *.dll*.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-136">The IL code and resources, such as bitmaps and strings, are stored in an assembly, typically with an extension of *.dll*.</span></span> <span data-ttu-id="4bdbe-137">Сборка содержит манифест с информацией о типах, версии, языке и региональных параметрах для этой сборки.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-137">An assembly contains a manifest that provides information about the assembly's types, version, and culture.</span></span>

<span data-ttu-id="4bdbe-138">При выполнении программы C# сборка загружается в среду CLR.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-138">When the C# program is executed, the assembly is loaded into the CLR.</span></span> <span data-ttu-id="4bdbe-139">Среда CLR выполняет JIT-компиляцию из кода на языке IL в инструкции машинного языка.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-139">The CLR performs Just-In-Time (JIT) compilation to convert the IL code to native machine instructions.</span></span> <span data-ttu-id="4bdbe-140">Среда CLR также выполняет другие операции, например, автоматическую сборку мусора, обработку исключений и управление ресурсами.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-140">The CLR provides other services related to automatic garbage collection, exception handling, and resource management.</span></span> <span data-ttu-id="4bdbe-141">Код, выполняемый средой CLR, иногда называют "управляемым кодом", чтобы подчеркнуть отличия этого подхода от "неуправляемого кода", который сразу компилируется в машинный язык для определенной платформы.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-141">Code that's executed by the CLR is sometimes referred to as "managed code," in contrast to "unmanaged code," which is compiled into native machine language that targets a specific platform.</span></span>

<span data-ttu-id="4bdbe-142">Обеспечение взаимодействия между языками является ключевой особенностью .NET.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-142">Language interoperability is a key feature of .NET.</span></span> <span data-ttu-id="4bdbe-143">Код IL, созданный компилятором C#, соответствует спецификации общих типов (CTS).</span><span class="sxs-lookup"><span data-stu-id="4bdbe-143">IL code produced by the C# compiler conforms to the Common Type Specification (CTS).</span></span> <span data-ttu-id="4bdbe-144">Код IL, созданный из кода на C# , может взаимодействовать с кодом, созданным из версий .NET для языков F# , Visual Basic, C++ и любых других из более чем 20 языков, совместимых с CTS.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-144">IL code generated from C# can interact with code that was generated from the .NET versions of F#, Visual Basic, C++, or any of more than 20 other CTS-compliant languages.</span></span> <span data-ttu-id="4bdbe-145">Одна сборка может содержать несколько модулей, написанных на разных языках .NET, и все типы могут ссылаться друг на друга, как если бы они были написаны на одном языке.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-145">A single assembly may contain multiple modules written in different .NET languages, and the types can reference each other as if they were written in the same language.</span></span>

<span data-ttu-id="4bdbe-146">В дополнение к службам времени выполнения .NET также включает расширенные библиотеки.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-146">In addition to the run time services, .NET also includes extensive libraries.</span></span> <span data-ttu-id="4bdbe-147">Эти библиотеки поддерживают множество различных рабочих нагрузок.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-147">These libraries support many different workloads.</span></span> <span data-ttu-id="4bdbe-148">Они упорядочены по пространствам имен, которые предоставляют разные полезные возможности: от операций файлового ввода и вывода до управления строками и синтаксического анализа XML, от платформ веб-приложений до элементов управления Windows Forms.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-148">They're organized into namespaces that provide a wide variety of useful functionality for everything from file input and output to string manipulation to XML parsing, to web application frameworks to Windows Forms controls.</span></span> <span data-ttu-id="4bdbe-149">Обычно приложение C# активно используют библиотеку классов .NET для решения типовых задач.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-149">The typical C# application uses the .NET class library extensively to handle common "plumbing" chores.</span></span>

<span data-ttu-id="4bdbe-150">Дополнительные сведения о .NET, см. в статье [Обзор .NET](../../core/introduction.md).</span><span class="sxs-lookup"><span data-stu-id="4bdbe-150">For more information about .NET, see [Overview of .NET](../../core/introduction.md).</span></span>

## <a name="hello-world"></a><span data-ttu-id="4bdbe-151">Здравствуй, мир</span><span class="sxs-lookup"><span data-stu-id="4bdbe-151">Hello world</span></span>

<span data-ttu-id="4bdbe-152">Для первого знакомства с языком программирования традиционно используется программа "Hello, World".</span><span class="sxs-lookup"><span data-stu-id="4bdbe-152">The "Hello, World" program is traditionally used to introduce a programming language.</span></span> <span data-ttu-id="4bdbe-153">Вот ее пример на C#:</span><span class="sxs-lookup"><span data-stu-id="4bdbe-153">Here it is in C#:</span></span>

:::code language="csharp" interactive="try-dotnet" source="./snippets/shared/HelloWorld.cs":::

<span data-ttu-id="4bdbe-154">Программа "Hello, World" начинается с директивы `using`, которая ссылается на пространство имен `System`.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-154">The "Hello, World" program starts with a `using` directive that references the `System` namespace.</span></span> <span data-ttu-id="4bdbe-155">Пространства имен позволяют иерархически упорядочивать программы и библиотеки C#.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-155">Namespaces provide a hierarchical means of organizing C# programs and libraries.</span></span> <span data-ttu-id="4bdbe-156">Пространства имен содержат типы и другие пространства имен. Например, пространство имен `System` содержит несколько типов (в том числе используемый в нашей программе класс `Console`) и несколько других пространств имен, таких как `IO` и `Collections`.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-156">Namespaces contain types and other namespaces—for example, the `System` namespace contains a number of types, such as the `Console` class referenced in the program, and a number of other namespaces, such as `IO` and `Collections`.</span></span> <span data-ttu-id="4bdbe-157">Директива `using`, которая ссылается на пространство имен, позволяет использовать типы из этого пространства имен без указания полного имени.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-157">A `using` directive that references a given namespace enables unqualified use of the types that are members of that namespace.</span></span> <span data-ttu-id="4bdbe-158">Благодаря директиве `using` в коде программы можно использовать сокращенное имя `Console.WriteLine` вместо полного варианта `System.Console.WriteLine`.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-158">Because of the `using` directive, the program can use `Console.WriteLine` as shorthand for `System.Console.WriteLine`.</span></span>

<span data-ttu-id="4bdbe-159">Класс `Hello`, объявленный в программе "Hello, World", имеет только один член — это метод с именем `Main`.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-159">The `Hello` class declared by the "Hello, World" program has a single member, the method named `Main`.</span></span> <span data-ttu-id="4bdbe-160">Метод `Main` объявлен с модификатором `static`.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-160">The `Main` method is declared with the `static` modifier.</span></span> <span data-ttu-id="4bdbe-161">Методы экземпляра могут ссылаться на конкретный экземпляр объекта, используя ключевое слово `this`, а статические методы работают без ссылки на конкретный объект.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-161">While instance methods can reference a particular enclosing object instance using the keyword `this`, static methods operate without reference to a particular object.</span></span> <span data-ttu-id="4bdbe-162">По стандартному соглашению точкой входа программы C# является статический метод с именем `Main`.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-162">By convention, a static method named `Main` serves as the entry point of a C# program.</span></span>

<span data-ttu-id="4bdbe-163">Выходные данные программы создаются в методе `WriteLine` класса `Console` из пространства имен `System`.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-163">The output of the program is produced by the `WriteLine` method of the `Console` class in the `System` namespace.</span></span> <span data-ttu-id="4bdbe-164">Этот класс предоставляется библиотеками стандартных классов, ссылки на которые компилятор по умолчанию добавляет автоматически.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-164">This class is provided by the standard class libraries, which, by default, are automatically referenced by the compiler.</span></span>

## <a name="types-and-variables"></a><span data-ttu-id="4bdbe-165">Типы и переменные</span><span class="sxs-lookup"><span data-stu-id="4bdbe-165">Types and variables</span></span>

<span data-ttu-id="4bdbe-166">В C# существуют две разновидности типов: *ссылочные типы* и *типы значений*.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-166">There are two kinds of types in C#: *value types* and *reference types*.</span></span> <span data-ttu-id="4bdbe-167">Переменные типа значений содержат непосредственно данные,</span><span class="sxs-lookup"><span data-stu-id="4bdbe-167">Variables of value types directly contain their data.</span></span> <span data-ttu-id="4bdbe-168">а в переменных ссылочных типов хранятся ссылки на нужные данные, которые именуются объектами.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-168">Variables of reference types store references to their data, the latter being known as objects.</span></span> <span data-ttu-id="4bdbe-169">Две переменные ссылочного типа могут ссылаться на один и тот же объект, поэтому может случиться так, что операции над одной переменной затронут объект, на который ссылается другая переменная.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-169">With reference types, it's possible for two variables to reference the same object and possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="4bdbe-170">Каждая переменная типа значения имеет собственную копию данных, и операции над одной переменной не могут затрагивать другую (за исключением переменных параметров `ref` и `out`).</span><span class="sxs-lookup"><span data-stu-id="4bdbe-170">With value types, the variables each have their own copy of the data, and it isn't possible for operations on one to affect the other (except for `ref` and `out` parameter variables).</span></span>

<span data-ttu-id="4bdbe-171">***Идентификатор*** является именем переменной.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-171">An ***identifier*** is a variable name.</span></span> <span data-ttu-id="4bdbe-172">Идентификатор — это последовательность символов Юникода без пробелов.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-172">An identifier is a sequence of unicode characters without any whitespace.</span></span> <span data-ttu-id="4bdbe-173">Идентификатор может быть зарезервированным словом C#, если он имеет префикс `@`.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-173">An identifier may be a C# reserved word, if it's prefixed by `@`.</span></span> <span data-ttu-id="4bdbe-174">При взаимодействии с другими языками в качестве идентификатора может быть полезно использовать зарезервированное слово.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-174">Using a reserved word as an identifier can be useful when interacting with other languages.</span></span>

<span data-ttu-id="4bdbe-175">Типы значений в C# делятся на *простые типы*, *типы перечислений*, *типы структур*, *типы, допускающие значение NULL*, и *типы значений кортежей*.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-175">C#'s value types are further divided into *simple types*, *enum types*, *struct types*, *nullable value types*, and *tuple value types*.</span></span> <span data-ttu-id="4bdbe-176">Ссылочные типы в C# подразделяются на *типы классов*, *типы интерфейсов*, *типы массивов* и *типы делегатов*.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-176">C#'s reference types are further divided into *class types*, *interface types*, *array types*, and *delegate types*.</span></span>

<span data-ttu-id="4bdbe-177">Далее представлены общие сведения о системе типов в C#.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-177">The following outline provides an overview of C#'s type system.</span></span>

- [<span data-ttu-id="4bdbe-178">Типы значений</span><span class="sxs-lookup"><span data-stu-id="4bdbe-178">Value types</span></span>](../language-reference/builtin-types/value-types.md)
  - [<span data-ttu-id="4bdbe-179">Простые типы</span><span class="sxs-lookup"><span data-stu-id="4bdbe-179">Simple types</span></span>](../language-reference/builtin-types/value-types.md#built-in-value-types)
    - <span data-ttu-id="4bdbe-180">[Целочисленный со знаком](../language-reference/builtin-types/integral-numeric-types.md): `sbyte`, `short`, `int`, `long`.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-180">[Signed integral](../language-reference/builtin-types/integral-numeric-types.md): `sbyte`, `short`, `int`, `long`</span></span>
    - <span data-ttu-id="4bdbe-181">[Целочисленный без знака](../language-reference/builtin-types/integral-numeric-types.md): `byte`, `ushort`, `uint`, `ulong`.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-181">[Unsigned integral](../language-reference/builtin-types/integral-numeric-types.md): `byte`, `ushort`, `uint`, `ulong`</span></span>
    - <span data-ttu-id="4bdbe-182">[Символы Юникода](../../standard/base-types/character-encoding-introduction.md): `char`, который представляет блок кода в кодировке UTF-16.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-182">[Unicode characters](../../standard/base-types/character-encoding-introduction.md): `char`, which represents a UTF-16 code unit</span></span>
    - <span data-ttu-id="4bdbe-183">[Бинарный оператор IEEE с плавающей запятой](../language-reference/builtin-types/floating-point-numeric-types.md): `float`, `double`.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-183">[IEEE binary floating-point](../language-reference/builtin-types/floating-point-numeric-types.md): `float`, `double`</span></span>
    - <span data-ttu-id="4bdbe-184">[Десятичное значение с повышенной точностью и плавающей запятой](../language-reference/builtin-types/floating-point-numeric-types.md): `decimal`.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-184">[High-precision decimal floating-point](../language-reference/builtin-types/floating-point-numeric-types.md): `decimal`</span></span>
    - <span data-ttu-id="4bdbe-185">Логический: `bool`, используется для представления логических значений, которые могут иметь значение `true` или `false`.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-185">Boolean: `bool`, which represents Boolean values—values that are either `true` or `false`</span></span>
  - [<span data-ttu-id="4bdbe-186">Типы перечисления</span><span class="sxs-lookup"><span data-stu-id="4bdbe-186">Enum types</span></span>](../language-reference/builtin-types/enum.md)
    - <span data-ttu-id="4bdbe-187">Пользовательские типы в формате `enum E {...}`.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-187">User-defined types of the form `enum E {...}`.</span></span> <span data-ttu-id="4bdbe-188">Тип `enum` является отдельным типом со списком именованных констант.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-188">An `enum` type is a distinct type with named constants.</span></span> <span data-ttu-id="4bdbe-189">Каждый тип `enum` имеет базовый тип, в роли которого выступает один из восьми целочисленных типов.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-189">Every `enum` type has an underlying type, which must be one of the eight integral types.</span></span> <span data-ttu-id="4bdbe-190">Набор значений типа `enum` аналогичен набору значений его базового типа.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-190">The set of values of an `enum` type is the same as the set of values of the underlying type.</span></span>
  - [<span data-ttu-id="4bdbe-191">Типы структур</span><span class="sxs-lookup"><span data-stu-id="4bdbe-191">Struct types</span></span>](../language-reference/builtin-types/struct.md)
    - <span data-ttu-id="4bdbe-192">Пользовательские типы в формате `struct S {...}`</span><span class="sxs-lookup"><span data-stu-id="4bdbe-192">User-defined types of the form `struct S {...}`</span></span>
  - [<span data-ttu-id="4bdbe-193">Типы значений, допускающие значение NULL</span><span class="sxs-lookup"><span data-stu-id="4bdbe-193">Nullable value types</span></span>](../language-reference/builtin-types/nullable-value-types.md)
    - <span data-ttu-id="4bdbe-194">Расширения других типов значений, допускающие значение `null`</span><span class="sxs-lookup"><span data-stu-id="4bdbe-194">Extensions of all other value types with a `null` value</span></span>
  - [<span data-ttu-id="4bdbe-195">Типы значений кортежей</span><span class="sxs-lookup"><span data-stu-id="4bdbe-195">Tuple value types</span></span>](../language-reference/builtin-types/value-tuples.md)
    - <span data-ttu-id="4bdbe-196">Пользовательские типы в формате `(T1, T2, ...)`</span><span class="sxs-lookup"><span data-stu-id="4bdbe-196">User-defined types of the form `(T1, T2, ...)`</span></span>
- [<span data-ttu-id="4bdbe-197">Ссылочные типы</span><span class="sxs-lookup"><span data-stu-id="4bdbe-197">Reference types</span></span>](../language-reference/keywords/reference-types.md)
  - [<span data-ttu-id="4bdbe-198">Типы классов</span><span class="sxs-lookup"><span data-stu-id="4bdbe-198">Class types</span></span>](../language-reference/keywords/class.md)
    - <span data-ttu-id="4bdbe-199">Исходный базовым классом для всех типов: `object`</span><span class="sxs-lookup"><span data-stu-id="4bdbe-199">Ultimate base class of all other types: `object`</span></span>
    - <span data-ttu-id="4bdbe-200">[Строки в Юникоде](../../standard/base-types/character-encoding-introduction.md): `string`, который представляет последовательность блоков кода в кодировке UTF-16.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-200">[Unicode strings](../../standard/base-types/character-encoding-introduction.md): `string`, which represents a sequence of UTF-16 code units</span></span>
    - <span data-ttu-id="4bdbe-201">Пользовательские типы в формате `class C {...}`</span><span class="sxs-lookup"><span data-stu-id="4bdbe-201">User-defined types of the form `class C {...}`</span></span>
  - [<span data-ttu-id="4bdbe-202">Типы интерфейсов</span><span class="sxs-lookup"><span data-stu-id="4bdbe-202">Interface types</span></span>](../language-reference/keywords/interface.md)
    - <span data-ttu-id="4bdbe-203">Пользовательские типы в формате `interface I {...}`</span><span class="sxs-lookup"><span data-stu-id="4bdbe-203">User-defined types of the form `interface I {...}`</span></span>
  - [<span data-ttu-id="4bdbe-204">Типы массивов</span><span class="sxs-lookup"><span data-stu-id="4bdbe-204">Array types</span></span>](../programming-guide/arrays/index.md)
    - <span data-ttu-id="4bdbe-205">Одномерные, многомерные массивы и массивы массивов.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-205">Single-dimensional, multi-dimensional, and jagged.</span></span> <span data-ttu-id="4bdbe-206">Например, `int[]`, `int[,]` и `int[][]`.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-206">For example: `int[]`, `int[,]`, and `int[][]`</span></span>
  - [<span data-ttu-id="4bdbe-207">Типы делегатов</span><span class="sxs-lookup"><span data-stu-id="4bdbe-207">Delegate types</span></span>](../language-reference/builtin-types/reference-types.md#the-delegate-type)
    - <span data-ttu-id="4bdbe-208">Пользовательские типы в формате `delegate int D(...)`</span><span class="sxs-lookup"><span data-stu-id="4bdbe-208">User-defined types of the form `delegate int D(...)`</span></span>

<span data-ttu-id="4bdbe-209">Программы C# используют *объявления типов* для создания новых типов.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-209">C# programs use *type declarations* to create new types.</span></span> <span data-ttu-id="4bdbe-210">В объявлении типа указываются имя и члены нового типа.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-210">A type declaration specifies the name and the members of the new type.</span></span> <span data-ttu-id="4bdbe-211">Шесть категорий типов в C# определяются пользователем: типы классов, типы структур, типы интерфейсов, типы перечисления, типы делегатов и типы значений кортежей.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-211">Six of C#'s categories of types are user-definable: class types, struct types, interface types, enum types, delegate types, and tuple value types.</span></span>

- <span data-ttu-id="4bdbe-212">Тип `class` определяет структуру данных, которая содержит данные-члены (поля) и функции-члены (методы, свойства и т. д.).</span><span class="sxs-lookup"><span data-stu-id="4bdbe-212">A `class` type defines a data structure that contains data members (fields) and function members (methods, properties, and others).</span></span> <span data-ttu-id="4bdbe-213">Классы поддерживают механизмы одиночного наследования и полиморфизма, которые позволяют создавать производные классы, расширяющие и уточняющие определения базовых классов.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-213">Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</span></span>
- <span data-ttu-id="4bdbe-214">Тип `struct` похож на тип класса тем, что он представляет структуру с данными-членами и функциями-членами.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-214">A `struct` type is similar to a class type in that it represents a structure with data members and function members.</span></span> <span data-ttu-id="4bdbe-215">Но, в отличие от классов, структуры являются типами значений и обычно не требуют выделения памяти из кучи.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-215">However, unlike classes, structs are value types and don't typically require heap allocation.</span></span> <span data-ttu-id="4bdbe-216">Типы структуры не поддерживают определяемое пользователем наследование, и все типы структуры неявно наследуют от типа `object`.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-216">Struct types don't support user-specified inheritance, and all struct types implicitly inherit from type `object`.</span></span>
- <span data-ttu-id="4bdbe-217">Тип `interface` определяет контракт в виде именованного набора открытых элементов.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-217">An `interface` type defines a contract as a named set of public members.</span></span> <span data-ttu-id="4bdbe-218">Объект типа `class` или `struct`, реализующий `interface`, должен предоставить реализации для всех элементов интерфейса.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-218">A `class` or `struct` that implements an `interface` must provide implementations of the interface's members.</span></span> <span data-ttu-id="4bdbe-219">Тип `interface` может наследовать от нескольких базовых интерфейсов, а `class` или `struct` могут реализовывать несколько интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-219">An `interface` may inherit from multiple base interfaces, and a `class` or `struct` may implement multiple interfaces.</span></span>
- <span data-ttu-id="4bdbe-220">Тип `delegate` (делегат) представляющий ссылки на методы с конкретным списком параметров и типом возвращаемого значения.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-220">A `delegate` type represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="4bdbe-221">Делегаты позволяют использовать методы как сущности, сохраняя их в переменные и передавая в качестве параметров.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-221">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="4bdbe-222">Делегаты аналогичны типам функций, которые используются в функциональных языках.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-222">Delegates are analogous to function types provided by functional languages.</span></span> <span data-ttu-id="4bdbe-223">Их принцип работы близок к указателям функций из некоторых языков.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-223">They're also similar to the concept of function pointers found in some other languages.</span></span> <span data-ttu-id="4bdbe-224">В отличие от указателей функций, делегаты являются объектно-ориентированными и типобезопасными.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-224">Unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="4bdbe-225">Типы `class`, `struct`, `interface` и `delegate` поддерживают универсальные шаблоны, которые позволяют передавать им другие типы в качестве параметров.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-225">The `class`, `struct`, `interface`, and `delegate` types all support generics, whereby they can be parameterized with other types.</span></span>

<span data-ttu-id="4bdbe-226">C# поддерживает одномерные и многомерные массивы любого типа.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-226">C# supports single-dimensional and multi-dimensional arrays of any type.</span></span> <span data-ttu-id="4bdbe-227">В отличие от перечисленных выше типов, типы массивов не требуется объявлять перед использованием.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-227">Unlike the types listed above, array types don't have to be declared before they can be used.</span></span> <span data-ttu-id="4bdbe-228">Типы массивов можно сформировать, просто введя квадратные скобки после имени типа.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-228">Instead, array types are constructed by following a type name with square brackets.</span></span> <span data-ttu-id="4bdbe-229">Например, `int[]` является одномерным массивом значений типа `int`, а `int[,]` — двумерным массивом значений типа `int`, тогда как `int[][]` представляет собой одномерный массив одномерных массивов (или массив массивов) значений типа `int`.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-229">For example, `int[]` is a single-dimensional array of `int`, `int[,]` is a two-dimensional array of `int`, and `int[][]` is a single-dimensional array of single-dimensional arrays, or a "jagged" array, of `int`.</span></span>

<span data-ttu-id="4bdbe-230">Типы, допускающие значение NULL, не требуют отдельного определения.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-230">Nullable types don't require a separate definition.</span></span> <span data-ttu-id="4bdbe-231">Для каждого обычного типа `T`, который не допускает значение NULL, существует идентичный тип `T?`, который отличается только тем, что может содержать дополнительное значение `null`.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-231">For each non-nullable type `T`, there's a corresponding nullable type `T?`, which can hold an additional value, `null`.</span></span> <span data-ttu-id="4bdbe-232">Например, `int?` является типом, который может содержать любое 32-разрядное целое число или значение `null`, а `string?` — любое значение `string` или `null`.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-232">For instance, `int?` is a type that can hold any 32-bit integer or the value `null`, and `string?` is a type that can hold any `string` or the value `null`.</span></span>

<span data-ttu-id="4bdbe-233">Система типов в C# унифицирована таким образом, что значение любого типа можно рассматривать как `object` (объект).</span><span class="sxs-lookup"><span data-stu-id="4bdbe-233">C#'s type system is unified such that a value of any type can be treated as an `object`.</span></span> <span data-ttu-id="4bdbe-234">Каждый тип в C# является прямо или косвенно производным от типа класса `object`, и этот тип `object` является исходным базовым классом для всех типов.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-234">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="4bdbe-235">Чтобы значения ссылочного типа обрабатывались как объекты, им просто присваивается тип `object`.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-235">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="4bdbe-236">Чтобы значения типов значений обрабатывались как объекты, выполняются операции *упаковки-преобразования* и *распаковки-преобразования*.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-236">Values of value types are treated as objects by performing *boxing* and *unboxing operations*.</span></span> <span data-ttu-id="4bdbe-237">В следующем примере значение `int` преобразуется в `object`, а затем обратно в `int`.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-237">In the following example, an `int` value is converted to `object` and back again to `int`.</span></span>

:::code language="csharp" source="./snippets/shared/Program.cs" ID="boxing" :::

<span data-ttu-id="4bdbe-238">Если значение типа назначается ссылке `object`, для хранения значения выделяется упаковка.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-238">When a value of a value type is assigned to an `object` reference, a "box" is allocated to hold the value.</span></span> <span data-ttu-id="4bdbe-239">Эта упаковка является экземпляром ссылочного типа, и в нее копируется значение.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-239">That box is an instance of a reference type, and the value is copied into that box.</span></span> <span data-ttu-id="4bdbe-240">И наоборот, если ссылка типа `object` используется для типа значения, для соответствующего `object` выполняется проверка, является ли он упаковкой правильного типа.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-240">Conversely, when an `object` reference is cast to a value type, a check is made that the referenced `object` is a box of the correct value type.</span></span> <span data-ttu-id="4bdbe-241">Если эта проверка завершается успешно, копируется значение этой упаковки.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-241">If the check succeeds, the value in the box is copied to the value type.</span></span>

<span data-ttu-id="4bdbe-242">Унифицированная система типов C# фактически позволяет преобразовывать типы значений в ссылки `object` "по требованию".</span><span class="sxs-lookup"><span data-stu-id="4bdbe-242">C#'s unified type system effectively means that value types are treated as `object` references "on demand."</span></span> <span data-ttu-id="4bdbe-243">Такая унификация позволяет применять универсальные библиотеки, использующие тип `object`, со всеми типами, производными от `object`, включая как ссылочные типы, так и с типы значений.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-243">Because of the unification, general-purpose libraries that use type `object` can be used with all types that derive from `object`, including both reference types and value types.</span></span>

<span data-ttu-id="4bdbe-244">В C# существует несколько типов *переменных*, в том числе поля, элементы массива, локальные переменные и параметры.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-244">There are several kinds of *variables* in C#, including fields, array elements, local variables, and parameters.</span></span> <span data-ttu-id="4bdbe-245">Переменные представляют собой места хранения,</span><span class="sxs-lookup"><span data-stu-id="4bdbe-245">Variables represent storage locations.</span></span> <span data-ttu-id="4bdbe-246">и каждая переменная имеет тип, который определяет допустимые значения для хранения в этой переменной. Примеры представлены ниже.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-246">Every variable has a type that determines what values can be stored in the variable, as shown below.</span></span>

- <span data-ttu-id="4bdbe-247">Тип значения, не допускающий значения Null</span><span class="sxs-lookup"><span data-stu-id="4bdbe-247">Non-nullable value type</span></span>
  - <span data-ttu-id="4bdbe-248">Значение такого типа</span><span class="sxs-lookup"><span data-stu-id="4bdbe-248">A value of that exact type</span></span>
- <span data-ttu-id="4bdbe-249">Тип значения, допускающий значение Null</span><span class="sxs-lookup"><span data-stu-id="4bdbe-249">Nullable value type</span></span>
  - <span data-ttu-id="4bdbe-250">Значение `null` или значение такого типа</span><span class="sxs-lookup"><span data-stu-id="4bdbe-250">A `null` value or a value of that exact type</span></span>
- <span data-ttu-id="4bdbe-251">object</span><span class="sxs-lookup"><span data-stu-id="4bdbe-251">object</span></span>
  - <span data-ttu-id="4bdbe-252">Ссылка `null`, ссылка на объект любого ссылочного типа или ссылка на упакованное значение любого типа значения</span><span class="sxs-lookup"><span data-stu-id="4bdbe-252">A `null` reference, a reference to an object of any reference type, or a reference to a boxed value of any value type</span></span>
- <span data-ttu-id="4bdbe-253">Тип класса</span><span class="sxs-lookup"><span data-stu-id="4bdbe-253">Class type</span></span>
  - <span data-ttu-id="4bdbe-254">Ссылка `null`, ссылка на экземпляр такого типа класса или ссылка на экземпляр любого класса, производного от такого типа класса</span><span class="sxs-lookup"><span data-stu-id="4bdbe-254">A `null` reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type</span></span>
- <span data-ttu-id="4bdbe-255">Тип интерфейса</span><span class="sxs-lookup"><span data-stu-id="4bdbe-255">Interface type</span></span>
  - <span data-ttu-id="4bdbe-256">Ссылка `null`, ссылка на экземпляр типа класса, который реализует такой тип интерфейса, или ссылка на упакованное значение типа значения, которое реализует такой тип интерфейса</span><span class="sxs-lookup"><span data-stu-id="4bdbe-256">A `null` reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type</span></span>
- <span data-ttu-id="4bdbe-257">Тип массива</span><span class="sxs-lookup"><span data-stu-id="4bdbe-257">Array type</span></span>
  - <span data-ttu-id="4bdbe-258">Ссылка `null`, ссылка на экземпляр такого типа массива или ссылка на экземпляр любого совместимого типа массива</span><span class="sxs-lookup"><span data-stu-id="4bdbe-258">A `null` reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type</span></span>
- <span data-ttu-id="4bdbe-259">Тип делегата</span><span class="sxs-lookup"><span data-stu-id="4bdbe-259">Delegate type</span></span>
  - <span data-ttu-id="4bdbe-260">Ссылка `null` или ссылка на экземпляр совместимого типа делегата</span><span class="sxs-lookup"><span data-stu-id="4bdbe-260">A `null` reference or a reference to an instance of a compatible delegate type</span></span>

## <a name="program-structure"></a><span data-ttu-id="4bdbe-261">Структура программы</span><span class="sxs-lookup"><span data-stu-id="4bdbe-261">Program structure</span></span>

<span data-ttu-id="4bdbe-262">В C# основными понятиями организационной структуры являются [\***программы** _](../programming-guide/inside-a-program/index.md), [_\*_пространства имен_\*_](../programming-guide/namespaces/index.md), [_\*_типы_\*_](../programming-guide/types/index.md), [_\*_элементы_\*_](../programming-guide/classes-and-structs/members.md) и [_\*_сборки_\*_](../../standard/assembly/index.md).</span><span class="sxs-lookup"><span data-stu-id="4bdbe-262">The key organizational concepts in C# are [\***programs** _](../programming-guide/inside-a-program/index.md), [_*_namespaces_*_](../programming-guide/namespaces/index.md), [_*_types_*_](../programming-guide/types/index.md), [_*_members_*_](../programming-guide/classes-and-structs/members.md), and [_*_assemblies_*_](../../standard/assembly/index.md).</span></span> <span data-ttu-id="4bdbe-263">В программе объявляются типы, которые содержат члены. Эти типы можно организовать в пространства имен.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-263">Programs declare types, which contain members and can be organized into namespaces.</span></span> <span data-ttu-id="4bdbe-264">Примерами типов являются классы, структуры и интерфейсы.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-264">Classes, structs, and interfaces are examples of types.</span></span> <span data-ttu-id="4bdbe-265">К членам относятся поля, методы, свойства и события.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-265">Fields, methods, properties, and events are examples of members.</span></span> <span data-ttu-id="4bdbe-266">При компиляции программы на C# упаковываются в сборки.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-266">When C# programs are compiled, they're physically packaged into assemblies.</span></span> <span data-ttu-id="4bdbe-267">Сборка — это файл, обычно с расширением `.exe` или `.dll`, если она реализует _\*_приложение_\*_ или _\*_библиотеку_\*\*, соответственно.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-267">Assemblies typically have the file extension `.exe` or `.dll`, depending on whether they implement _*_applications_*_ or _\*_libraries_\*\*, respectively.</span></span>

<span data-ttu-id="4bdbe-268">В качестве небольшого примера рассмотрим сборку, содержащую следующий код:</span><span class="sxs-lookup"><span data-stu-id="4bdbe-268">As a small example, consider an assembly that contains the following code:</span></span>

:::code language="csharp" source="./snippets/shared/AcmeStack.cs":::

<span data-ttu-id="4bdbe-269">Полное имя этого класса: `Acme.Collections.Stack`.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-269">The fully qualified name of this class is `Acme.Collections.Stack`.</span></span> <span data-ttu-id="4bdbe-270">Этот класс содержит несколько членов: поле с именем `top`, два метода с именами `Push` и `Pop`, а также вложенный класс с именем `Entry`.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-270">The class contains several members: a field named `top`, two methods named `Push` and `Pop`, and a nested class named `Entry`.</span></span> <span data-ttu-id="4bdbe-271">Класс `Entry`, в свою очередь, содержит три члена: поле с именем `next`, поле с именем `data` и конструктор.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-271">The `Entry` class further contains three members: a field named `next`, a field named `data`, and a constructor.</span></span> <span data-ttu-id="4bdbe-272">`Stack` — это *универсальный* класс.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-272">The `Stack` is a *generic* class.</span></span> <span data-ttu-id="4bdbe-273">Он имеет параметр одного типа `T`, который замещается конкретным типом при использовании.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-273">It has one type parameter, `T` that is replaced with a concrete type when it's used.</span></span>

> [!NOTE]
> <span data-ttu-id="4bdbe-274">*Стек* — это коллекция типа FILO (прибыл первым — обслужен последним).</span><span class="sxs-lookup"><span data-stu-id="4bdbe-274">A *stack* is a "first in - last out" (FILO) collection.</span></span> <span data-ttu-id="4bdbe-275">Новые элементы добавляются в верх стека.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-275">New elements are added to the top of the stack.</span></span> <span data-ttu-id="4bdbe-276">При удалении элемента он удаляется из верха стека.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-276">When an element is removed, it is removed from the top of the stack.</span></span>

<span data-ttu-id="4bdbe-277">Сборки содержат исполняемый код в виде инструкций промежуточного языка (IL) и символьную информацию в виде метаданных.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-277">Assemblies contain executable code in the form of Intermediate Language (IL) instructions, and symbolic information in the form of metadata.</span></span> <span data-ttu-id="4bdbe-278">Перед выполнением JIT-компилятор среды CLR .NET преобразует код IL в сборке в код, зависящий от процессора.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-278">Before it's executed, the Just-In-Time (JIT) compiler of .NET Common Language Runtime converts the IL code in an assembly to processor-specific code.</span></span>

<span data-ttu-id="4bdbe-279">Сборка полностью описывает сама себя и содержит весь код и метаданные, поэтому в C# не используются директивы `#include` и файлы заголовков.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-279">Because an assembly is a self-describing unit of functionality containing both code and metadata, there's no need for `#include` directives and header files in C#.</span></span> <span data-ttu-id="4bdbe-280">Чтобы использовать в программе C# открытые типы и члены, содержащиеся в определенной сборке, вам достаточно указать ссылку на эту сборку при компиляции программы.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-280">The public types and members contained in a particular assembly are made available in a C# program simply by referencing that assembly when compiling the program.</span></span> <span data-ttu-id="4bdbe-281">Например, эта программа использует класс `Acme.Collections.Stack` из сборки `acme.dll`:</span><span class="sxs-lookup"><span data-stu-id="4bdbe-281">For example, this program uses the `Acme.Collections.Stack` class from the `acme.dll` assembly:</span></span>

:::code language="csharp" source="./snippets/shared/StackUsage.cs":::

<span data-ttu-id="4bdbe-282">Для компиляции программы вам потребуется создать *ссылку* на сборку, содержащую класс стека, определенный в примере выше.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-282">To compile this program, you would need to *reference* the assembly containing the stack class defined in the earlier example.</span></span>

<span data-ttu-id="4bdbe-283">Программы C# можно хранить в нескольких исходных файлах.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-283">C# programs can be stored in several source files.</span></span> <span data-ttu-id="4bdbe-284">При компиляции программы C# все исходные файлы обрабатываются вместе, при этом они могут свободно ссылаться друг на друга.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-284">When a C# program is compiled, all of the source files are processed together, and the source files can freely reference each other.</span></span> <span data-ttu-id="4bdbe-285">По сути, это аналогично тому, как если бы все исходные файлы были объединены в один большой файл перед обработкой.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-285">Conceptually, it's as if all the source files were concatenated into one large file before being processed.</span></span> <span data-ttu-id="4bdbe-286">В C# никогда не используются опережающие объявления, так как порядок объявления, за редким исключением, не играет никакой роли.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-286">Forward declarations are never needed in C# because, with few exceptions, declaration order is insignificant.</span></span> <span data-ttu-id="4bdbe-287">В C# нет требований объявлять только один открытый тип в одном исходном файле, а также имя исходного файла не обязано совпадать с типом, объявляемом в этом файле.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-287">C# doesn't limit a source file to declaring only one public type nor does it require the name of the source file to match a type declared in the source file.</span></span>

<span data-ttu-id="4bdbe-288">Такие организационные блоки описываются в других статьях этого обзора.</span><span class="sxs-lookup"><span data-stu-id="4bdbe-288">Further articles in this tour explain these organizational blocks.</span></span>

>[!div class="step-by-step"]
>[<span data-ttu-id="4bdbe-289">Вперед</span><span class="sxs-lookup"><span data-stu-id="4bdbe-289">Next</span></span>](types.md)
