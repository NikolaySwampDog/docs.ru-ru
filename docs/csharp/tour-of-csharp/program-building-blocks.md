---
title: Стандартные блоки программ на C#
description: Сведения о членах, выражениях и операторах в C#. Типы содержат создаваемые вами члены. Эти члены строятся из операторов и выражений.
ms.date: 08/06/2020
ms.openlocfilehash: 87410697bbed305c746f1440cca61dcbe53f88a7
ms.sourcegitcommit: 872ca41d1c26f39d0aef57cc365d09503bac780d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/03/2021
ms.locfileid: "106288060"
---
# <a name="program-building-blocks"></a><span data-ttu-id="42071-105">Стандартные блоки программы</span><span class="sxs-lookup"><span data-stu-id="42071-105">Program building blocks</span></span>

<span data-ttu-id="42071-106">Типы, описанные в предыдущей статье, создаются с использованием следующих стандартных блоков: [\***элементы** _](../programming-guide/classes-and-structs/members.md), [_\*_выражения_\*_ и _ *_инструкции_*\*](../programming-guide/statements-expressions-operators/index.md).</span><span class="sxs-lookup"><span data-stu-id="42071-106">The types described in the previous article are built using these building blocks: [\***members** _](../programming-guide/classes-and-structs/members.md), [_*_expressions_*_, and _ *_statements_*\*](../programming-guide/statements-expressions-operators/index.md).</span></span>

## <a name="members"></a><span data-ttu-id="42071-107">Элементы</span><span class="sxs-lookup"><span data-stu-id="42071-107">Members</span></span>

<span data-ttu-id="42071-108">Элементы `class` могут быть ***статическими элементами** _ или _*_элементами экземпляра_\*\*.</span><span class="sxs-lookup"><span data-stu-id="42071-108">The members of a `class` are either ***static members** _ or _*_instance members_\*\*.</span></span> <span data-ttu-id="42071-109">Статические члены принадлежат классу в целом, а члены экземпляра принадлежат конкретным объектам (экземплярам классов).</span><span class="sxs-lookup"><span data-stu-id="42071-109">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="42071-110">Ниже перечислены виды членов, которые могут содержаться в классе.</span><span class="sxs-lookup"><span data-stu-id="42071-110">The following list provides an overview of the kinds of members a class can contain.</span></span>

- <span data-ttu-id="42071-111">**Константы**. Константные значения, связанные с классом.</span><span class="sxs-lookup"><span data-stu-id="42071-111">**Constants**: Constant values associated with the class</span></span>
- <span data-ttu-id="42071-112">**Поля**. Переменные, связанные с классом.</span><span class="sxs-lookup"><span data-stu-id="42071-112">**Fields**:  Variables that are associated with the class</span></span>
- <span data-ttu-id="42071-113">**Методы**.  Действия, которые может выполнять класс.</span><span class="sxs-lookup"><span data-stu-id="42071-113">**Methods**:  Actions that can be performed by the class</span></span>
- <span data-ttu-id="42071-114">**Свойства**. Действия, связанные с чтением и записью именованных свойств класса.</span><span class="sxs-lookup"><span data-stu-id="42071-114">**Properties**: Actions associated with reading and writing named properties of the class</span></span>
- <span data-ttu-id="42071-115">**Индексаторы**. Действия, реализующие индексирование экземпляров класса, чтобы обращаться к ним как к массиву.</span><span class="sxs-lookup"><span data-stu-id="42071-115">**Indexers**: Actions associated with indexing instances of the class like an array</span></span>
- <span data-ttu-id="42071-116">**События**. Уведомления, которые могут быть созданы этим классом.</span><span class="sxs-lookup"><span data-stu-id="42071-116">**Events**: Notifications that can be generated by the class</span></span>
- <span data-ttu-id="42071-117">**Операторы**. Поддерживаемые классом операторы преобразования и выражения.</span><span class="sxs-lookup"><span data-stu-id="42071-117">**Operators**: Conversions and expression operators supported by the class</span></span>
- <span data-ttu-id="42071-118">**Конструкторы**. Действия, необходимые для инициализации экземпляров класса или класса в целом.</span><span class="sxs-lookup"><span data-stu-id="42071-118">**Constructors**: Actions required to initialize instances of the class or the class itself</span></span>
- <span data-ttu-id="42071-119">**Методы завершения**. Действия, выполняемые перед окончательным удалением экземпляров класса.</span><span class="sxs-lookup"><span data-stu-id="42071-119">**Finalizers**: Actions performed before instances of the class are permanently discarded</span></span>
- <span data-ttu-id="42071-120">**Типы**. Вложенные типы, объявленные в классе.</span><span class="sxs-lookup"><span data-stu-id="42071-120">**Types**: Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="42071-121">Возможности доступа</span><span class="sxs-lookup"><span data-stu-id="42071-121">Accessibility</span></span>

<span data-ttu-id="42071-122">Каждый член класса имеет определенный уровень доступности. Он определяет, из какой области программы можно обращаться к этому члену.</span><span class="sxs-lookup"><span data-stu-id="42071-122">Each member of a class has an associated accessibility, which controls the regions of program text that can access the member.</span></span> <span data-ttu-id="42071-123">Существует шесть уровней доступности.</span><span class="sxs-lookup"><span data-stu-id="42071-123">There are six possible forms of accessibility.</span></span> <span data-ttu-id="42071-124">Ниже приведены модификаторы доступа.</span><span class="sxs-lookup"><span data-stu-id="42071-124">The access modifiers are summarized below.</span></span>

- <span data-ttu-id="42071-125">`public`. Доступ не ограничен.</span><span class="sxs-lookup"><span data-stu-id="42071-125">`public`: Access isn't limited.</span></span>
- <span data-ttu-id="42071-126">`private`. Доступ возможен только из этого класса.</span><span class="sxs-lookup"><span data-stu-id="42071-126">`private`: Access is limited to this class.</span></span>
- <span data-ttu-id="42071-127">`protected`. Доступ возможен из этого класса и из классов, производных от него.</span><span class="sxs-lookup"><span data-stu-id="42071-127">`protected`: Access is limited to this class or classes derived from this class.</span></span>
- <span data-ttu-id="42071-128">`internal`. Доступ ограничен текущей сборкой (`.exe` или `.dll`).</span><span class="sxs-lookup"><span data-stu-id="42071-128">`internal`: Access is limited to the current assembly (`.exe` or `.dll`).</span></span>
- <span data-ttu-id="42071-129">`protected internal`. Доступ ограничен данным классом, классами, производными от данного класса, либо классами в той же сборке.</span><span class="sxs-lookup"><span data-stu-id="42071-129">`protected internal`: Access is limited to this class, classes derived from this class, or classes within the same assembly.</span></span>
- <span data-ttu-id="42071-130">`private protected`. Доступ ограничен данным классом либо классами, производными от данного типа в той же сборке.</span><span class="sxs-lookup"><span data-stu-id="42071-130">`private protected`: Access is limited to this class or classes derived from this type within the same assembly.</span></span>

## <a name="fields"></a><span data-ttu-id="42071-131">Поля</span><span class="sxs-lookup"><span data-stu-id="42071-131">Fields</span></span>

<span data-ttu-id="42071-132">*Поле* является переменной, связанной с определенным классом или экземпляром класса.</span><span class="sxs-lookup"><span data-stu-id="42071-132">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="42071-133">Поле, объявленное с модификатором static, является статическим.</span><span class="sxs-lookup"><span data-stu-id="42071-133">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="42071-134">Статическое поле определяет строго одно место хранения.</span><span class="sxs-lookup"><span data-stu-id="42071-134">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="42071-135">Независимо от того, сколько будет создано экземпляров этого класса, существует только одна копия статического поля.</span><span class="sxs-lookup"><span data-stu-id="42071-135">No matter how many instances of a class are created, there's only ever one copy of a static field.</span></span>

<span data-ttu-id="42071-136">Поле, объявленное без модификатора static, является полем экземпляра.</span><span class="sxs-lookup"><span data-stu-id="42071-136">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="42071-137">Каждый экземпляр класса содержит отдельные копии всех полей экземпляра, определенных для этого класса.</span><span class="sxs-lookup"><span data-stu-id="42071-137">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="42071-138">В следующем примере каждый экземпляр класса `Color` содержит отдельную копию полей экземпляра `R`, `G` и `B`, но для каждого из статических полей `Black`, `White`, `Red`, `Green` и `Blue` существует только одна копия:</span><span class="sxs-lookup"><span data-stu-id="42071-138">In the following example, each instance of the `Color` class has a separate copy of the `R`, `G`, and `B` instance fields, but there's only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ColorClassDefinition":::

<span data-ttu-id="42071-139">Как показано в предыдущем примере, можно объявить *поля только для чтения*, используя модификатор `readonly`.</span><span class="sxs-lookup"><span data-stu-id="42071-139">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="42071-140">Присвоение значения доступному только для чтения полю может происходить только при объявлении этого поля или в конструкторе этого класса.</span><span class="sxs-lookup"><span data-stu-id="42071-140">Assignment to a read-only field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="42071-141">Методы</span><span class="sxs-lookup"><span data-stu-id="42071-141">Methods</span></span>

<span data-ttu-id="42071-142">*Метод* — это член, реализующий вычисление или действие, которое может выполнять объект или класс.</span><span class="sxs-lookup"><span data-stu-id="42071-142">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="42071-143">Доступ к *статическим методам* осуществляется через класс.</span><span class="sxs-lookup"><span data-stu-id="42071-143">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="42071-144">Доступ к *методам экземпляра* осуществляется через экземпляр класса.</span><span class="sxs-lookup"><span data-stu-id="42071-144">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="42071-145">Для метода можно определить список *параметров*, которые представляют передаваемые методу значения или ссылки на переменные.</span><span class="sxs-lookup"><span data-stu-id="42071-145">Methods may have a list of *parameters*, which represent values or variable references passed to the method.</span></span> <span data-ttu-id="42071-146">Методы имеют *возвращаемый тип*, который задает тип значения, вычисляемого и возвращаемого методом.</span><span class="sxs-lookup"><span data-stu-id="42071-146">Methods have a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="42071-147">Если метод не возвращает значение, для него устанавливается тип возвращаемого значения `void`.</span><span class="sxs-lookup"><span data-stu-id="42071-147">A method’s return type is `void` if it doesn't return a value.</span></span>

<span data-ttu-id="42071-148">Как и типы, методы могут иметь набор параметров типа, для которых при вызове метода необходимо указывать аргументы типа.</span><span class="sxs-lookup"><span data-stu-id="42071-148">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="42071-149">В отличие от типов, аргументы типа зачастую могут выводиться из аргументов вызова метода, и тогда их не обязательно задавать явным образом.</span><span class="sxs-lookup"><span data-stu-id="42071-149">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="42071-150">*Сигнатура* метода должна быть уникальной в пределах класса, в котором объявлен этот метод.</span><span class="sxs-lookup"><span data-stu-id="42071-150">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="42071-151">Сигнатура метода включает имя метода, количество параметров типа, а также количество, модификаторы и типы параметров метода.</span><span class="sxs-lookup"><span data-stu-id="42071-151">The signature of a method consists of the name of the method, the number of type parameters, and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="42071-152">Сигнатура метода не включает тип возвращаемого значения.</span><span class="sxs-lookup"><span data-stu-id="42071-152">The signature of a method doesn't include the return type.</span></span>

<span data-ttu-id="42071-153">Если тело метода является одиночным выражением, метод можно определить с помощью компактного формата выражения, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="42071-153">When a method body is a single expression, the method can be defined using a compact expression format, as shown in the following example:</span></span>

```csharp
public override string ToString() => "This is an object";
```

### <a name="parameters"></a><span data-ttu-id="42071-154">Параметры</span><span class="sxs-lookup"><span data-stu-id="42071-154">Parameters</span></span>

<span data-ttu-id="42071-155">Параметры позволяют передать в метод значения или ссылки на переменные.</span><span class="sxs-lookup"><span data-stu-id="42071-155">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="42071-156">Фактические значения параметрам метода присваиваются на основе *аргументов*, заданных при вызове метода.</span><span class="sxs-lookup"><span data-stu-id="42071-156">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="42071-157">Существует четыре типа параметров: параметры значения, ссылочные параметры, параметры вывода и массивы параметров.</span><span class="sxs-lookup"><span data-stu-id="42071-157">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="42071-158">*Параметр значения* используется для передачи входных аргументов.</span><span class="sxs-lookup"><span data-stu-id="42071-158">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="42071-159">Параметр значения сопоставляется с локальной переменной, которая получит начальное значение из значения аргумента, переданного в этом параметре.</span><span class="sxs-lookup"><span data-stu-id="42071-159">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="42071-160">Изменения параметра значения не влияют на аргумент, переданный для этого параметра.</span><span class="sxs-lookup"><span data-stu-id="42071-160">Modifications to a value parameter don't affect the argument that was passed for the parameter.</span></span>

<span data-ttu-id="42071-161">Параметры значения можно сделать необязательными, указав для них значения по умолчанию. Тогда соответствующие аргументы можно не указывать.</span><span class="sxs-lookup"><span data-stu-id="42071-161">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="42071-162">*Ссылочный параметр* используется для передачи аргументов по ссылке.</span><span class="sxs-lookup"><span data-stu-id="42071-162">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="42071-163">Аргумент, передаваемый ссылочному параметру, должен являться переменной с определенным значением.</span><span class="sxs-lookup"><span data-stu-id="42071-163">The argument passed for a reference parameter must be a variable with a definite value.</span></span> <span data-ttu-id="42071-164">При выполнении метода ссылочный параметр указывает на то же место хранения, где размещена переменная аргумента.</span><span class="sxs-lookup"><span data-stu-id="42071-164">During execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="42071-165">Чтобы объявить ссылочный параметр, используйте модификатор `ref`.</span><span class="sxs-lookup"><span data-stu-id="42071-165">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="42071-166">Следующий пример кода демонстрирует использование параметров `ref`.</span><span class="sxs-lookup"><span data-stu-id="42071-166">The following example shows the use of `ref` parameters.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RefExample":::

<span data-ttu-id="42071-167">*Параметр вывода* используется для передачи аргументов по ссылке.</span><span class="sxs-lookup"><span data-stu-id="42071-167">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="42071-168">Он похож на ссылочный параметр, однако не требует явно присваивать значение аргумента, предоставляемого вызывающим объектом.</span><span class="sxs-lookup"><span data-stu-id="42071-168">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="42071-169">Чтобы объявить параметр вывода, используйте модификатор `out`.</span><span class="sxs-lookup"><span data-stu-id="42071-169">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="42071-170">В следующем примере показано использование параметров `out` с помощью синтаксиса, появившегося в C# 7.</span><span class="sxs-lookup"><span data-stu-id="42071-170">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="OutExample":::

<span data-ttu-id="42071-171">*Массив параметров* позволяет передавать в метод переменное число аргументов.</span><span class="sxs-lookup"><span data-stu-id="42071-171">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="42071-172">Чтобы объявить массив параметров, используйте модификатор `params`.</span><span class="sxs-lookup"><span data-stu-id="42071-172">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="42071-173">Массив параметров может быть только последним параметром в методе. Для него можно использовать только тип одномерного массива.</span><span class="sxs-lookup"><span data-stu-id="42071-173">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="42071-174">В качестве примера правильного использования массива параметров можно назвать методы `Write` и `WriteLine`, реализованные в классе <xref:System.Console?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="42071-174">The `Write` and `WriteLine` methods of the <xref:System.Console?displayProperty=nameWithType> class are good examples of parameter array usage.</span></span> <span data-ttu-id="42071-175">Ниже представлены объявления этих методов.</span><span class="sxs-lookup"><span data-stu-id="42071-175">They're declared as follows.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ConsoleExtract":::

<span data-ttu-id="42071-176">Внутри метода массив параметров полностью идентичен обычному параметру типа массив.</span><span class="sxs-lookup"><span data-stu-id="42071-176">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="42071-177">Но зато при вызове метода, использующего массив параметров, ему можно передать либо один аргумент типа массив, либо любое количество аргументов типа элемент для массива параметров.</span><span class="sxs-lookup"><span data-stu-id="42071-177">However, in an invocation of a method with a parameter array, it's possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="42071-178">В последнем случае экземпляр массива автоматически создается и инициализируется с заданными аргументами.</span><span class="sxs-lookup"><span data-stu-id="42071-178">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="42071-179">Код из этого примера...</span><span class="sxs-lookup"><span data-stu-id="42071-179">This example</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseParamsArgs":::

<span data-ttu-id="42071-180">...эквивалентен следующей конструкции:</span><span class="sxs-lookup"><span data-stu-id="42071-180">is equivalent to writing the following.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CompilerParams":::

### <a name="method-body-and-local-variables"></a><span data-ttu-id="42071-181">Тело метода и локальные переменные</span><span class="sxs-lookup"><span data-stu-id="42071-181">Method body and local variables</span></span>

<span data-ttu-id="42071-182">Тело метода содержит инструкции, которые будут выполнены при вызове метода.</span><span class="sxs-lookup"><span data-stu-id="42071-182">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="42071-183">В теле метода можно объявлять переменные, относящиеся к выполнению этого метода.</span><span class="sxs-lookup"><span data-stu-id="42071-183">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="42071-184">Такие переменные называются *локальными переменными*.</span><span class="sxs-lookup"><span data-stu-id="42071-184">Such variables are called *local variables*.</span></span> <span data-ttu-id="42071-185">В объявлении локальной переменной нужно указать имя типа и имя переменной. Также можно задать ее начальное значение.</span><span class="sxs-lookup"><span data-stu-id="42071-185">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="42071-186">Следующий пример кода объявляет локальную переменную `i` с нулевым начальным значением, и еще одну локальную переменную `j` без начального значения.</span><span class="sxs-lookup"><span data-stu-id="42071-186">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="SquaresClass":::

<span data-ttu-id="42071-187">C# требует, чтобы локальной переменной было *явно присвоено значение*, прежде чем можно будет получить это значение.</span><span class="sxs-lookup"><span data-stu-id="42071-187">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="42071-188">Например, если в предложенное выше объявление `i` не включить начальное значение, компилятор сообщит об ошибке при последующем использовании `i`, так как для `i` нет явно присвоенного значения.</span><span class="sxs-lookup"><span data-stu-id="42071-188">For example, if the declaration of the previous `i` didn't include an initial value, the compiler would report an error for the later usages of `i` because `i` wouldn't be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="42071-189">Метод может использовать инструкцию `return`, чтобы вернуть управление вызывающему объекту.</span><span class="sxs-lookup"><span data-stu-id="42071-189">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="42071-190">Если метод возвращает `void`, инструкции `return` не могут указывать выражение.</span><span class="sxs-lookup"><span data-stu-id="42071-190">In a method returning `void`, `return` statements can't specify an expression.</span></span> <span data-ttu-id="42071-191">В методе, выходное значение которого имеет любой другой тип, инструкции `return` должны содержать выражение, которое вычисляет возвращаемое значение.</span><span class="sxs-lookup"><span data-stu-id="42071-191">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="42071-192">Статические методы и методы экземпляра</span><span class="sxs-lookup"><span data-stu-id="42071-192">Static and instance methods</span></span>

<span data-ttu-id="42071-193">Метод, объявленный с модификатором `static`, является *статическим методом*.</span><span class="sxs-lookup"><span data-stu-id="42071-193">A method declared with a `static` modifier is a *static method*.</span></span> <span data-ttu-id="42071-194">Статический метод не работает с конкретным экземпляром и может напрямую обращаться только к статическим членам.</span><span class="sxs-lookup"><span data-stu-id="42071-194">A static method doesn't operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="42071-195">Метод, объявленный с модификатором `static`, является *методом экземпляра*.</span><span class="sxs-lookup"><span data-stu-id="42071-195">A method declared without a `static` modifier is an *instance method*.</span></span> <span data-ttu-id="42071-196">Метод экземпляра работает в определенном экземпляре и может обращаться как к статическим методам, так и к методам этого экземпляра.</span><span class="sxs-lookup"><span data-stu-id="42071-196">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="42071-197">В методе можно напрямую обратиться к экземпляру, для которого этот метод был вызван, используя дескриптор `this`.</span><span class="sxs-lookup"><span data-stu-id="42071-197">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="42071-198">Использование ссылки на `this` в статическом методе является недопустимым.</span><span class="sxs-lookup"><span data-stu-id="42071-198">It's an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="42071-199">Следующий класс `Entity` содержит статические члены и члены экземпляра.</span><span class="sxs-lookup"><span data-stu-id="42071-199">The following `Entity` class has both static and instance members.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="EntityClass":::

<span data-ttu-id="42071-200">Каждый экземпляр `Entity` содержит серийный номер (и может содержать другие данные, которые здесь не показаны).</span><span class="sxs-lookup"><span data-stu-id="42071-200">Each `Entity` instance contains a serial number (and presumably some other information that isn't shown here).</span></span> <span data-ttu-id="42071-201">Конструктор объекта `Entity` (который рассматривается как метод экземпляра) задает для нового экземпляра следующий доступный серийный номер.</span><span class="sxs-lookup"><span data-stu-id="42071-201">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="42071-202">Поскольку конструктор является членом экземпляра, он может обращаться как к полю экземпляра `_serialNo`, так и к статическому полю `s_nextSerialNo`.</span><span class="sxs-lookup"><span data-stu-id="42071-202">Because the constructor is an instance member, it's permitted to access both the `_serialNo` instance field and the `s_nextSerialNo` static field.</span></span>

<span data-ttu-id="42071-203">Статические методы `GetNextSerialNo` и `SetNextSerialNo` могут обращаться к статическому полю `s_nextSerialNo`, но прямое обращение из них к полю экземпляра `_serialNo` приводит к ошибке.</span><span class="sxs-lookup"><span data-stu-id="42071-203">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `s_nextSerialNo` static field, but it would be an error for them to directly access the `_serialNo` instance field.</span></span>

<span data-ttu-id="42071-204">В приведенном ниже примере показано использование класса `Entity`.</span><span class="sxs-lookup"><span data-stu-id="42071-204">The following example shows the use of the `Entity` class.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingEntity":::

<span data-ttu-id="42071-205">Статические методы `SetNextSerialNo` и `GetNextSerialNo` вызываются для класса, а метод экземпляра `GetSerialNo` вызывается для экземпляров класса.</span><span class="sxs-lookup"><span data-stu-id="42071-205">The `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="42071-206">Виртуальные, переопределяющие и абстрактные методы</span><span class="sxs-lookup"><span data-stu-id="42071-206">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="42071-207">Если объявление метода экземпляра включает модификатор `virtual`, такой метод называется *виртуальным методом*.</span><span class="sxs-lookup"><span data-stu-id="42071-207">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="42071-208">Если модификатор virtual отсутствует, метод считается *невиртуальным*.</span><span class="sxs-lookup"><span data-stu-id="42071-208">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="42071-209">При вызове виртуального метода могут быть вызваны разные его реализации в зависимости от того, какой *тип среды выполнения* имеет экземпляр, для которого вызван этот метод.</span><span class="sxs-lookup"><span data-stu-id="42071-209">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="42071-210">При вызове невиртуального метода решающим фактором является *тип во время компиляции* для этого экземпляра.</span><span class="sxs-lookup"><span data-stu-id="42071-210">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="42071-211">Виртуальный метод можно *переопределить* в производном классе.</span><span class="sxs-lookup"><span data-stu-id="42071-211">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="42071-212">Если объявление метода экземпляра содержит модификатор override, этот метод переопределяет унаследованный виртуальный метод с такой же сигнатурой.</span><span class="sxs-lookup"><span data-stu-id="42071-212">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="42071-213">Объявление виртуального метода создает новый метод.</span><span class="sxs-lookup"><span data-stu-id="42071-213">A virtual method declaration introduces a new method.</span></span> <span data-ttu-id="42071-214">Переопределение этого метода создает специализированный виртуальный метод с новой реализацией.</span><span class="sxs-lookup"><span data-stu-id="42071-214">An override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="42071-215">*Абстрактным методом* называется виртуальный метод без реализации.</span><span class="sxs-lookup"><span data-stu-id="42071-215">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="42071-216">Абстрактный метод объявляется с модификатором `abstract`. Его можно объявить только в абстрактном классе.</span><span class="sxs-lookup"><span data-stu-id="42071-216">An abstract method is declared with the `abstract` modifier and is permitted only in an abstract class.</span></span> <span data-ttu-id="42071-217">Абстрактный метод должен обязательно переопределяться в каждом производном классе, не являющемся абстрактным.</span><span class="sxs-lookup"><span data-stu-id="42071-217">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="42071-218">Следующий пример кода объявляет абстрактный класс `Expression`, который представляет узел дерева выражений, а также три производных класса: `Constant`, `VariableReference` и `Operation`, которые реализуют узлы дерева выражений для констант, ссылок на переменные и арифметических операций.</span><span class="sxs-lookup"><span data-stu-id="42071-218">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="42071-219">(Этот пример похож на типы дерева выражений, но не связан с ними.)</span><span class="sxs-lookup"><span data-stu-id="42071-219">(This example is similar to, but not related to the expression tree types).</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="WorkingWithExpressions":::

<span data-ttu-id="42071-220">Четыре приведенных выше класса можно использовать для моделирования арифметических выражений.</span><span class="sxs-lookup"><span data-stu-id="42071-220">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="42071-221">Например, с помощью экземпляров этих классов выражение `x + 3` можно представить следующим образом.</span><span class="sxs-lookup"><span data-stu-id="42071-221">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseExpressions":::

<span data-ttu-id="42071-222">Метод `Evaluate` экземпляра `Expression` вызывается для вычисления данного выражения и создает значение `double`.</span><span class="sxs-lookup"><span data-stu-id="42071-222">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="42071-223">Этот метод принимает аргумент `Dictionary`, который содержит имена переменных (в качестве ключей записей) и значения переменных (в качестве значений записей).</span><span class="sxs-lookup"><span data-stu-id="42071-223">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="42071-224">Так как `Evaluate` — абстрактный метод, то в неабстрактных классах, производных от `Expression`, необходимо переопределить `Evaluate`.</span><span class="sxs-lookup"><span data-stu-id="42071-224">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="42071-225">В `Constant` реализация метода `Evaluate` просто возвращает хранимую константу.</span><span class="sxs-lookup"><span data-stu-id="42071-225">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="42071-226">В `VariableReference` реализация этого метода выполняет поиск имени переменной в словаре и возвращает полученное значение.</span><span class="sxs-lookup"><span data-stu-id="42071-226">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="42071-227">В `Operation` реализация этого метода сначала вычисляет левый и правый операнды (рекурсивно вызывая их методы `Evaluate`), а затем выполняет предоставленную арифметическую операцию.</span><span class="sxs-lookup"><span data-stu-id="42071-227">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="42071-228">В следующей программе классы `Expression` используются для вычисления выражения `x * (y + 2)` с различными значениями `x` и `y`.</span><span class="sxs-lookup"><span data-stu-id="42071-228">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingExpressions":::

### <a name="method-overloading"></a><span data-ttu-id="42071-229">Перегрузка методов</span><span class="sxs-lookup"><span data-stu-id="42071-229">Method overloading</span></span>

<span data-ttu-id="42071-230">*Перегрузка* метода позволяет использовать в одном классе несколько методов с одинаковыми именами, если они имеют уникальные сигнатуры.</span><span class="sxs-lookup"><span data-stu-id="42071-230">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="42071-231">Когда при компиляции встречается вызов перегруженного метода, компилятор использует принцип *разрешения перегрузки*, чтобы определить, какой из методов следует вызвать.</span><span class="sxs-lookup"><span data-stu-id="42071-231">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="42071-232">Разрешение перегрузки выбирает из методов тот, который лучше всего соответствует предоставленным аргументам.</span><span class="sxs-lookup"><span data-stu-id="42071-232">Overload resolution finds the one method that best matches the arguments.</span></span> <span data-ttu-id="42071-233">Если не удается выбрать конкретный подходящий метод, возвращается ошибка.</span><span class="sxs-lookup"><span data-stu-id="42071-233">If no single best match can be found, an error is reported.</span></span> <span data-ttu-id="42071-234">В следующем примере показано, как работает разрешение перегрузки.</span><span class="sxs-lookup"><span data-stu-id="42071-234">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="42071-235">Комментарий к каждому вызову метода `UsageExample` указывает, какой именно метод вызывается.</span><span class="sxs-lookup"><span data-stu-id="42071-235">The comment for each invocation in the `UsageExample` method shows which method is invoked.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="Overloading":::

<span data-ttu-id="42071-236">Как видно из этого примера, вы всегда можете выбрать конкретный метод, явным образом приведя типы аргументов к соответствующим типам параметров и аргументам типов.</span><span class="sxs-lookup"><span data-stu-id="42071-236">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="42071-237">Другие функции-члены</span><span class="sxs-lookup"><span data-stu-id="42071-237">Other function members</span></span>

<span data-ttu-id="42071-238">Все члены класса, содержащие исполняемый код, совокупно называются *функции-члены*.</span><span class="sxs-lookup"><span data-stu-id="42071-238">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="42071-239">В предыдущем разделе описаны основные варианты методов, используемых в качестве функций-членов.</span><span class="sxs-lookup"><span data-stu-id="42071-239">The preceding section describes methods, which are the primary types of function members.</span></span> <span data-ttu-id="42071-240">В этом разделе описываются другие типы функций-членов, поддерживаемые в языке C#: конструкторы, свойства, индексаторы, события, операторы и методы завершения.</span><span class="sxs-lookup"><span data-stu-id="42071-240">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="42071-241">В следующем примере показан универсальный класс с именем `MyList<T>`, который реализует расширяемый список объектов.</span><span class="sxs-lookup"><span data-stu-id="42071-241">The following example shows a generic class called `MyList<T>`, which implements a growable list of objects.</span></span> <span data-ttu-id="42071-242">Этот класс содержит несколько наиболее распространенных типов функций-членов.</span><span class="sxs-lookup"><span data-stu-id="42071-242">The class contains several examples of the most common kinds of function members.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListExample":::

### <a name="constructors"></a><span data-ttu-id="42071-243">Конструкторы</span><span class="sxs-lookup"><span data-stu-id="42071-243">Constructors</span></span>

<span data-ttu-id="42071-244">C# поддерживает конструкторы экземпляров и статические конструкторы.</span><span class="sxs-lookup"><span data-stu-id="42071-244">C# supports both instance and static constructors.</span></span> <span data-ttu-id="42071-245">*Конструктор экземпляра* является членом, который реализует действия для инициализации нового экземпляра класса.</span><span class="sxs-lookup"><span data-stu-id="42071-245">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="42071-246">*Статический конструктор* является членом, который реализует действия для инициализации самого класса при первоначальной его загрузке.</span><span class="sxs-lookup"><span data-stu-id="42071-246">A *static constructor* is a member that implements the actions required to initialize a class itself when it's first loaded.</span></span>

<span data-ttu-id="42071-247">Конструктор объявляется в виде метода без возвращаемого типа, имя которого совпадает с именем класса, в котором он определен.</span><span class="sxs-lookup"><span data-stu-id="42071-247">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="42071-248">Если объявление конструктора содержит модификатор `static`, объявляется статический конструктор.</span><span class="sxs-lookup"><span data-stu-id="42071-248">If a constructor declaration includes a `static` modifier, it declares a static constructor.</span></span> <span data-ttu-id="42071-249">В противном случае это объявление считается конструктором экземпляра.</span><span class="sxs-lookup"><span data-stu-id="42071-249">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="42071-250">Конструкторы экземпляров можно перегружать, и для них можно указать необязательные параметры.</span><span class="sxs-lookup"><span data-stu-id="42071-250">Instance constructors can be overloaded and can have optional parameters.</span></span> <span data-ttu-id="42071-251">Например, класс `MyList<T>` объявляет один конструктор экземпляра с одним необязательным параметром `int`.</span><span class="sxs-lookup"><span data-stu-id="42071-251">For example, the `MyList<T>` class declares one instance constructor with a single optional `int` parameter.</span></span> <span data-ttu-id="42071-252">Конструкторы экземпляров вызываются с помощью оператора `new`.</span><span class="sxs-lookup"><span data-stu-id="42071-252">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="42071-253">Следующий пример кода выделяет два экземпляра `MyList<string>` с помощью конструкторов класса `MyList`: один с необязательным аргументом, а второй — без.</span><span class="sxs-lookup"><span data-stu-id="42071-253">The following statements allocate two `MyList<string>` instances using the constructor of the `MyList` class with and without the optional argument.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CreateLists":::

<span data-ttu-id="42071-254">В отличие от других членов, конструкторы экземпляров не наследуются.</span><span class="sxs-lookup"><span data-stu-id="42071-254">Unlike other members, instance constructors aren't inherited.</span></span> <span data-ttu-id="42071-255">Класс не имеет конструкторов экземпляров, кроме объявленных в самом этом классе.</span><span class="sxs-lookup"><span data-stu-id="42071-255">A class has no instance constructors other than those constructors actually declared in the class.</span></span> <span data-ttu-id="42071-256">Если в классе не объявлен конструктор экземпляра, для него автоматически создается пустой конструктор без параметров.</span><span class="sxs-lookup"><span data-stu-id="42071-256">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="42071-257">Свойства</span><span class="sxs-lookup"><span data-stu-id="42071-257">Properties</span></span>

<span data-ttu-id="42071-258">*Свойства* естественным образом дополняют поля.</span><span class="sxs-lookup"><span data-stu-id="42071-258">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="42071-259">И те, и другие являются именованными членами со связанными типами, и для доступа к ним используется одинаковый синтаксис.</span><span class="sxs-lookup"><span data-stu-id="42071-259">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="42071-260">Однако свойства, в отличие от полей, не указывают места хранения.</span><span class="sxs-lookup"><span data-stu-id="42071-260">However, unlike fields, properties don't denote storage locations.</span></span> <span data-ttu-id="42071-261">Вместо этого свойства содержат *методы доступа*, в которых описаны операторы, выполняемые при чтении или записи значений.</span><span class="sxs-lookup"><span data-stu-id="42071-261">Instead, properties have *accessors* that specify the statements executed when their values are read or written.</span></span>

<span data-ttu-id="42071-262">Свойство объявляется так же, как поле, за исключением того, что объявление заканчивается не точкой с запятой, а парой разделителей `{` и `}`, между которыми указан метод доступа get или set.</span><span class="sxs-lookup"><span data-stu-id="42071-262">A property is declared like a field, except that the declaration ends with a get accessor or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="42071-263">Свойство, которое имеет и метод доступа get, и метод доступа set, является *свойством для чтения и записи*.</span><span class="sxs-lookup"><span data-stu-id="42071-263">A property that has both a get accessor and a set accessor is a *read-write property*.</span></span> <span data-ttu-id="42071-264">Свойство, имеющее только метод доступа get, является *свойством только для чтения*.</span><span class="sxs-lookup"><span data-stu-id="42071-264">A property that has only a get accessor is a *read-only property*.</span></span> <span data-ttu-id="42071-265">Свойство, имеющее только метод доступа set, является *свойством только для записи*.</span><span class="sxs-lookup"><span data-stu-id="42071-265">A property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="42071-266">Акцессор get оформляется как метод без параметров, у которого тип возвращаемого значения совпадает с типом, установленным для этого свойства.</span><span class="sxs-lookup"><span data-stu-id="42071-266">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="42071-267">Метод доступа set соответствует методу с одним именованным значением параметра и без возвращаемого типа.</span><span class="sxs-lookup"><span data-stu-id="42071-267">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="42071-268">Метод доступа get вычисляет значение свойства.</span><span class="sxs-lookup"><span data-stu-id="42071-268">The get accessor computes the value of the property.</span></span> <span data-ttu-id="42071-269">Метод доступа set предоставляет новое значение для свойства.</span><span class="sxs-lookup"><span data-stu-id="42071-269">The set accessor provides a new value for the property.</span></span> <span data-ttu-id="42071-270">При ссылке на свойство в качестве назначения в операторе присваивания или в качестве операнда для `++` или `--` вызывается метод доступа set.</span><span class="sxs-lookup"><span data-stu-id="42071-270">When the property is the target of an assignment, or the operand of `++` or `--`, the set accessor is invoked.</span></span> <span data-ttu-id="42071-271">В остальных случаях при ссылке на свойство вызывается метод доступа get.</span><span class="sxs-lookup"><span data-stu-id="42071-271">In other cases where the property is referenced, the get accessor is invoked.</span></span>

<span data-ttu-id="42071-272">Класс `MyList<T>` объявляет два свойства: `Count` (только для чтения) и `Capacity` (только для записи).</span><span class="sxs-lookup"><span data-stu-id="42071-272">The `MyList<T>` class declares two properties, `Count` and `Capacity`, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="42071-273">Следующий код содержит пример использования этих свойств:</span><span class="sxs-lookup"><span data-stu-id="42071-273">The following code is an example of use of these properties:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="AccessProperties":::

<span data-ttu-id="42071-274">Как и в отношении полей и методов, C# поддерживает свойства экземпляра и статические свойства.</span><span class="sxs-lookup"><span data-stu-id="42071-274">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="42071-275">Статические свойства объявляются с модификатором static, а свойства экземпляра — без него.</span><span class="sxs-lookup"><span data-stu-id="42071-275">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="42071-276">Акцессоры свойства могут быть виртуальными.</span><span class="sxs-lookup"><span data-stu-id="42071-276">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="42071-277">Если объявление свойства содержит модификатор `virtual`, `abstract` или `override`, этот модификатор применяется к акцессорам свойства.</span><span class="sxs-lookup"><span data-stu-id="42071-277">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="42071-278">Индексаторы</span><span class="sxs-lookup"><span data-stu-id="42071-278">Indexers</span></span>

<span data-ttu-id="42071-279">*Индексатор* является членом, позволяющим индексировать объекты так, как будто они включены в массив.</span><span class="sxs-lookup"><span data-stu-id="42071-279">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="42071-280">Индексатор объявляется так же, как свойство, за исключением того, что именем элемента является `this`, а за этим именем следует список параметров, находящийся между разделителями `[` и `]`.</span><span class="sxs-lookup"><span data-stu-id="42071-280">An indexer is declared like a property except that the name of the member is `this` followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="42071-281">Эти параметры доступны в акцессорах индексатора.</span><span class="sxs-lookup"><span data-stu-id="42071-281">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="42071-282">Как и свойства, можно объявить индексаторы для чтения и записи, только для чтения или только для записи. Кроме того, поддерживаются виртуальные акцессоры индексатора.</span><span class="sxs-lookup"><span data-stu-id="42071-282">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="42071-283">Класс `MyList<T>` объявляет один индексатор для чтения и записи, который принимает параметр `int`.</span><span class="sxs-lookup"><span data-stu-id="42071-283">The `MyList<T>` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="42071-284">Индексатор позволяет индексировать экземпляры `MyList<T>` значениями с типом `int`.</span><span class="sxs-lookup"><span data-stu-id="42071-284">The indexer makes it possible to index `MyList<T>` instances with `int` values.</span></span> <span data-ttu-id="42071-285">Например:</span><span class="sxs-lookup"><span data-stu-id="42071-285">For example:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAccess":::

<span data-ttu-id="42071-286">Индексаторы могут быть перегружены.</span><span class="sxs-lookup"><span data-stu-id="42071-286">Indexers can be overloaded.</span></span> <span data-ttu-id="42071-287">В одном классе можно объявить несколько индексаторов, если у них различаются количество или типы параметров.</span><span class="sxs-lookup"><span data-stu-id="42071-287">A class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="42071-288">События</span><span class="sxs-lookup"><span data-stu-id="42071-288">Events</span></span>

<span data-ttu-id="42071-289">*Событие* — это член, с помощью которого класс или объект предоставляют уведомления.</span><span class="sxs-lookup"><span data-stu-id="42071-289">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="42071-290">Объявление события выглядит так же, как объявление поля, но содержит ключевое слово `event` и обязано иметь тип делегата.</span><span class="sxs-lookup"><span data-stu-id="42071-290">An event is declared like a field except that the declaration includes an `event` keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="42071-291">В классе, который объявляет член события, это событие действует как обычное поле с типом делегата (если это событие не является абстрактным и не объявляет методы доступа).</span><span class="sxs-lookup"><span data-stu-id="42071-291">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event isn't abstract and doesn't declare accessors).</span></span> <span data-ttu-id="42071-292">Это поле хранит ссылку на делегат, который представляет добавленные к событию обработчики событий.</span><span class="sxs-lookup"><span data-stu-id="42071-292">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="42071-293">Если обработчики событий отсутствуют, это поле имеет значение `null`.</span><span class="sxs-lookup"><span data-stu-id="42071-293">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="42071-294">Класс `MyList<T>` объявляет один член события с именем `Changed`, который обрабатывает добавление нового элемента.</span><span class="sxs-lookup"><span data-stu-id="42071-294">The `MyList<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="42071-295">Событие Changed вызывается виртуальным методом `OnChanged`, который сначала проверяет, не имеет ли это событие значение `null` (это означает, что обработчики отсутствуют).</span><span class="sxs-lookup"><span data-stu-id="42071-295">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="42071-296">Концепция создания события в точности соответствует вызову делегата, представленного этим событием.</span><span class="sxs-lookup"><span data-stu-id="42071-296">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event.</span></span> <span data-ttu-id="42071-297">Это позволяет обойтись без особой языковой конструкции для создания событий.</span><span class="sxs-lookup"><span data-stu-id="42071-297">There are no special language constructs for raising events.</span></span>

<span data-ttu-id="42071-298">Клиенты реагируют на события посредством *обработчиков событий*.</span><span class="sxs-lookup"><span data-stu-id="42071-298">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="42071-299">Обработчики событий можно подключать с помощью оператора `+=` и удалять с помощью оператора `-=`.</span><span class="sxs-lookup"><span data-stu-id="42071-299">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="42071-300">Следующий пример кода подключает обработчик события `Changed` к событию `MyList<string>`.</span><span class="sxs-lookup"><span data-stu-id="42071-300">The following example attaches an event handler to the `Changed` event of a `MyList<string>`.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RespondToEvents":::

<span data-ttu-id="42071-301">Для более сложных сценариев, требующих контроля над базовым хранилищем события, в объявлении события можно явным образом предоставить методы доступа `add` и `remove`. Они будут действовать аналогично методу доступа `set` для свойства.</span><span class="sxs-lookup"><span data-stu-id="42071-301">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="42071-302">Операторы</span><span class="sxs-lookup"><span data-stu-id="42071-302">Operators</span></span>

<span data-ttu-id="42071-303">*Оператор* является членом, который определяет правила применения определенного выражения к экземплярам класса.</span><span class="sxs-lookup"><span data-stu-id="42071-303">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="42071-304">Вы можете определить операторы трех типов: унарные операторы, двоичные операторы и операторы преобразования.</span><span class="sxs-lookup"><span data-stu-id="42071-304">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="42071-305">Все операторы объявляются с модификаторами `public` и `static`.</span><span class="sxs-lookup"><span data-stu-id="42071-305">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="42071-306">В классе `MyList<T>` объявляются два оператора: `operator ==` и `operator !=`.</span><span class="sxs-lookup"><span data-stu-id="42071-306">The `MyList<T>` class declares two operators, `operator ==` and `operator !=`.</span></span> <span data-ttu-id="42071-307">Эти переопределенные операторы придают новое значение выражениям, которые применяют эти операторы к экземплярам `MyList`.</span><span class="sxs-lookup"><span data-stu-id="42071-307">These overridden operators give new meaning to expressions that apply those operators to `MyList` instances.</span></span> <span data-ttu-id="42071-308">В частности, они определяют, что равенство двух экземпляров `MyList<T>` проверяется путем сравнения всех содержащихся в них объектов с помощью определенных для них методов `Equals`.</span><span class="sxs-lookup"><span data-stu-id="42071-308">Specifically, the operators define equality of two `MyList<T>` instances as comparing each of the contained objects using their `Equals` methods.</span></span> <span data-ttu-id="42071-309">Следующий пример кода использует оператор `==` для сравнения двух экземпляров `MyList<int>`.</span><span class="sxs-lookup"><span data-stu-id="42071-309">The following example uses the `==` operator to compare two `MyList<int>` instances.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAddition":::

<span data-ttu-id="42071-310">Первый `Console.WriteLine` выводит `True`, поскольку два списка содержат одинаковое число объектов с одинаковыми значениями в том же порядке.</span><span class="sxs-lookup"><span data-stu-id="42071-310">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="42071-311">Если бы в `MyList<T>` не было определения `operator ==`, первый `Console.WriteLine` возвращал бы `False`, поскольку `a` и `b` указывают на различные экземпляры `MyList<int>`.</span><span class="sxs-lookup"><span data-stu-id="42071-311">Had `MyList<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `MyList<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="42071-312">Методы завершения</span><span class="sxs-lookup"><span data-stu-id="42071-312">Finalizers</span></span>

<span data-ttu-id="42071-313">*Метод завершения* является членом, который реализует действия для завершения существования экземпляра класса.</span><span class="sxs-lookup"><span data-stu-id="42071-313">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="42071-314">Как правило, метод завершения необходим для освобождения неуправляемых ресурсов.</span><span class="sxs-lookup"><span data-stu-id="42071-314">Typically, a finalizer is needed to release unmanaged resources.</span></span> <span data-ttu-id="42071-315">Методы завершения не могут иметь параметры, не могут содержать модификаторы доступа, и их невозможно вызвать явным образом.</span><span class="sxs-lookup"><span data-stu-id="42071-315">Finalizers can't have parameters, they can't have accessibility modifiers, and they can't be invoked explicitly.</span></span> <span data-ttu-id="42071-316">Метод завершения для экземпляра вызывается автоматически в процессе сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="42071-316">The finalizer for an instance is invoked automatically during garbage collection.</span></span> <span data-ttu-id="42071-317">Дополнительные сведения см. в статье о [методах завершения](../programming-guide/classes-and-structs/destructors.md).</span><span class="sxs-lookup"><span data-stu-id="42071-317">For more details, see the article on [finalizers](../programming-guide/classes-and-structs/destructors.md).</span></span>

<span data-ttu-id="42071-318">Сборщик мусора имеет широкую степень свободы в выборе времени уничтожения объектов и вызова методов завершения.</span><span class="sxs-lookup"><span data-stu-id="42071-318">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="42071-319">В частности, время вызова методов завершения не является детерминированным, и эти методы могут выполняться в любом потоке.</span><span class="sxs-lookup"><span data-stu-id="42071-319">Specifically, the timing of finalizer invocations isn't deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="42071-320">По этим и некоторым другим причинам методы завершения следует использовать в классах только в крайнем случае, когда невозможны другие решения.</span><span class="sxs-lookup"><span data-stu-id="42071-320">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="42071-321">Уничтожение объектов лучше контролировать с помощью инструкции `using`.</span><span class="sxs-lookup"><span data-stu-id="42071-321">The `using` statement provides a better approach to object destruction.</span></span>

## <a name="expressions"></a><span data-ttu-id="42071-322">Выражения</span><span class="sxs-lookup"><span data-stu-id="42071-322">Expressions</span></span>

<span data-ttu-id="42071-323">*Выражения* создаются из *операндов* и *операторов*.</span><span class="sxs-lookup"><span data-stu-id="42071-323">*Expressions* are constructed from *operands* and *operators*.</span></span> <span data-ttu-id="42071-324">Операторы в выражении указывают, какие действия нужно применить к операндам.</span><span class="sxs-lookup"><span data-stu-id="42071-324">The operators of an expression indicate which operations to apply to the operands.</span></span> <span data-ttu-id="42071-325">Примеры операторов: `+`, `-`, `*`, `/` и `new`.</span><span class="sxs-lookup"><span data-stu-id="42071-325">Examples of operators include `+`, `-`, `*`, `/`, and `new`.</span></span> <span data-ttu-id="42071-326">Операндами могут являться литералы, поля, локальные переменные, выражения и т. п.</span><span class="sxs-lookup"><span data-stu-id="42071-326">Examples of operands include literals, fields, local variables, and expressions.</span></span>

<span data-ttu-id="42071-327">Если выражение содержит несколько операторов, их *приоритет* определяет порядок, в котором они оцениваются.</span><span class="sxs-lookup"><span data-stu-id="42071-327">When an expression contains multiple operators, the *precedence* of the operators controls the order in which the individual operators are evaluated.</span></span> <span data-ttu-id="42071-328">Например, выражение `x + y * z` вычисляется как `x + (y * z)`, поскольку оператор `*` имеет более высокий приоритет, чем оператор `+`.</span><span class="sxs-lookup"><span data-stu-id="42071-328">For example, the expression `x + y * z` is evaluated as `x + (y * z)` because the `*` operator has higher precedence than the `+` operator.</span></span>

<span data-ttu-id="42071-329">Если операнд располагается между двумя операторами с одинаковым приоритетом, порядок их выполнения определяется *ассоциативностью* операторов.</span><span class="sxs-lookup"><span data-stu-id="42071-329">When an operand occurs between two operators with the same precedence, the *associativity* of the operators controls the order in which the operations are performed:</span></span>

* <span data-ttu-id="42071-330">Все бинарные операторы, за исключением операторов объединения со значением NULL и операторов присваивания, являются *левоассоциативными*, т. е. эти операции выполняются слева направо.</span><span class="sxs-lookup"><span data-stu-id="42071-330">Except for the assignment and null-coalescing operators, all binary operators are *left-associative*, meaning that operations are performed from left to right.</span></span> <span data-ttu-id="42071-331">Например, выражение `x + y + z` вычисляется как `(x + y) + z`.</span><span class="sxs-lookup"><span data-stu-id="42071-331">For example, `x + y + z` is evaluated as `(x + y) + z`.</span></span>
* <span data-ttu-id="42071-332">Операторы присваивания, операторы объединения со значением NULL `??` и `??=`, а также условный оператор `?:` являются *правоассоциативными*, т. е. эти операции выполняются справа налево.</span><span class="sxs-lookup"><span data-stu-id="42071-332">The assignment operators, the null-coalescing `??` and `??=` operators, and the conditional operator `?:` are *right-associative*, meaning that operations are performed from right to left.</span></span> <span data-ttu-id="42071-333">Например, выражение `x = y = z` вычисляется как `x = (y = z)`.</span><span class="sxs-lookup"><span data-stu-id="42071-333">For example, `x = y = z` is evaluated as `x = (y = z)`.</span></span>

<span data-ttu-id="42071-334">Приоритет и ассоциативность операторов можно изменять, используя скобки.</span><span class="sxs-lookup"><span data-stu-id="42071-334">Precedence and associativity can be controlled using parentheses.</span></span> <span data-ttu-id="42071-335">Например, в выражении `x + y * z` сначала `y` умножается на `z`, а результат прибавляется к `x`, а в выражении `(x + y) * z` сначала суммируются `x` и `y`, а результат умножается на `z`.</span><span class="sxs-lookup"><span data-stu-id="42071-335">For example, `x + y * z` first multiplies `y` by `z` and then adds the result to `x`, but `(x + y) * z` first adds `x` and `y` and then multiplies the result by `z`.</span></span>

<span data-ttu-id="42071-336">Большинство операторов могут быть [*перегружены*](../language-reference/operators/operator-overloading.md).</span><span class="sxs-lookup"><span data-stu-id="42071-336">Most operators can be [*overloaded*](../language-reference/operators/operator-overloading.md).</span></span> <span data-ttu-id="42071-337">Перегрузка операторов позволяет создать пользовательскую реализацию оператора для таких операций, в которых один или оба операнда имеют определяемый пользователем тип класса или структуры.</span><span class="sxs-lookup"><span data-stu-id="42071-337">Operator overloading permits user-defined operator implementations to be specified for operations where one or both of the operands are of a user-defined class or struct type.</span></span>

<span data-ttu-id="42071-338">C# предоставляет несколько операторов для выполнения [арифметических](../language-reference/operators/arithmetic-operators.md), [логических](../language-reference/operators/boolean-logical-operators.md) операций, [побитовых операций и сдвигов](../language-reference/operators/bitwise-and-shift-operators.md), сравнения на [равенство](../language-reference/operators/equality-operators.md) и [порядок](../language-reference/operators/comparison-operators.md).</span><span class="sxs-lookup"><span data-stu-id="42071-338">C# provides a number of operators to perform [arithmetic](../language-reference/operators/arithmetic-operators.md), [logical](../language-reference/operators/boolean-logical-operators.md), [bitwise and shift](../language-reference/operators/bitwise-and-shift-operators.md) operations and [equality](../language-reference/operators/equality-operators.md) and [order](../language-reference/operators/comparison-operators.md) comparisons.</span></span>

<span data-ttu-id="42071-339">Полный список операторов C#, упорядоченных по уровню приоритета, см. в статье [Операторы C#](../language-reference/operators/index.md).</span><span class="sxs-lookup"><span data-stu-id="42071-339">For the complete list of C# operators ordered by precedence level, see [C# operators](../language-reference/operators/index.md).</span></span>

## <a name="statements"></a><span data-ttu-id="42071-340">Операторы</span><span class="sxs-lookup"><span data-stu-id="42071-340">Statements</span></span>

<span data-ttu-id="42071-341">Действия программы выражаются с помощью *операторов*.</span><span class="sxs-lookup"><span data-stu-id="42071-341">The actions of a program are expressed using *statements*.</span></span> <span data-ttu-id="42071-342">C# поддерживает несколько типов операторов, некоторые из которых определяются как внедренные операторы.</span><span class="sxs-lookup"><span data-stu-id="42071-342">C# supports several different kinds of statements, a number of which are defined in terms of embedded statements.</span></span>

- <span data-ttu-id="42071-343">С помощью *блоков* можно использовать несколько операторов в таких контекстах, где ожидается только один оператор.</span><span class="sxs-lookup"><span data-stu-id="42071-343">A *block* permits multiple statements to be written in contexts where a single statement is allowed.</span></span> <span data-ttu-id="42071-344">Блок состоит из списка инструкций, заключенных между разделителями `{` и `}`.</span><span class="sxs-lookup"><span data-stu-id="42071-344">A block consists of a list of statements written between the delimiters `{` and `}`.</span></span>
- <span data-ttu-id="42071-345">*Операторы объявления* используются для объявления локальных переменных и констант.</span><span class="sxs-lookup"><span data-stu-id="42071-345">*Declaration statements* are used to declare local variables and constants.</span></span>
- <span data-ttu-id="42071-346">*Операторы выражений* позволяют вычислять выражения.</span><span class="sxs-lookup"><span data-stu-id="42071-346">*Expression statements* are used to evaluate expressions.</span></span> <span data-ttu-id="42071-347">В качестве оператора можно использовать такие выражения, как вызовы методов, выделение объектов с помощью оператора `new`, назначения с помощью `=` и составных операторов присваивания, операторы `++` и `--` для приращения и уменьшения, а также выражения `await`.</span><span class="sxs-lookup"><span data-stu-id="42071-347">Expressions that can be used as statements include method invocations, object allocations using the `new` operator, assignments using `=` and the compound assignment operators, increment and decrement operations using the `++` and `--` operators and `await` expressions.</span></span>
- <span data-ttu-id="42071-348">*Операторы выбора* используются для выбора одного оператора из нескольких возможных вариантов в зависимости от значения какого-либо выражения.</span><span class="sxs-lookup"><span data-stu-id="42071-348">*Selection statements* are used to select one of a number of possible statements for execution based on the value of some expression.</span></span> <span data-ttu-id="42071-349">Эта группа содержит операторы `if` и `switch`.</span><span class="sxs-lookup"><span data-stu-id="42071-349">This group contains the `if` and `switch` statements.</span></span>
- <span data-ttu-id="42071-350">*Операторы итерации* используются для многократного выполнения внедренного оператора.</span><span class="sxs-lookup"><span data-stu-id="42071-350">*Iteration statements* are used to execute repeatedly an embedded statement.</span></span> <span data-ttu-id="42071-351">Эта группа содержит операторы `while`, `do`, `for` и `foreach`.</span><span class="sxs-lookup"><span data-stu-id="42071-351">This group contains the `while`, `do`, `for`, and `foreach` statements.</span></span>
- <span data-ttu-id="42071-352">*Операторы перехода* используются для передачи управления.</span><span class="sxs-lookup"><span data-stu-id="42071-352">*Jump statements* are used to transfer control.</span></span> <span data-ttu-id="42071-353">Эта группа содержит операторы `break`, `continue`, `goto`, `throw`, `return` и `yield`.</span><span class="sxs-lookup"><span data-stu-id="42071-353">This group contains the `break`, `continue`, `goto`, `throw`, `return`, and `yield` statements.</span></span>
- <span data-ttu-id="42071-354">Операторы `try`...`catch` позволяют перехватывать исключения, создаваемые при выполнении блока кода, а оператор `try`...`finally` используется для указания кода завершения, который выполняется всегда, независимо от появления исключений.</span><span class="sxs-lookup"><span data-stu-id="42071-354">The `try`...`catch` statement is used to catch exceptions that occur during execution of a block, and the `try`...`finally` statement is used to specify finalization code that is always executed, whether an exception occurred or not.</span></span>
- <span data-ttu-id="42071-355">Операторы `checked` и `unchecked` операторы позволяют управлять контекстом проверки переполнения для целочисленных арифметических операций и преобразований.</span><span class="sxs-lookup"><span data-stu-id="42071-355">The `checked` and `unchecked` statements are used to control the overflow-checking context for integral-type arithmetic operations and conversions.</span></span>
- <span data-ttu-id="42071-356">Оператор `lock` позволяет создать взаимоисключающую блокировку заданного объекта перед выполнением определенных операторов, а затем снять блокировку.</span><span class="sxs-lookup"><span data-stu-id="42071-356">The `lock` statement is used to obtain the mutual-exclusion lock for a given object, execute a statement, and then release the lock.</span></span>
- <span data-ttu-id="42071-357">Оператор `using` используется для получения ресурса перед определенным оператором, и для удаления ресурса после его завершения.</span><span class="sxs-lookup"><span data-stu-id="42071-357">The `using` statement is used to obtain a resource, execute a statement, and then dispose of that resource.</span></span>

<span data-ttu-id="42071-358">Ниже перечислены виды операторов, которые можно использовать.</span><span class="sxs-lookup"><span data-stu-id="42071-358">The following lists the kinds of statements that can be used:</span></span>

* <span data-ttu-id="42071-359">Объявление локальной переменной.</span><span class="sxs-lookup"><span data-stu-id="42071-359">Local variable declaration.</span></span>
* <span data-ttu-id="42071-360">Объявление локальной константы.</span><span class="sxs-lookup"><span data-stu-id="42071-360">Local constant declaration.</span></span>
* <span data-ttu-id="42071-361">Оператор выражений.</span><span class="sxs-lookup"><span data-stu-id="42071-361">Expression statement.</span></span>
* <span data-ttu-id="42071-362">Оператор `if`.</span><span class="sxs-lookup"><span data-stu-id="42071-362">`if` statement.</span></span>
* <span data-ttu-id="42071-363">Оператор `switch`.</span><span class="sxs-lookup"><span data-stu-id="42071-363">`switch` statement.</span></span>
* <span data-ttu-id="42071-364">Оператор `while`.</span><span class="sxs-lookup"><span data-stu-id="42071-364">`while` statement.</span></span>
* <span data-ttu-id="42071-365">Оператор `do`.</span><span class="sxs-lookup"><span data-stu-id="42071-365">`do` statement.</span></span>
* <span data-ttu-id="42071-366">Оператор `for`.</span><span class="sxs-lookup"><span data-stu-id="42071-366">`for` statement.</span></span>
* <span data-ttu-id="42071-367">Оператор `foreach`.</span><span class="sxs-lookup"><span data-stu-id="42071-367">`foreach` statement.</span></span>
* <span data-ttu-id="42071-368">Оператор `break`.</span><span class="sxs-lookup"><span data-stu-id="42071-368">`break` statement.</span></span>
* <span data-ttu-id="42071-369">Оператор `continue`.</span><span class="sxs-lookup"><span data-stu-id="42071-369">`continue` statement.</span></span>
* <span data-ttu-id="42071-370">Оператор `goto`.</span><span class="sxs-lookup"><span data-stu-id="42071-370">`goto` statement.</span></span>
* <span data-ttu-id="42071-371">Оператор `return`.</span><span class="sxs-lookup"><span data-stu-id="42071-371">`return` statement.</span></span>
* <span data-ttu-id="42071-372">Оператор `yield`.</span><span class="sxs-lookup"><span data-stu-id="42071-372">`yield` statement.</span></span>
* <span data-ttu-id="42071-373">Операторы `throw` и `try`.</span><span class="sxs-lookup"><span data-stu-id="42071-373">`throw` statements and `try` statements.</span></span>
* <span data-ttu-id="42071-374">Операторы `checked` и `unchecked`.</span><span class="sxs-lookup"><span data-stu-id="42071-374">`checked` and `unchecked` statements.</span></span>
* <span data-ttu-id="42071-375">Оператор `lock`.</span><span class="sxs-lookup"><span data-stu-id="42071-375">`lock` statement.</span></span>
* <span data-ttu-id="42071-376">Оператор `using`.</span><span class="sxs-lookup"><span data-stu-id="42071-376">`using` statement.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="42071-377">[Назад](types.md)
>[Вперед](features.md)</span><span class="sxs-lookup"><span data-stu-id="42071-377">[Previous](types.md)
[Next](features.md)</span></span>
