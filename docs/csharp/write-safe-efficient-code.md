---
title: Написание безопасного и эффективного кода C#
description: Последние улучшения языка C# позволяют создавать проверяемый безопасный код с производительностью, не уступающей небезопасному коду.
ms.date: 03/17/2020
ms.technology: csharp-advanced-concepts
ms.custom: mvc
ms.openlocfilehash: b739a4ce1f723798cbe50ef9eae673494996751c
ms.sourcegitcommit: 42d436ebc2a7ee02fc1848c7742bc7d80e13fc2f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/04/2021
ms.locfileid: "102106622"
---
# <a name="write-safe-and-efficient-c-code"></a>Написание безопасного и эффективного кода C#

Новые возможности в C# позволяют создавать проверяемый безопасный код с более высокой производительностью. Если вы будете внимательно применять эти методы, у вас будет меньше сценариев, требующих небезопасного кода. Эти функции упрощают использование ссылок на типы значений в качестве аргументов метода и возвращаемых значений метода. При безопасном выполнении эти методики сводят к минимуму копирование типов значений. Используя типы значений, можно свести к минимуму число распределений и сборок мусора.

В большей части примера кода в этой статье демонстрируются функции, добавленные в C# 7.2. Чтобы их использовать, нужно настроить проект для работы с языком C# 7.2 или более поздней версии. Дополнительные сведения об установке версии языка см. в разделе [Настройка языковой версии](language-reference/configure-language-version.md).

Эта статья посвящена методам эффективного управления ресурсами. Преимущество использования типов значений заключается в том, что они часто позволяют избежать выделения памяти в кучах. Недостаток состоит в том, что они копируются по значению. Этот компромисс усложняет оптимизацию алгоритмов, работающих с большими объемами данных. Новые возможности языка в C# 7.2 предоставляют механизмы, обеспечивающие безопасный и эффективный код со ссылками на типы значений. При рациональном использовании этих функций можно свести к минимуму число операций выделения и копирования. В этой статье приводится описание этих новых функций.

Эта статья описывает следующие методы управления ресурсами:

- Объявите [`readonly struct`](language-reference/builtin-types/struct.md#readonly-struct), чтобы указать, что тип — **неизменяемый**. Это позволяет компилятору сохранять защищенные копии при использовании параметров [`in`](language-reference/keywords/in-parameter-modifier.md).
- Если тип не может быть неизменяемым, объявите члены `struct` [`readonly`](language-reference/builtin-types/struct.md#readonly-instance-members), чтобы указать, что член не изменяет состояние.
- Используйте [`ref readonly`](language-reference/keywords/ref.md#reference-return-values), если возвращаемое значение — `struct` больше, чем <xref:System.IntPtr.Size?displayProperty=nameWithType>, и время существования хранилища больше, чем метод, возвращающий значение.
- Если размер `readonly struct` больше, чем <xref:System.IntPtr.Size?displayProperty=nameWithType>, необходимо передать его как параметр `in` для повышения производительности.
- Никогда не передавайте `struct` как параметр `in`, если он не объявлен с модификатором `readonly` или метод вызывает только члены `readonly` структуры. Нарушение этого правила может негативно сказаться на производительности и привести к непонятному поведению.
- Используйте [`ref struct`](language-reference/builtin-types/struct.md#ref-struct) или `readonly ref struct`, например <xref:System.Span%601> или <xref:System.ReadOnlySpan%601>, для работы с памятью как последовательностью байтов.

Эти методы помогают найти баланс между двумя противоположными целями в отношении **ссылок** и **значений**. Переменные, которые являются [ссылочными типами](programming-guide/types/index.md#reference-types), содержат ссылку на расположение в памяти. Переменные, которые являются [типами значений](programming-guide/types/index.md#value-types), непосредственно содержат значение. Это ключевые различия, которые важны для управления ресурсами памяти. **Типы значений** обычно копируются при передаче в метод или возвращаются из метода. Это поведение включает в себя копирование значения `this` при вызове членов типа значения. Издержки копирования связаны с размером типа. **Ссылочные типы** размещаются в управляемой куче. Каждый новый объект требует новое распределение и впоследствии должен быть освобожден. Обе эти операции занимают время. Ссылка копируется, когда ссылочный тип передается в качестве аргумента в метод или возвращается из метода.

В этой статье используется следующий пример концепции трехмерной структуры для объяснения этих рекомендаций:

```csharp
public struct Point3D
{
    public double X;
    public double Y;
    public double Z;
}
```

Различные примеры использования других реализаций этой концепции.

## <a name="declare-readonly-structs-for-immutable-value-types"></a>Объявление структур только для чтения для неизменяемых типов значений

Объявление `struct` с помощью модификатора `readonly` сообщает компилятору, что ваша цель — создать неизменяемый тип. Компилятор указывает это решение со следующими правилами:

- Все члены поля должны быть `readonly`
- Все свойства должны быть только для чтения, включая автоматически реализуемые свойства.

Этих двух правил достаточно, чтобы убедиться, что ни один из элементов `readonly struct` не изменяет состояние этой структуры. Объект `struct` является неизменяемым. Структура `Point3D` может быть определена как неизменяемая, как показано в следующем примере:

```csharp
readonly public struct ReadonlyPoint3D
{
    public ReadonlyPoint3D(double x, double y, double z)
    {
        this.X = x;
        this.Y = y;
        this.Z = z;
    }

    public double X { get; }
    public double Y { get; }
    public double Z { get; }
}
```

Следуйте этим рекомендациям, когда планируете создать неизменяемый тип значения. Улучшения производительности являются дополнительным преимуществом. `readonly struct` четко выражает ваше намерение.

## <a name="declare-readonly-members-when-a-struct-cant-be-immutable"></a>Объявление членов, доступных только для чтения, если структура не может быть неизменяемой

В C# 8.0 и более поздних версиях, когда тип структуры является изменяемым, следует объявить члены, которые не приводят к тому, что изменение имеет статус `readonly`. Рассмотрим другое приложение, для которого требуется структура объемных точек, однако оно должно поддерживать изменяемость. Следующая версия структуры объемных точек добавляет модификатор `readonly` только к тем элементам, которые не изменяют структуру. Используйте этот пример, если проект должен поддерживать модификации структуры некоторыми членами, однако вам все равно нужны преимущества реализации через "только для чтения" для некоторых членов:

```csharp
public struct Point3D
{
    public Point3D(double x, double y, double z)
    {
        _x = x;
        _y = y;
        _z = z;
    }

    private double _x;
    public double X
    {
        readonly get => _x;
        set => _x = value;
    }

    private double _y;
    public double Y
    {
        readonly get => _y;
        set => _y = value;
    }

    private double _z;
    public double Z
    {
        readonly get => _z;
        set => _z = value;
    }

    public readonly double Distance => Math.Sqrt(X * X + Y * Y + Z * Z);

    public readonly override string ToString() => $"{X}, {Y}, {Z}";
}
```

В предыдущем примере показаны многие расположения, в которых можно применить модификатор `readonly`: методы, свойства и методы доступа к свойствам. При использовании автоматически реализуемых свойств компилятор добавляет модификатор `readonly` к методу доступа `get` для свойств, предназначенных для чтения и записи. Компилятор добавляет модификатор `readonly` к автоматически реализуемым объявлениям свойств для свойств только с методом доступа `get`.

Добавление модификатора `readonly` к членам, которые не изменяют состояние, предоставляет два связанных преимущества. Во первых, компилятор применяет свое намерение. Этот член не может изменять состояние структуры. Во-вторых, компилятор не создает защитные копии параметров `in` при доступе к члену `readonly`. Компилятор может безопасно выполнить эту оптимизацию, так как она гарантирует, что `struct` не изменяется членом `readonly`.

## <a name="use-ref-readonly-return-statements-for-large-structures-when-possible"></a>Используйте операторы `ref readonly return` для больших структур, когда это возможно

Вы можете возвращать значения по ссылке, когда возвращаемое значение не является локальным для возвращающего метода. Возврат по ссылке означает, что копируется только ссылка, не структура. В следующем примере свойство `Origin` не может использовать возврат `ref`, так как возвращаемое значение является локальной переменной:

```csharp
public Point3D Origin => new Point3D(0,0,0);
```

Тем не менее, следующее определение свойства может возвращаться по ссылке, так как возвращаемое значение является статическим элементом:

```csharp
public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);

    // Dangerous! returning a mutable reference to internal storage
    public ref Point3D Origin => ref origin;

    // other members removed for space
}
```

Вы не хотите, чтобы вызывающие объекты изменяли источник, поэтому следует возвращать значение через `ref readonly`:

```csharp
public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);

    public static ref readonly Point3D Origin => ref origin;

    // other members removed for space
}
```

Возвращение `ref readonly` позволяет сохранить копирование больших структур и неизменность внутренних элементов данных.

Во время вызова вызывающие объекты выбирают использовать свойство `Origin` как `ref readonly` или как значение:

[!code-csharp[AssignRefReadonly](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

При первом назначении в предыдущем примере кода создается и назначается копия константы `Origin`. При втором назначается ссылка. Обратите внимание, что модификатор `readonly` должен быть частью объявления переменной. Ссылку, на которую он ссылается, изменить невозможно. В противном случае возникнет ошибка времени компиляции.

В объявлении `originReference` требуется модификатор `readonly`.

Компилятор применяет правило, не позволяющее вызывающему объекту изменять ссылку. Попытки назначить значение напрямую вызывают ошибку времени компиляции. В других случаях компилятор выделяет защитную копию, если он не может безопасно использовать ссылку только для чтения. Правила статического анализа определяют, можно ли изменить структуру. Компилятор не создает защитную копию, если структура или ее член является `readonly struct`. Защитная копия не требуется для передачи структуры в качестве аргумента `in`.

## <a name="apply-the-in-modifier-to-readonly-struct-parameters-larger-than-systemintptrsize"></a>Применение модификатора `in` к параметрам `readonly struct`, больше чем `System.IntPtr.Size`

При передаче аргументов по ссылке можно использовать ключевое слово `in` как дополнение к существующим ключевым словам `ref` и `out`. Ключевое слово `in` указывает, что аргумент передается по ссылке, но вызванный метод не изменяет это значение.

Это дополнение позволяет полностью выразить намерение разработки.
Если в сигнатуре метода не указан ни один из следующих модификаторов, типы значений копируются при передаче в вызываемый метод. Каждый из этих модификаторов указывает, что переменная передается по ссылке, предотвращая копирование. Каждый модификатор выражает конкретное намерение.

- `out`. этот метод задает значение аргумента, используемого в качестве этого параметра.
- `ref`. этот метод может задавать значение аргумента, используемого в качестве этого параметра.
- `in`. этот метод не изменяет значение аргумента, используемого в качестве этого параметра.

При добавлении модификатора `in` для передачи аргумента по ссылке вы объявляете о своем намерении передавать аргументы по ссылке, чтобы избежать ненужных операций копирования. Вы не собираетесь изменять объект, используемый в качестве этого аргумента.

Такой подход часто повышает производительность для типов значений только для чтения, размер которых превышает <xref:System.IntPtr.Size?displayProperty=nameWithType>. Для простых типов (`sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal` и `bool` и `enum`) возможное повышение производительности минимально. На самом деле, производительность может снизиться при использовании передачи по ссылке для типов, меньше чем <xref:System.IntPtr.Size?displayProperty=nameWithType>.

Ниже приведен пример метода, который вычисляет расстояние между двумя точками в трехмерном пространстве.

[!code-csharp[InArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument "Specifying an in argument")]

Аргументами являются две структуры, каждая из которых содержит три типа double. double имеет размер 8 байт, поэтому каждый аргумент равен 24 байтам. Указывая модификатор `in`, вы, в зависимости от архитектуры компьютера, передаете этим аргументам 4- или 8-байтовую ссылку. Разница в размере невелика, но она может вырасти, когда приложение вызывает этот метод в непрерывном цикле с помощью множества различных значений.

Существуют и другие способы, которыми модификатор `in` дополняет `out` и `ref`. Невозможно создать перегрузки метода, которые отличаются только наличием `in`, `out` или `ref`. Эти новые правила расширяют то же поведение, которое всегда действовало для параметров `out` и `ref`. Как и модификаторы `out` и `ref`, типы значений не упаковываются, так как применяется модификатор `in`.

Модификатор `in` может применяться к любому члену, который принимает параметры: к методам, делегатам, лямбда-выражениям, локальным функциям, индексаторам, операторам.

Еще одно преимущество параметров `in` состоит в том, что вы можете использовать литеральные значения или константы для аргумента в параметре `in`. Кроме того, в отличие от параметра `ref` или `out`, не нужно применять модификатор `in` на сайте вызова. В следующем коде показаны два примера вызова метода `CalculateDistance`. В первом используются две локальные переменные, передаваемые по ссылке. Второй содержит временную переменную, созданную в рамках вызова метода.

[!code-csharp[UseInArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#UseInArgument "Specifying an In argument")]

Существует несколько способов, когда компилятор гарантирует, что аргумент `in` доступен только для чтения.  Во-первых, вызванный метод не может быть напрямую назначен параметру `in`. Его невозможно напрямую назначить полю параметра `in`, когда это значение имеет тип `struct`. Кроме того, параметр `in` невозможно передать какому-либо методу, использующему модификатор `ref` или `out`.
Эти правила применяются к любому полю параметра `in` при условии, что данное поле имеет тип `struct` и параметр имеет тип `struct`. На самом деле эти правила применяются к нескольким уровням доступа к членам при условии, что все уровни доступа к членам являются `structs`.
Компилятор принудительно указывает, что типы `struct`, передаваемые в качестве аргументов `in`, и их члены `struct` являются переменными, доступными только для чтения, когда используются в качестве аргументов для других методов.

Использование параметров `in` позволяет избежать потенциальных затрат на создание копий. Это не меняет семантику ни одного вызова метода. Таким образом, указывать модификатор `in` в месте вызова не нужно. Пропуск модификатора `in` в месте вызова сообщает компилятору, что он может сделать копию аргумента по следующим причинам:

- Выполняется неявное преобразование, но не преобразование удостоверения из типа аргумента в тип параметра.
- Аргумент является выражением, но не имеет известную переменную хранения.
- Существует перегрузка, которая отличается наличием или отсутствием `in`. В этом случае перегрузка по значению подходит лучше.

Эти правила полезны и при обновлении существующего кода для использования аргументов со ссылками, доступными только для чтения. Внутри вызываемого метода можно вызвать любой метод экземпляра, который использует параметры передачи по значению. В этих экземплярах создается копия параметра `in`. Поскольку компилятор может создавать временную переменную для любого параметра `in`, вы можете также указать значения по умолчанию для любого параметра `in`. Следующий код указывает начало координат (точку 0,0) в качестве значения по умолчанию для второй точки:

[!code-csharp[InArgumentDefault](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

Чтобы велеть компилятору передавать аргументы, доступные только для чтения, по ссылке, укажите модификатор `in` для аргументов в месте вызова, как показано в следующем коде:

[!code-csharp[UseInArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ExplicitInArgument "Specifying an In argument")]

Это упрощает постепенное внедрение параметров `in` в больших базах кода, где возможен выигрыш по производительности. Сначала нужно добавить модификатор `in` в сигнатуры методов. Затем можно добавить модификатор `in` в местах вызовов и создать типы `readonly struct`, чтобы разрешить компилятору не создавать защитные копии параметров `in` в дополнительных расположениях.

Обозначение параметра `in` также можно использовать со ссылочными типами или числовыми значениями. Однако преимущества в обоих случаях минимальны (если они вообще есть).

## <a name="avoid-mutable-structs-as-an-in-argument"></a>Не используйте изменяемые структуры как аргумент `in`

Методики, описанные выше, объясняют, как избежать копий путем возврата ссылок и передачи значения по ссылке. Эти методы лучше всего работают, когда типы аргументов объявляются как типы `readonly struct`. В противном случае компилятор должен создавать **защитные копии** во многих ситуациях, чтобы гарантировать, что все аргументы будут доступны только для чтения. Рассмотрим следующий пример, который вычисляет расстояние до точки в трехмерном пространстве от начала координат:

[!code-csharp[InArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument "Specifying an in argument")]

Структура `Point3D`*не* предоставляется только для чтения. В тексте этого метода есть шесть разных вызовов доступа к свойству. На первый взгляд может показаться, что эти доступы безопасны. В конце концов, метод доступа `get` не должен изменять состояние объекта. Но нет правила языка, которое это обеспечивает. Это просто общее соглашение. Любой тип может реализовывать метод доступа `get`, который изменил внутреннее состояние. Без языковой гарантии компилятору необходимо создавать временную копию аргумента перед вызовом любого члена, не помеченного модификатором `readonly`. Временное хранилище создается на стеке, значения аргумента копируются во временном хранилище, и значение копируется в стек для каждого доступа к членам как аргумент `this`. Во многих случаях эти копии достаточно снижают производительность, так что передача по значению работает быстрее, чем передача по ссылке только для чтения, если тип аргумента не `readonly struct` и метод вызывает члены, не помеченные как `readonly`. Если пометить все методы, которые не изменяют состояние структуры как `readonly`, компилятор сможет безопасно определить, что состояние структуры не изменено и защитная копия не требуется.

Вместо этого, если вычисление расстояния использует неизменяемую структуру, `ReadonlyPoint3D`, временные объекты не требуются:

[!code-csharp[readonlyInArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ReadOnlyInArgument "Specifying a readonly in argument")]

Компилятор создает более эффективный код, когда вызываются члены `readonly struct`: Ссылка `this`, а не копия приемника, всегда является параметром `in`, переданным по ссылке методу члена. Эта оптимизация позволяет избежать копирования при использовании `readonly struct` в качестве аргумента `in`.

Не следует передавать тип значения, допускающий значения NULL, в качестве аргумента `in`. Тип <xref:System.Nullable%601> не объявлен как структура только для чтения. Это означает, что компилятор должен создавать защитные копии для любого аргумента типа, допускающего значение NULL и передаваемого в метод с помощью модификатора `in` в объявлении параметра.

Вы видите пример программы, который демонстрирует разницу в производительности с помощью [BenchmarkDotNet](https://www.nuget.org/packages/BenchmarkDotNet/) в наших [репозиториях примеров](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark) на сайте GitHub. Он сравнивает передачу изменяемых структур по значению и по ссылке с передачей неизменяемых структур по значению и по ссылке. Быстрее всего использовать неизменяемую структуру и передачу по ссылке.

## <a name="use-ref-struct-types-to-work-with-blocks-or-memory-on-a-single-stack-frame"></a>Используйте типы `ref struct` для работы с блоками или памятью в одном кадре стека

Еще одной связанной функцией языка является возможность объявлять тип значения, который должен быть ограничен одним кадром стека. Это ограничение позволяет компилятору кое-что оптимизировать. Главным стимулом для создания этой функции была структура <xref:System.Span%601> и связанные структуры. Вы получите повышение производительности благодаря этим усовершенствованиям, если будете использовать новые и обновленные интерфейсы API .NET, которые используют тип <xref:System.Span%601>.

Похожие требования могут иметь место при работе с памятью, созданной с помощью [`stackalloc`](language-reference/operators/stackalloc.md), или при использовании памяти из API взаимодействия. Для этих задач можно определить собственные типы `ref struct`.

## <a name="readonly-ref-struct-type"></a>Тип `readonly ref struct`

Объявление структуры как `readonly ref` сочетает в себе преимущества и недостатки объявлений `ref struct` и `readonly struct`. Объем памяти, используемой диапазоном только для чтения, будет ограничен одним кадром стека, а объем памяти, используемой диапазоном только для чтения, невозможно изменить.

## <a name="conclusions"></a>Выводы

Использование типов значений сводит к минимуму число операций распределения:

- Хранилище для типов значений выделяется в стеке для локальных переменных и аргументов метода.
- Хранилище для типов значений, которые являются членами других объектов, выделяется как часть этого объекта, а не отдельное распределение.
- Хранилища возвращаемых значений типов значений выделяется в стеке.

Сравните это со ссылочными типами в таких же ситуациях:

- Хранилище для ссылочных типов выделяется в куче для локальных переменных и аргументов метода. Ссылка хранится в стеке.
- Хранилище для ссылочных типов, которые являются членами других объектов, выделяется в куче отдельно. Объект хранит ссылку.
- Хранилище возвращаемых значений ссылочного типа выделяется в куче. Ссылка на это хранилище хранится в стеке.

Чтобы свести распределения к минимуму, придется пойти на компромисс. Вы копируете больше памяти, если размер `struct` больше, чем размер ссылки. Ссылка обычно является 64- или 32-разрядной и зависит от ЦП целевого компьютера.

Эти компромиссы обычно имеют минимальное влияние на производительность. Однако для больших структур или больших коллекций влияние на производительность возрастает. Влияние может быть большим в плотных циклах и часто используемых путях для программ.

Эти усовершенствования языка C# предназначены для критических алгоритмов производительности, когда минимизация распределений памяти может иметь большое значение для достижения необходимой производительности. Может оказаться, что в создаваемом коде эти функции используются довольно редко. Тем не менее эти усовершенствования были реализованы в .NET. Поскольку с этими функциями работает все больше API-интерфейсов, повышение производительности приложений не останется незаметным.

## <a name="see-also"></a>См. также

- [Ключевое слово ref](language-reference/keywords/ref.md)
- [Возвращаемые значения ref и локальные переменные ref](programming-guide/classes-and-structs/ref-returns.md)
