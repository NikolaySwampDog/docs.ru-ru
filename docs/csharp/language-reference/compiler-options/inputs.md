---
description: Параметры компилятора C# для управления входными файлами для компиляции. Эти параметры определяют способ считывания компилятором метаданных из зависимых сборок и модулей.
title: Параметры компилятора C# — параметры входных файлов
ms.date: 03/12/2021
f1_keywords:
- cs.build.options
helpviewer_keywords:
- References compiler option [C#]
- AddModules compiler option [C#]
- EmbedInteropTypes compiler option [C#]
ms.openlocfilehash: 819e2322720782b94bd744e00c602221f023c0d8
ms.sourcegitcommit: 0bb8074d524e0dcf165430b744bb143461f17026
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/15/2021
ms.locfileid: "103482501"
---
# <a name="c-compiler-options-that-specify-inputs"></a><span data-ttu-id="66d7b-104">Параметры компилятора C#, которые определяют входные данные</span><span class="sxs-lookup"><span data-stu-id="66d7b-104">C# Compiler Options that specify inputs</span></span>

<span data-ttu-id="66d7b-105">Следующие параметры управляют входными данными компилятора.</span><span class="sxs-lookup"><span data-stu-id="66d7b-105">The following options control compiler inputs.</span></span> <span data-ttu-id="66d7b-106">Новый синтаксис MSBuild выделен **полужирным шрифтом**.</span><span class="sxs-lookup"><span data-stu-id="66d7b-106">The new MSBuild syntax is shown in **Bold**.</span></span> <span data-ttu-id="66d7b-107">Для старого синтаксиса *csc.exe* используется формат `code style`.</span><span class="sxs-lookup"><span data-stu-id="66d7b-107">The older *csc.exe* syntax is shown in `code style`.</span></span>

- <span data-ttu-id="66d7b-108">**References** / `-reference` или `-references`: создание ссылки на метаданные из указанного файла или файлов сборки.</span><span class="sxs-lookup"><span data-stu-id="66d7b-108">**References** / `-reference` or `-references`: Reference metadata from the specified assembly file or files.</span></span>
- <span data-ttu-id="66d7b-109">**AddModules** / `-addmodule`: добавление модуля (созданного с помощью `target:module` для этой сборки).</span><span class="sxs-lookup"><span data-stu-id="66d7b-109">**AddModules** / `-addmodule`: Add a module (created with `target:module` to this assembly.)</span></span>
- <span data-ttu-id="66d7b-110">**EmbedInteropTypes** / `-link`: встраивание метаданных из указанных файлов сборки взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="66d7b-110">**EmbedInteropTypes** / `-link`: Embed metadata from the specified interop assembly files.</span></span>

## <a name="references"></a><span data-ttu-id="66d7b-111">Ссылки</span><span class="sxs-lookup"><span data-stu-id="66d7b-111">References</span></span>

<span data-ttu-id="66d7b-112">Параметр **Reference** указывает компилятору импортировать сведения типа [public](../keywords/public.md) из указанного файла в текущий проект. Это позволяет ссылаться на метаданные из указанных файлов сборки.</span><span class="sxs-lookup"><span data-stu-id="66d7b-112">The **References** option causes the compiler to import [public](../keywords/public.md) type information in the specified file into the current project, enabling you to reference metadata from the specified assembly files.</span></span>

```xml
<Reference Include="filename" />
```

 <span data-ttu-id="66d7b-113">`filename` — это имя файла, который содержит манифест сборки.</span><span class="sxs-lookup"><span data-stu-id="66d7b-113">`filename` is the name of a file that contains an assembly manifest.</span></span> <span data-ttu-id="66d7b-114">Чтобы импортировать данные из нескольких файлов, включите отдельный элемент **Reference** для каждого файла.</span><span class="sxs-lookup"><span data-stu-id="66d7b-114">To import more than one file, include a separate **Reference** element for each file.</span></span> <span data-ttu-id="66d7b-115">Псевдоним можно определить как дочерний элемент элемента **Reference**:</span><span class="sxs-lookup"><span data-stu-id="66d7b-115">You can define an alias as a child element of the **Reference** element:</span></span>

```xml
<Reference Include="filename.dll">
  <Aliases>LS</Aliases>
</Reference>
```

<span data-ttu-id="66d7b-116">В предыдущем примере `LS` — это допустимый идентификатор C# для представления корневого пространства имен, которое будет содержать все пространства имен в сборке *filename.dll*.</span><span class="sxs-lookup"><span data-stu-id="66d7b-116">In the previous example, `LS` is the valid C# identifier that represents a root namespace that will contain all namespaces in the assembly *filename.dll*.</span></span> <span data-ttu-id="66d7b-117">Импортируемые файлы должны содержать манифест.</span><span class="sxs-lookup"><span data-stu-id="66d7b-117">The files you import must contain a manifest.</span></span> <span data-ttu-id="66d7b-118">Для указания каталога, в котором находятся одна или несколько ссылок на сборки, используйте [**AdditionalLibPaths**](advanced.md#additionallibpaths).</span><span class="sxs-lookup"><span data-stu-id="66d7b-118">Use [**AdditionalLibPaths**](advanced.md#additionallibpaths) to specify the directory in which one or more of your assembly references is located.</span></span> <span data-ttu-id="66d7b-119">В разделе с описанием [**AdditionalLibPaths**](advanced.md#additionallibpaths) также рассматриваются каталоги, в которых компилятор ищет сборки.</span><span class="sxs-lookup"><span data-stu-id="66d7b-119">The [**AdditionalLibPaths**](advanced.md#additionallibpaths) topic also discusses the directories in which the compiler searches for assemblies.</span></span> <span data-ttu-id="66d7b-120">Чтобы компилятор мог распознавать тип в сборке (не в модуле), ему следует указать принудительно разрешать типы. Это можно сделать, определив экземпляр типа.</span><span class="sxs-lookup"><span data-stu-id="66d7b-120">In order for the compiler to recognize a type in an assembly, and not in a module, it needs to be forced to resolve the type, which you can do by defining an instance of the type.</span></span> <span data-ttu-id="66d7b-121">Возможны и другие способы разрешения компилятором имен типов в сборке. Например, если тип наследуется от типа в сборке, его имя будет распознаваться компилятором.</span><span class="sxs-lookup"><span data-stu-id="66d7b-121">There are other ways to resolve type names in an assembly for the compiler: for example, if you inherit from a type in an assembly, the type name will then be recognized by the compiler.</span></span> <span data-ttu-id="66d7b-122">Иногда бывает необходимо сослаться на две различные версии одного компонента из одной сборки.</span><span class="sxs-lookup"><span data-stu-id="66d7b-122">Sometimes it is necessary to reference two different versions of the same component from within one assembly.</span></span> <span data-ttu-id="66d7b-123">Для этого используйте элемент **Aliases** в элементе **References** для каждого файла, чтобы различать два этих файла.</span><span class="sxs-lookup"><span data-stu-id="66d7b-123">To do this, use the **Aliases** element on the **References** element for each file to distinguish between the two files.</span></span> <span data-ttu-id="66d7b-124">Этот псевдоним используется в качестве квалификатора имени компонента и разрешается в компонент в одном из файлов.</span><span class="sxs-lookup"><span data-stu-id="66d7b-124">This alias will be used as a qualifier for the component name, and will resolve to the component in one of the files.</span></span>

> [!NOTE]
> <span data-ttu-id="66d7b-125">В Visual Studio используйте команду **Добавить ссылку**.</span><span class="sxs-lookup"><span data-stu-id="66d7b-125">In Visual Studio, use the **Add Reference** command.</span></span> <span data-ttu-id="66d7b-126">Для получения дополнительной информации см. [Практическое руководство. Добавление и удаление ссылок с помощью диспетчера ссылок](/visualstudio/ide/how-to-add-or-remove-references-by-using-the-reference-manager).</span><span class="sxs-lookup"><span data-stu-id="66d7b-126">For more information, see [How to: Add or Remove References By Using the Reference Manager](/visualstudio/ide/how-to-add-or-remove-references-by-using-the-reference-manager).</span></span>

## <a name="addmodules"></a><span data-ttu-id="66d7b-127">AddModules</span><span class="sxs-lookup"><span data-stu-id="66d7b-127">AddModules</span></span>

<span data-ttu-id="66d7b-128">Установка этого параметра приводит к добавлению модуля, созданного с помощью параметра `<TargetType>module</TargetType>` для текущей компиляции:</span><span class="sxs-lookup"><span data-stu-id="66d7b-128">This option adds a module that was created with the `<TargetType>module</TargetType>` switch to the current compilation:</span></span>

```xml
<AddModule Include=file1 />
<AddModule Include=file2 />
```

<span data-ttu-id="66d7b-129">Где `file`, `file2` — это выходные файлы, содержащие метаданные.</span><span class="sxs-lookup"><span data-stu-id="66d7b-129">Where `file`, `file2` are output files that contain metadata.</span></span> <span data-ttu-id="66d7b-130">В этот файл не может входить манифест сборки.</span><span class="sxs-lookup"><span data-stu-id="66d7b-130">The file can't contain an assembly manifest.</span></span> <span data-ttu-id="66d7b-131">Чтобы импортировать несколько файлов, разделите их имена запятыми или точками с запятой.</span><span class="sxs-lookup"><span data-stu-id="66d7b-131">To import more than one file, separate file names with either a comma or a semicolon.</span></span> <span data-ttu-id="66d7b-132">Все модули, добавленные с помощью **AddModules**, во время выполнения должны находиться в том же каталоге, что и выходной файл.</span><span class="sxs-lookup"><span data-stu-id="66d7b-132">All modules added with **AddModules** must be in the same directory as the output file at run time.</span></span> <span data-ttu-id="66d7b-133">То есть во время компиляции можно указать модуль в любом каталоге, но во время выполнения он должен находиться в каталоге приложения.</span><span class="sxs-lookup"><span data-stu-id="66d7b-133">That is, you can specify a module in any directory at compile time but the module must be in the application directory at run time.</span></span> <span data-ttu-id="66d7b-134">Если во время выполнения модуль отсутствует в каталоге приложения, возникнет исключение <xref:System.TypeLoadException>.</span><span class="sxs-lookup"><span data-stu-id="66d7b-134">If the module isn't in the application directory at run time, you'll get a <xref:System.TypeLoadException>.</span></span> <span data-ttu-id="66d7b-135">`file` не может содержать сборку.</span><span class="sxs-lookup"><span data-stu-id="66d7b-135">`file` can't contain an assembly.</span></span> <span data-ttu-id="66d7b-136">Например, если выходной файл был создан с помощью параметра [**TargetType**](output.md#targettype) **module**, для импорта его метаданных можно использовать **AddModules**.</span><span class="sxs-lookup"><span data-stu-id="66d7b-136">For example, if the output file was created with [**TargetType**](output.md#targettype) option of **module**, its metadata can be imported with **AddModules**.</span></span>

<span data-ttu-id="66d7b-137">Если выходной файл был создан с помощью параметра [**TargetType**](output.md#targettype), отличающегося от **module**, для импорта его метаданных нельзя использовать **AddModules**, но можно использовать параметр [**References**](#references).</span><span class="sxs-lookup"><span data-stu-id="66d7b-137">If the output file was created with a [**TargetType**](output.md#targettype) option other than **module**, its metadata cannot be imported with **AddModules** but can be imported with the [**References**](#references) option.</span></span>

## <a name="embedinteroptypes"></a><span data-ttu-id="66d7b-138">EmbedInteropTypes</span><span class="sxs-lookup"><span data-stu-id="66d7b-138">EmbedInteropTypes</span></span>

<span data-ttu-id="66d7b-139">Дает компилятору указание сделать всю информацию о типах COM из указанных сборок доступной компилируемому проекту.</span><span class="sxs-lookup"><span data-stu-id="66d7b-139">Causes the compiler to make COM type information in the specified assemblies available to the project that you are currently compiling.</span></span>

```xml
<References>
  <EmbedInteropTypes>file1;file2;file3</EmbedInteropTypes>
</References>
```

<span data-ttu-id="66d7b-140">Где `file1;file2;file3` — это список с именами файлов сборок, разделенными точкой с запятой.</span><span class="sxs-lookup"><span data-stu-id="66d7b-140">Where  `file1;file2;file3` is a semicolon-delimited list of assembly file names.</span></span> <span data-ttu-id="66d7b-141">Если имя файла содержит пробел, заключите его в кавычки.</span><span class="sxs-lookup"><span data-stu-id="66d7b-141">If the file name contains a space, enclose the name in quotation marks.</span></span> <span data-ttu-id="66d7b-142">Параметр **EmbedInteropTypes** позволяет развернуть приложение, содержащее сведения о внедренном типе.</span><span class="sxs-lookup"><span data-stu-id="66d7b-142">The **EmbedInteropTypes** option enables you to deploy an application that has embedded type information.</span></span> <span data-ttu-id="66d7b-143">После этого приложение может использовать типы из сборки среды выполнения, реализующей информацию о внедренных типах, без ссылки на эту сборку.</span><span class="sxs-lookup"><span data-stu-id="66d7b-143">The application can then use types in a runtime assembly that implement the embedded type information without requiring a reference to the runtime assembly.</span></span> <span data-ttu-id="66d7b-144">Если опубликовано несколько версий сборки среды выполнения, приложение, содержащее сведения о внедренных типах, может работать с различными версиями без перекомпиляции.</span><span class="sxs-lookup"><span data-stu-id="66d7b-144">If various versions of the runtime assembly are published, the application that contains the embedded type information can work with the various versions without having to be recompiled.</span></span> <span data-ttu-id="66d7b-145">Пример см. в разделе [Пошаговое руководство. внедрению типов из управляемых сборок](../../../standard/assembly/embed-types-visual-studio.md).</span><span class="sxs-lookup"><span data-stu-id="66d7b-145">For an example, see [Walkthrough: Embedding Types from Managed Assemblies](../../../standard/assembly/embed-types-visual-studio.md).</span></span>

<span data-ttu-id="66d7b-146">Параметр **EmbedInteropTypes** особенно полезен при работе с COM-взаимодействием.</span><span class="sxs-lookup"><span data-stu-id="66d7b-146">Using the **EmbedInteropTypes** option is especially useful when you're working with COM interop.</span></span> <span data-ttu-id="66d7b-147">COM-типы внедряются для того, чтобы приложению не требовалась основная сборка взаимодействия (PIA) на целевом компьютере.</span><span class="sxs-lookup"><span data-stu-id="66d7b-147">You can embed COM types so that your application no longer requires a primary interop assembly (PIA) on the target computer.</span></span> <span data-ttu-id="66d7b-148">Параметр **EmbedInteropTypes** указывает компилятору внедрить сведения о COM-типах из указанной сборки взаимодействия в результирующий скомпилированный код.</span><span class="sxs-lookup"><span data-stu-id="66d7b-148">The **EmbedInteropTypes** option instructs the compiler to embed the COM type information from the referenced interop assembly into the resulting compiled code.</span></span> <span data-ttu-id="66d7b-149">COM-тип определяется значением CLSID (GUID).</span><span class="sxs-lookup"><span data-stu-id="66d7b-149">The COM type is identified by the CLSID (GUID) value.</span></span> <span data-ttu-id="66d7b-150">Это позволяет запускать приложение на целевом компьютере, где установлены те же COM-типы с такими же значениями CLSID.</span><span class="sxs-lookup"><span data-stu-id="66d7b-150">As a result, your application can run on a target computer that has installed the same COM types with the same CLSID values.</span></span> <span data-ttu-id="66d7b-151">В качестве примера можно привести приложения, автоматизирующие Microsoft Office.</span><span class="sxs-lookup"><span data-stu-id="66d7b-151">Applications that automate Microsoft Office are a good example.</span></span> <span data-ttu-id="66d7b-152">Поскольку в приложениях типа Office значение CLSID обычно не зависит от версии, ваше приложение сможет использовать COM-типы по ссылке до тех пора, пока на целевом компьютере установлена платформа .NET Framework 4 или более поздней версии, а приложение работает с методами, свойствами или событиями, включенными в эти COM-типы.</span><span class="sxs-lookup"><span data-stu-id="66d7b-152">Because applications like Office usually keep the same CLSID value across different versions, your application can use the referenced COM types as long as .NET Framework 4 or later is installed on the target computer and your application uses methods, properties, or events that are included in the referenced COM types.</span></span> <span data-ttu-id="66d7b-153">Параметр **EmbedInteropTypes** внедряет только интерфейсы, структуры и делегаты.</span><span class="sxs-lookup"><span data-stu-id="66d7b-153">The **EmbedInteropTypes** option embeds only interfaces, structures, and delegates.</span></span> <span data-ttu-id="66d7b-154">Внедрение COM-классов не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="66d7b-154">Embedding COM classes isn't supported.</span></span>

> [!NOTE]
> <span data-ttu-id="66d7b-155">Если в коде создается экземпляр внедренного COM-типа, его следует создавать, используя соответствующий интерфейс.</span><span class="sxs-lookup"><span data-stu-id="66d7b-155">When you create an instance of an embedded COM type in your code, you must create the instance by using the appropriate interface.</span></span> <span data-ttu-id="66d7b-156">При попытке создать экземпляр внедренного COM-типа с помощью компонентного класса возникнет ошибка.</span><span class="sxs-lookup"><span data-stu-id="66d7b-156">Attempting to create an instance of an embedded COM type by using the CoClass causes an error.</span></span>

<span data-ttu-id="66d7b-157">Как и параметр [**References**](#references) компилятора, параметр **EmbedInteropTypes** компилятора использует файл ответов Csc.rsp, который ссылается на часто используемые сборки .NET.</span><span class="sxs-lookup"><span data-stu-id="66d7b-157">Like the [**References**](#references) compiler option, the **EmbedInteropTypes** compiler option uses the Csc.rsp response file, which references frequently used .NET assemblies.</span></span> <span data-ttu-id="66d7b-158">Если вы не хотите, чтобы компилятор использовал файл Csc.rsp, примените параметр [**NoConfig**](miscellaneous.md#noconfig) компилятора.</span><span class="sxs-lookup"><span data-stu-id="66d7b-158">Use the [**NoConfig**](miscellaneous.md#noconfig) compiler option if you don't want the compiler to use the Csc.rsp file.</span></span>

[!code-csharp[VbLinkCompilerCS#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/vblinkcompilercs/cs/program.cs#1)]

<span data-ttu-id="66d7b-159">Типы с универсальным параметром, тип которого внедрен из сборки взаимодействия, нельзя использовать, если он относится к внешней сборке.</span><span class="sxs-lookup"><span data-stu-id="66d7b-159">Types that have a generic parameter whose type is embedded from an interop assembly cannot be used if that type is from an external assembly.</span></span> <span data-ttu-id="66d7b-160">Это ограничение не относится к интерфейсам.</span><span class="sxs-lookup"><span data-stu-id="66d7b-160">This restriction doesn't apply to interfaces.</span></span> <span data-ttu-id="66d7b-161">Например, рассмотрим интерфейс <xref:Microsoft.Office.Interop.Excel.Range>, который определен в сборке <xref:Microsoft.Office.Interop.Excel>.</span><span class="sxs-lookup"><span data-stu-id="66d7b-161">For example, consider the <xref:Microsoft.Office.Interop.Excel.Range> interface that is defined in the <xref:Microsoft.Office.Interop.Excel> assembly.</span></span> <span data-ttu-id="66d7b-162">Если библиотека содержит внедренные типы взаимодействия из сборки <xref:Microsoft.Office.Interop.Excel> и предоставляет метод, возвращающий универсальный тип с параметром, типом которого является интерфейс <xref:Microsoft.Office.Interop.Excel.Range>, этот метод должен возвращать универсальный интерфейс, как показано в следующем примере кода.</span><span class="sxs-lookup"><span data-stu-id="66d7b-162">If a library embeds interop types from the <xref:Microsoft.Office.Interop.Excel> assembly and exposes a method that returns a generic type that has a parameter whose type is the <xref:Microsoft.Office.Interop.Excel.Range> interface, that method must return a generic interface, as shown in the following code example.</span></span>

[!code-csharp[VbLinkCompilerCS#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/vblinkcompilercs/cs/utility.cs)]

<span data-ttu-id="66d7b-163">В следующем примере клиентский код может вызывать метод, возвращающий универсальный интерфейс <xref:System.Collections.IList> без ошибок.</span><span class="sxs-lookup"><span data-stu-id="66d7b-163">In the following example, client code can call the method that returns the <xref:System.Collections.IList> generic interface without error.</span></span>

[!code-csharp[VbLinkCompilerCS#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/vblinkcompilercs/cs/program.cs#5)]
