---
description: Параметры компилятора C# для управления входными файлами для компиляции. Эти параметры определяют способ считывания компилятором метаданных из зависимых сборок и модулей.
title: Параметры компилятора C# — параметры входных файлов
ms.date: 03/12/2021
f1_keywords:
- cs.build.options
helpviewer_keywords:
- References compiler option [C#]
- AddModules compiler option [C#]
- EmbedInteropTypes compiler option [C#]
ms.openlocfilehash: 819e2322720782b94bd744e00c602221f023c0d8
ms.sourcegitcommit: 0bb8074d524e0dcf165430b744bb143461f17026
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/15/2021
ms.locfileid: "103482501"
---
# <a name="c-compiler-options-that-specify-inputs"></a>Параметры компилятора C#, которые определяют входные данные

Следующие параметры управляют входными данными компилятора. Новый синтаксис MSBuild выделен **полужирным шрифтом**. Для старого синтаксиса *csc.exe* используется формат `code style`.

- **References** / `-reference` или `-references`: создание ссылки на метаданные из указанного файла или файлов сборки.
- **AddModules** / `-addmodule`: добавление модуля (созданного с помощью `target:module` для этой сборки).
- **EmbedInteropTypes** / `-link`: встраивание метаданных из указанных файлов сборки взаимодействия.

## <a name="references"></a>Ссылки

Параметр **Reference** указывает компилятору импортировать сведения типа [public](../keywords/public.md) из указанного файла в текущий проект. Это позволяет ссылаться на метаданные из указанных файлов сборки.

```xml
<Reference Include="filename" />
```

 `filename` — это имя файла, который содержит манифест сборки. Чтобы импортировать данные из нескольких файлов, включите отдельный элемент **Reference** для каждого файла. Псевдоним можно определить как дочерний элемент элемента **Reference**:

```xml
<Reference Include="filename.dll">
  <Aliases>LS</Aliases>
</Reference>
```

В предыдущем примере `LS` — это допустимый идентификатор C# для представления корневого пространства имен, которое будет содержать все пространства имен в сборке *filename.dll*. Импортируемые файлы должны содержать манифест. Для указания каталога, в котором находятся одна или несколько ссылок на сборки, используйте [**AdditionalLibPaths**](advanced.md#additionallibpaths). В разделе с описанием [**AdditionalLibPaths**](advanced.md#additionallibpaths) также рассматриваются каталоги, в которых компилятор ищет сборки. Чтобы компилятор мог распознавать тип в сборке (не в модуле), ему следует указать принудительно разрешать типы. Это можно сделать, определив экземпляр типа. Возможны и другие способы разрешения компилятором имен типов в сборке. Например, если тип наследуется от типа в сборке, его имя будет распознаваться компилятором. Иногда бывает необходимо сослаться на две различные версии одного компонента из одной сборки. Для этого используйте элемент **Aliases** в элементе **References** для каждого файла, чтобы различать два этих файла. Этот псевдоним используется в качестве квалификатора имени компонента и разрешается в компонент в одном из файлов.

> [!NOTE]
> В Visual Studio используйте команду **Добавить ссылку**. Для получения дополнительной информации см. [Практическое руководство. Добавление и удаление ссылок с помощью диспетчера ссылок](/visualstudio/ide/how-to-add-or-remove-references-by-using-the-reference-manager).

## <a name="addmodules"></a>AddModules

Установка этого параметра приводит к добавлению модуля, созданного с помощью параметра `<TargetType>module</TargetType>` для текущей компиляции:

```xml
<AddModule Include=file1 />
<AddModule Include=file2 />
```

Где `file`, `file2` — это выходные файлы, содержащие метаданные. В этот файл не может входить манифест сборки. Чтобы импортировать несколько файлов, разделите их имена запятыми или точками с запятой. Все модули, добавленные с помощью **AddModules**, во время выполнения должны находиться в том же каталоге, что и выходной файл. То есть во время компиляции можно указать модуль в любом каталоге, но во время выполнения он должен находиться в каталоге приложения. Если во время выполнения модуль отсутствует в каталоге приложения, возникнет исключение <xref:System.TypeLoadException>. `file` не может содержать сборку. Например, если выходной файл был создан с помощью параметра [**TargetType**](output.md#targettype) **module**, для импорта его метаданных можно использовать **AddModules**.

Если выходной файл был создан с помощью параметра [**TargetType**](output.md#targettype), отличающегося от **module**, для импорта его метаданных нельзя использовать **AddModules**, но можно использовать параметр [**References**](#references).

## <a name="embedinteroptypes"></a>EmbedInteropTypes

Дает компилятору указание сделать всю информацию о типах COM из указанных сборок доступной компилируемому проекту.

```xml
<References>
  <EmbedInteropTypes>file1;file2;file3</EmbedInteropTypes>
</References>
```

Где `file1;file2;file3` — это список с именами файлов сборок, разделенными точкой с запятой. Если имя файла содержит пробел, заключите его в кавычки. Параметр **EmbedInteropTypes** позволяет развернуть приложение, содержащее сведения о внедренном типе. После этого приложение может использовать типы из сборки среды выполнения, реализующей информацию о внедренных типах, без ссылки на эту сборку. Если опубликовано несколько версий сборки среды выполнения, приложение, содержащее сведения о внедренных типах, может работать с различными версиями без перекомпиляции. Пример см. в разделе [Пошаговое руководство. внедрению типов из управляемых сборок](../../../standard/assembly/embed-types-visual-studio.md).

Параметр **EmbedInteropTypes** особенно полезен при работе с COM-взаимодействием. COM-типы внедряются для того, чтобы приложению не требовалась основная сборка взаимодействия (PIA) на целевом компьютере. Параметр **EmbedInteropTypes** указывает компилятору внедрить сведения о COM-типах из указанной сборки взаимодействия в результирующий скомпилированный код. COM-тип определяется значением CLSID (GUID). Это позволяет запускать приложение на целевом компьютере, где установлены те же COM-типы с такими же значениями CLSID. В качестве примера можно привести приложения, автоматизирующие Microsoft Office. Поскольку в приложениях типа Office значение CLSID обычно не зависит от версии, ваше приложение сможет использовать COM-типы по ссылке до тех пора, пока на целевом компьютере установлена платформа .NET Framework 4 или более поздней версии, а приложение работает с методами, свойствами или событиями, включенными в эти COM-типы. Параметр **EmbedInteropTypes** внедряет только интерфейсы, структуры и делегаты. Внедрение COM-классов не поддерживается.

> [!NOTE]
> Если в коде создается экземпляр внедренного COM-типа, его следует создавать, используя соответствующий интерфейс. При попытке создать экземпляр внедренного COM-типа с помощью компонентного класса возникнет ошибка.

Как и параметр [**References**](#references) компилятора, параметр **EmbedInteropTypes** компилятора использует файл ответов Csc.rsp, который ссылается на часто используемые сборки .NET. Если вы не хотите, чтобы компилятор использовал файл Csc.rsp, примените параметр [**NoConfig**](miscellaneous.md#noconfig) компилятора.

[!code-csharp[VbLinkCompilerCS#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/vblinkcompilercs/cs/program.cs#1)]

Типы с универсальным параметром, тип которого внедрен из сборки взаимодействия, нельзя использовать, если он относится к внешней сборке. Это ограничение не относится к интерфейсам. Например, рассмотрим интерфейс <xref:Microsoft.Office.Interop.Excel.Range>, который определен в сборке <xref:Microsoft.Office.Interop.Excel>. Если библиотека содержит внедренные типы взаимодействия из сборки <xref:Microsoft.Office.Interop.Excel> и предоставляет метод, возвращающий универсальный тип с параметром, типом которого является интерфейс <xref:Microsoft.Office.Interop.Excel.Range>, этот метод должен возвращать универсальный интерфейс, как показано в следующем примере кода.

[!code-csharp[VbLinkCompilerCS#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/vblinkcompilercs/cs/utility.cs)]

В следующем примере клиентский код может вызывать метод, возвращающий универсальный интерфейс <xref:System.Collections.IList> без ошибок.

[!code-csharp[VbLinkCompilerCS#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/vblinkcompilercs/cs/program.cs#5)]
