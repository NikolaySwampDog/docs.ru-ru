---
title: Записи — справочник по C#
description: Сведения о типе записи в C#
ms.date: 02/25/2021
f1_keywords:
- record_CSharpKeyword
helpviewer_keywords:
- record keyword [C#]
- record type [C#]
ms.openlocfilehash: 067046a66c6eb1f314c123de8bde2d023f1f374a
ms.sourcegitcommit: e7e0921d0a10f85e9cb12f8b87cc1639a6c8d3fe
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/09/2021
ms.locfileid: "107255120"
---
# <a name="records-c-reference"></a>Записи (справочник по C#)

Начиная с C# версии 9 вы можете использовать ключевое слово `record` для определения [ссылочного типа](reference-types.md), который предоставляет встроенные возможности для инкапсуляции данных. Вы можете создавать типы записей с неизменяемыми свойствами, используя позиционные параметры или стандартный синтаксис свойств:

:::code language="csharp" source="snippets/shared/RecordType.cs" id="PositionalRecord":::
:::code language="csharp" source="snippets/shared/RecordType.cs" id="ImmutableRecord":::

Кроме того, можно создавать типы записей с изменяемыми свойствами и полями:

:::code language="csharp" source="snippets/shared/RecordType.cs" id="MutableRecord":::

Несмотря на поддержку изменения, записи предназначены в первую очередь для неизменяемых моделей данных. Тип записи предоставляет следующие возможности:

* [Краткий синтаксис для создания ссылочного типа с неизменяемыми свойствами.](#positional-syntax-for-property-definition)
* Встроенное поведение, полезное для ссылочного типа, ориентированного на данные:
  * [Равенство значений](#value-equality)
  * [Краткий синтаксис для обратимого изменения.](#nondestructive-mutation)
  * [Встроенное форматирование для отображения.](#built-in-formatting-for-display)
* [Поддержка иерархий наследования.](#inheritance)

Вы также можете на основе [типов структур](struct.md) создать типы, ориентированные на данные, которые поддерживают равенство значений и почти не определяют поведение. Но в сравнительно больших моделях данных типы структур имеют определенные недостатки:

* Они не поддерживают наследование.
* Они менее эффективны при определении равенства значений. Для типов значений метод <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> использует отражение для поиска всех полей. Для записей компилятор создает метод `Equals`. На практике реализация равенства значений в записях работает заметно быстрее.
* В некоторых сценариях они используют больше памяти, так как каждый экземпляр содержит полную копию всех данных. Типы записей являются [ссылочными типами](reference-types.md), то есть каждый экземпляр записи содержит только ссылку на данные.

## <a name="positional-syntax-for-property-definition"></a>Позиционный синтаксис для определения свойств

Позиционные параметры позволяют объявить свойства записи и инициализировать значения свойств при создании экземпляра:

:::code language="csharp" source="snippets/shared/RecordType.cs" id="InstantiatePositional":::

При использовании позиционного синтаксиса для определения свойства компилятор создает следующие элементы:

* Открытое автоматически реализуемое свойство "только init" создается для каждого позиционного параметра, предоставленного в объявлении записи. Свойство [только init](../keywords/init.md) может быть задано только в конструкторе или с помощью инициализатора свойств.
* Основной конструктор, параметры которого соответствуют позиционным параметрам в объявлении записи.
* Метод `Deconstruct` с параметром `out` создается для каждого позиционного параметра, предоставленного в объявлении записи. Этот метод предоставляется только в том случае, если предоставлено два или более позиционных параметров. Этот метод деконструирует свойства, определенные с помощью позиционного синтаксиса, и игнорирует любые свойства, определенные с помощью стандартного синтаксиса.

Если вам не подходит созданное определение автоматически реализуемого свойства, вы можете определить собственное свойство с тем же именем. В этом случае созданные конструктор и деконструктор будут использовать предоставленное вами определение свойства. Например, в следующем примере позиционное свойство `FirstName` получает атрибут `internal` вместо `public`.

:::code language="csharp" source="snippets/shared/RecordType.cs" id="PositionalWithManualProperty":::

В типе записи не обязательно объявлять позиционные свойства. Вы можете объявить запись без позиционных свойств или даже объявить дополнительные поля и свойства, как показано в следующем примере:

:::code language="csharp" source="snippets/shared/RecordType.cs" id="MixedSyntax":::

Если вы определите свойства с использованием стандартного синтаксиса свойств, но опустите модификатор доступа, эти свойства неявно становятся `public`.
<!-- Todo -- Explain issues surrounding use of attributes on positional properties. -->

## <a name="immutability"></a>Неизменяемость

Тип записи не обязательно является неизменяемым. Вы можете объявить свойства с методами доступа `set` и полями без атрибута `readonly`. Но несмотря на поддержку изменения, записи лучше всего подходят для создания неизменяемых моделей данных.

Неизменяемость может быть полезной, если требуется обеспечить потокобезопасность для типа, ориентированного на данные, или существует необходимость сохранять хэш-код в неизменном виде в хэш-таблице. Но все же неизменяемость пригодна не для всех сценариев работы с данными. Например, [Entity Framework Core](/ef/core/) не поддерживает обновление с неизменяемыми типами сущностей.

Свойства "только init", созданные на основе позиционных параметров или путем указания методов доступа `init`, имеют *неполную неизменяемость*. После инициализации вы не сможете изменить значения свойств с типом значения или ссылки на свойства ссылочного типа. Но вы можете изменить сами данные, на которые ссылается свойство ссылочного типа. В следующем примере показано, что содержимое неизменяемого свойства ссылочного типа (в нашем примере это массив) является по сути изменяемым:

:::code language="csharp" source="snippets/shared/RecordType.cs" id="ShallowImmutability":::

Возможности, уникальные для типов записей, реализуются синтезированными компилятором методами, ни один из которых не нарушает неизменяемость путем изменения состояния объекта.

## <a name="value-equality"></a>Равенство значений

Равенство значений означает, что две переменные типа записи считаются равными, если совпадают типы и значения всех свойств и полей. Для других ссылочных типов равенство означает полную идентичность. То есть две переменные ссылочного типа равны только в том случае, если они ссылаются на один и тот же объект.

Для некоторых моделей данных требуется ссылочное равенство. Например, [Entity Framework Core](/ef/core/) использует ссылочное равенство, чтобы гарантировать использование только одного экземпляра типа сущности в том случае, когда разные объекты концептуально являются одной сущностью. По этой причине типы записей не подходят для использования в качестве типов сущностей в Entity Framework Core.

Следующий пример демонстрирует равенство значений для типов записей:

:::code language="csharp" source="snippets/shared/RecordType.cs" id="Equality":::

Чтобы реализовать равенство значений, компилятор синтезирует следующие методы:

* Переопределение <xref:System.Object.Equals(System.Object)?displayProperty=nameWithType>.

  Этот метод используется как основа для статического метода <xref:System.Object.Equals(System.Object,System.Object)?displayProperty=nameWithType>, если оба параметра имеют отличное от NULL значение.

* Виртуальный метод `Equals`, параметр которого является типом записи. Этот метод реализует <xref:System.IEquatable%601>.

* Переопределение <xref:System.Object.GetHashCode?displayProperty=nameWithType>.

* Переопределения операторов `==` и `!=`.

В типах `class` можно вручную переопределить методы и операторы равенства, чтобы реализовать равенство значений, но разработка и тестирование такого кода занимают много времени и могут стать причиной ошибок. Если такая функциональность встроена изначально, это позволяет избежать ошибок, которые возникнут, когда вы забудете обновить пользовательский код переопределения при добавлении или изменении свойств или полей.

Вы можете написать собственные реализации и заменить ими любой из синтезированных методов. Если тип записи имеет метод, совпадающий с сигнатурой какого-либо синтезируемого метода, компилятор будет его синтезировать.

Если вы предоставляете в типе записи собственную реализацию `Equals`, предоставьте также реализацию `GetHashCode`.

## <a name="nondestructive-mutation"></a>Обратимое изменение

Если нужно изменить неизменяемые свойства экземпляра записи, вы можете с помощью выражения `with` выполнить *обратимое изменение*. Выражение `with` создает новый экземпляр записи, который является копией существующего экземпляра записи, и изменяет в этой копии указанные свойства и поля. Для указания требуемых изменений используется синтаксис [инициализатора объектов](../../programming-guide/classes-and-structs/object-and-collection-initializers.md), как показано в следующем примере:

:::code language="csharp" source="snippets/shared/RecordType.cs" id="WithExpressions":::

Выражение `with` может задавать позиционные свойства или свойства, созданные с помощью стандартного синтаксиса свойств. Непозиционные свойства должны иметь метод доступа `init` или `set`, чтобы их можно было изменять с помощью выражения `with`.

Результатом выражения `with` является *неполная копия*, то есть для ссылочных свойств в нее копируется только ссылка на экземпляр. В итоге исходная запись и ее копия указывают на один и тот же экземпляр.

Для реализации такой возможности компилятор синтезирует метод клонирования и конструктор копии. Этот конструктор принимает экземпляр записи для копирования и вызывает метод клонирования (clone). При использовании выражения `with` компилятор создает код, который вызывает конструктор копии, а затем устанавливает указанные в выражении `with` свойства.

Если требуется другое поведение копирования, вы можете написать собственный конструктор копирования. В этом случае компилятор не будет синтезировать конструктор. Присвойте конструктору атрибут `private`, если запись является `sealed`, или `protected` в противном случае.

Вы не можете переопределить метод клонирования или создать другой элемент с именем `Clone`. Фактическое имя метода клонирования создается компилятором.

## <a name="built-in-formatting-for-display"></a>Встроенное форматирование для отображения

Типы записей имеют создаваемый компилятором метод <xref:System.Object.ToString%2A>, который отображает имена и значения открытых свойств и полей. Метод `ToString` возвращает строку в следующем формате:

> \<record type name> { \<property name> = \<value>, \<property name> = \<value>, ...}

Для ссылочных типов вместо значения свойства отображается имя типа того объекта, на который ссылается это свойство. В следующем примере массив имеет ссылочный тип, поэтому отображается `System.String[]` вместо фактических значений элементов массива:

```
Person { FirstName = Nancy, LastName = Davolio, ChildNames = System.String[] }
```

Для реализации этой функциональной возможности компилятор синтезирует виртуальный метод `PrintMembers` и переопределение <xref:System.Object.ToString%2A>.
Переопределение `ToString` создает объект <xref:System.Text.StringBuilder> с именем типа, за которым следует открывающая квадратная скобка. Затем оно вызывает метод `PrintMembers`, который добавляет имена и значения свойств, а затем добавляет закрывающую скобку. В следующем примере показан код, аналогичный синтезированному переопределению:

:::code language="csharp" source="snippets/shared/RecordType.cs" id="ToStringOverrideDefault":::

Вы можете предоставить собственную реализацию `PrintMembers` или переопределения `ToString`. Примеры можно изучить в разделе [Форматирование `PrintMembers` в производных записях](#printmembers-formatting-in-derived-records) далее в этой статье.

## <a name="inheritance"></a>Наследование

Запись может наследовать от другой записи. Но запись не может наследовать от класса, а класс не может наследовать от записи.

### <a name="positional-parameters-in-derived-record-types"></a>Позиционные параметры в производных типах записей

Производная запись объявляет позиционные параметры для всех параметров, определенных в основном конструкторе базовой записи. Базовая запись объявляет и инициализирует эти свойства. Производная запись не скрывает их, но создает и инициализирует только свойства для параметров, которые не объявлены в базовой записи.

Следующий пример демонстрирует наследование с использованием синтаксиса позиционных свойств:

:::code language="csharp" source="snippets/shared/RecordType.cs" id="PositionalInheritance":::

### <a name="equality-in-inheritance-hierarchies"></a>Равенство в иерархиях наследования

Чтобы две переменные записи считались равными, у них должен совпадать тип времени выполнения. При этом типы содержащихся в них переменных могут отличаться. Это демонстрируется в следующем примере кода:

:::code language="csharp" source="snippets/shared/RecordType.cs" id="InheritanceEquality":::

В этом примере все экземпляры имеют одинаковые свойства и одинаковые значения этих свойств. Но `student == teacher` возвращает `False`, хотя обе переменные имеют тип `Person`, а `student == student2` возвращает `True`, хотя одна переменная имеет тип `Person`, а другая — `Student`.

Чтобы реализовать такое поведение, компилятор синтезирует свойство `EqualityContract`, которое возвращает объект <xref:System.Type>, соответствующий типу записи. Это позволяет методам равенства учитывать тип времени выполнения при сравнении объектов. Если запись имеет базовый тип `object`, это свойство получает атрибут `virtual`. Если базовый тип имеет другой тип записи, это свойство становится переопределением. Если тип записи имеет атрибут `sealed`, свойство также получает атрибут `sealed`.

При сравнении двух экземпляров производного типа синтезированные методы равенства проверяют на равенство все свойства базового и производного типов. Синтезированный метод `GetHashCode` использует метод `GetHashCode` всех свойств и полей, объявленных в базовом типе и в производном типе записи.

### <a name="with-expressions-in-derived-records"></a>Выражения `with` в производных записях

Так как синтезированной метод клонирования использует [ковариантный возвращаемый тип](~/_csharplang/proposals/csharp-9.0/covariant-returns.md), тип времени выполнения у результата выражения `with` будет таким же, как у операнда выражения. Копируются все свойства с типом времени выполнения, но изменять вы можете только свойства с типом времени компиляции, как показано в следующем примере:

:::code language="csharp" source="snippets/shared/RecordType.cs" id="WithExpressionInheritance":::

### <a name="printmembers-formatting-in-derived-records"></a>Форматирование `PrintMembers` в производных записях

Синтезированный метод `PrintMembers` из производного типа записи вызывает базовую реализацию. Это означает, что в выходные данные `ToString` включаются все свойства и поля с атрибутом public, как в производных, так и базовых типах, как показано в следующем примере:

:::code language="csharp" source="snippets/shared/RecordType.cs" id="ToStringInheritance":::

Вы можете предоставить собственную реализацию метода `PrintMembers`. В этом случае используйте следующую сигнатуру:

* Для записи `sealed`, которая является производной от `object` (не объявляет базовую запись): `private bool PrintMembers(StringBuilder builder)`.
* Для записи `sealed`, которая является производной от другой записи: `protected sealed override bool PrintMembers(StringBuilder builder)`.
* Для записи, которая не является `sealed` и наследует от объекта: `protected virtual bool PrintMembers(StringBuilder builder);`.
* Для записи, которая не является `sealed` и наследует от другой записи: `protected override bool PrintMembers(StringBuilder builder);`.

Ниже приведен пример кода, который заменяет синтезированные методы `PrintMembers`: один пример для типа записи, которая наследует от объекта, и другой для типа записи, которая наследует от другой записи:

:::code language="csharp" source="snippets/shared/RecordType.cs" id="PrintMembersImplementation":::

### <a name="deconstructor-behavior-in-derived-records"></a>Поведение деконструктора в производных записях

Метод `Deconstruct` производной записи возвращает значения всех позиционных свойств с типом времени компиляции. Если переменная имеет тип базовой записи, деконструкция выполняется только для свойств базовой записи, если объект не приведен к производному типу. Следующий пример демонстрирует вызов деконструктора для производной записи.

:::code language="csharp" source="snippets/shared/RecordType.cs" id="DeconstructorInheritance":::

## <a name="generic-constraints"></a>Общие ограничения

Не существует общих ограничений, по которым тип обязан являться записью. Записи соответствуют ограничению `class`. Чтобы задать ограничение для конкретной иерархии типов записей, задайте это ограничение для базовой записи, как обычно для базового класса. Дополнительные сведения см. в статье [Ограничения параметров типа](../../programming-guide/generics/constraints-on-type-parameters.md).

## <a name="c-language-specification"></a>Спецификация языка C#

Дополнительные сведения см. в разделе о [классах](~/_csharplang/spec/classes.md) в [спецификации языка C#](~/_csharplang/spec/introduction.md).

Дополнительные сведения о функциях, появившихся в C# версии 9 и более поздних, см. в следующих заметках о функциях:

- [Записи](~/_csharplang/proposals/csharp-9.0/records.md)
- [Методы задания init](~/_csharplang/proposals/csharp-9.0/init.md)
- [Ковариантные возвращаемые значения](~/_csharplang/proposals/csharp-9.0/covariant-returns.md)

## <a name="see-also"></a>См. также раздел

- [справочник по C#](../index.md)
- [Рекомендации по проектированию — выбор между классом и структурой](../../../standard/design-guidelines/choosing-between-class-and-struct.md)
- [Рекомендации по проектированию — проектирование структуры](../../../standard/design-guidelines/struct.md)
- [Классы и структуры](../../programming-guide/classes-and-structs/index.md)
- [Выражение `with`](../operators/with-expression.md)
