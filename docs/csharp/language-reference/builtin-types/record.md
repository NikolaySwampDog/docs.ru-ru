---
title: Записи — справочник по C#
description: Сведения о типе записи в C#
ms.date: 02/25/2021
f1_keywords:
- record_CSharpKeyword
helpviewer_keywords:
- record keyword [C#]
- record type [C#]
ms.openlocfilehash: 067046a66c6eb1f314c123de8bde2d023f1f374a
ms.sourcegitcommit: e7e0921d0a10f85e9cb12f8b87cc1639a6c8d3fe
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/09/2021
ms.locfileid: "107255120"
---
# <a name="records-c-reference"></a><span data-ttu-id="eef27-103">Записи (справочник по C#)</span><span class="sxs-lookup"><span data-stu-id="eef27-103">Records (C# reference)</span></span>

<span data-ttu-id="eef27-104">Начиная с C# версии 9 вы можете использовать ключевое слово `record` для определения [ссылочного типа](reference-types.md), который предоставляет встроенные возможности для инкапсуляции данных.</span><span class="sxs-lookup"><span data-stu-id="eef27-104">Beginning with C# 9, you use the `record` keyword to define a [reference type](reference-types.md) that provides built-in functionality for encapsulating data.</span></span> <span data-ttu-id="eef27-105">Вы можете создавать типы записей с неизменяемыми свойствами, используя позиционные параметры или стандартный синтаксис свойств:</span><span class="sxs-lookup"><span data-stu-id="eef27-105">You can create record types with immutable properties by using positional parameters or standard property syntax:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="PositionalRecord":::
:::code language="csharp" source="snippets/shared/RecordType.cs" id="ImmutableRecord":::

<span data-ttu-id="eef27-106">Кроме того, можно создавать типы записей с изменяемыми свойствами и полями:</span><span class="sxs-lookup"><span data-stu-id="eef27-106">You can also create record types with mutable properties and fields:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="MutableRecord":::

<span data-ttu-id="eef27-107">Несмотря на поддержку изменения, записи предназначены в первую очередь для неизменяемых моделей данных.</span><span class="sxs-lookup"><span data-stu-id="eef27-107">While records can be mutable, they are primarily intended for supporting immutable data models.</span></span> <span data-ttu-id="eef27-108">Тип записи предоставляет следующие возможности:</span><span class="sxs-lookup"><span data-stu-id="eef27-108">The record type offers the following features:</span></span>

* [<span data-ttu-id="eef27-109">Краткий синтаксис для создания ссылочного типа с неизменяемыми свойствами.</span><span class="sxs-lookup"><span data-stu-id="eef27-109">Concise syntax for creating a reference type with immutable properties</span></span>](#positional-syntax-for-property-definition)
* <span data-ttu-id="eef27-110">Встроенное поведение, полезное для ссылочного типа, ориентированного на данные:</span><span class="sxs-lookup"><span data-stu-id="eef27-110">Built-in behavior useful for a data-centric reference type:</span></span>
  * [<span data-ttu-id="eef27-111">Равенство значений</span><span class="sxs-lookup"><span data-stu-id="eef27-111">Value equality</span></span>](#value-equality)
  * [<span data-ttu-id="eef27-112">Краткий синтаксис для обратимого изменения.</span><span class="sxs-lookup"><span data-stu-id="eef27-112">Concise syntax for nondestructive mutation</span></span>](#nondestructive-mutation)
  * [<span data-ttu-id="eef27-113">Встроенное форматирование для отображения.</span><span class="sxs-lookup"><span data-stu-id="eef27-113">Built-in formatting for display</span></span>](#built-in-formatting-for-display)
* [<span data-ttu-id="eef27-114">Поддержка иерархий наследования.</span><span class="sxs-lookup"><span data-stu-id="eef27-114">Support for inheritance hierarchies</span></span>](#inheritance)

<span data-ttu-id="eef27-115">Вы также можете на основе [типов структур](struct.md) создать типы, ориентированные на данные, которые поддерживают равенство значений и почти не определяют поведение.</span><span class="sxs-lookup"><span data-stu-id="eef27-115">You can also use [structure types](struct.md) to design data-centric types that provide value equality and little or no behavior.</span></span> <span data-ttu-id="eef27-116">Но в сравнительно больших моделях данных типы структур имеют определенные недостатки:</span><span class="sxs-lookup"><span data-stu-id="eef27-116">But for relatively large data models, structure types have some disadvantages:</span></span>

* <span data-ttu-id="eef27-117">Они не поддерживают наследование.</span><span class="sxs-lookup"><span data-stu-id="eef27-117">They don't support inheritance.</span></span>
* <span data-ttu-id="eef27-118">Они менее эффективны при определении равенства значений.</span><span class="sxs-lookup"><span data-stu-id="eef27-118">They're less efficient at determining value equality.</span></span> <span data-ttu-id="eef27-119">Для типов значений метод <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> использует отражение для поиска всех полей.</span><span class="sxs-lookup"><span data-stu-id="eef27-119">For value types, the <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> method uses reflection to find all fields.</span></span> <span data-ttu-id="eef27-120">Для записей компилятор создает метод `Equals`.</span><span class="sxs-lookup"><span data-stu-id="eef27-120">For records, the compiler generates the `Equals` method.</span></span> <span data-ttu-id="eef27-121">На практике реализация равенства значений в записях работает заметно быстрее.</span><span class="sxs-lookup"><span data-stu-id="eef27-121">In practice, the implementation of value equality in records is measurably faster.</span></span>
* <span data-ttu-id="eef27-122">В некоторых сценариях они используют больше памяти, так как каждый экземпляр содержит полную копию всех данных.</span><span class="sxs-lookup"><span data-stu-id="eef27-122">They use more memory in some scenarios, since every instance has a complete copy of all of the data.</span></span> <span data-ttu-id="eef27-123">Типы записей являются [ссылочными типами](reference-types.md), то есть каждый экземпляр записи содержит только ссылку на данные.</span><span class="sxs-lookup"><span data-stu-id="eef27-123">Record types are [reference types](reference-types.md), so a record instance contains only a reference to the data.</span></span>

## <a name="positional-syntax-for-property-definition"></a><span data-ttu-id="eef27-124">Позиционный синтаксис для определения свойств</span><span class="sxs-lookup"><span data-stu-id="eef27-124">Positional syntax for property definition</span></span>

<span data-ttu-id="eef27-125">Позиционные параметры позволяют объявить свойства записи и инициализировать значения свойств при создании экземпляра:</span><span class="sxs-lookup"><span data-stu-id="eef27-125">You can use positional parameters to declare properties of a record and to initialize the property values when you create an instance:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="InstantiatePositional":::

<span data-ttu-id="eef27-126">При использовании позиционного синтаксиса для определения свойства компилятор создает следующие элементы:</span><span class="sxs-lookup"><span data-stu-id="eef27-126">When you use the positional syntax for property definition, the compiler creates:</span></span>

* <span data-ttu-id="eef27-127">Открытое автоматически реализуемое свойство "только init" создается для каждого позиционного параметра, предоставленного в объявлении записи.</span><span class="sxs-lookup"><span data-stu-id="eef27-127">A public init-only auto-implemented property for each positional parameter provided in the record declaration.</span></span> <span data-ttu-id="eef27-128">Свойство [только init](../keywords/init.md) может быть задано только в конструкторе или с помощью инициализатора свойств.</span><span class="sxs-lookup"><span data-stu-id="eef27-128">An [init-only](../keywords/init.md) property can only be set in the constructor or by using a property initializer.</span></span>
* <span data-ttu-id="eef27-129">Основной конструктор, параметры которого соответствуют позиционным параметрам в объявлении записи.</span><span class="sxs-lookup"><span data-stu-id="eef27-129">A primary constructor whose parameters match the positional parameters on the record declaration.</span></span>
* <span data-ttu-id="eef27-130">Метод `Deconstruct` с параметром `out` создается для каждого позиционного параметра, предоставленного в объявлении записи.</span><span class="sxs-lookup"><span data-stu-id="eef27-130">A `Deconstruct` method with an `out` parameter for each positional parameter provided in the record declaration.</span></span> <span data-ttu-id="eef27-131">Этот метод предоставляется только в том случае, если предоставлено два или более позиционных параметров.</span><span class="sxs-lookup"><span data-stu-id="eef27-131">This method is provided only if there are two or more positional parameters.</span></span> <span data-ttu-id="eef27-132">Этот метод деконструирует свойства, определенные с помощью позиционного синтаксиса, и игнорирует любые свойства, определенные с помощью стандартного синтаксиса.</span><span class="sxs-lookup"><span data-stu-id="eef27-132">The method deconstructs properties defined by using positional syntax; it ignores properties that are defined by using standard property syntax.</span></span>

<span data-ttu-id="eef27-133">Если вам не подходит созданное определение автоматически реализуемого свойства, вы можете определить собственное свойство с тем же именем.</span><span class="sxs-lookup"><span data-stu-id="eef27-133">If the generated auto-implemented property definition isn't what you want, you can define your own property of the same name.</span></span> <span data-ttu-id="eef27-134">В этом случае созданные конструктор и деконструктор будут использовать предоставленное вами определение свойства.</span><span class="sxs-lookup"><span data-stu-id="eef27-134">If you do that, the generated constructor and deconstructor will use your property definition.</span></span> <span data-ttu-id="eef27-135">Например, в следующем примере позиционное свойство `FirstName` получает атрибут `internal` вместо `public`.</span><span class="sxs-lookup"><span data-stu-id="eef27-135">For instance, the following example makes the `FirstName` positional property `internal` instead of `public`.</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="PositionalWithManualProperty":::

<span data-ttu-id="eef27-136">В типе записи не обязательно объявлять позиционные свойства.</span><span class="sxs-lookup"><span data-stu-id="eef27-136">A record type doesn't have to declare any positional properties.</span></span> <span data-ttu-id="eef27-137">Вы можете объявить запись без позиционных свойств или даже объявить дополнительные поля и свойства, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="eef27-137">You can declare a record without any positional properties, and you can declare additional fields and properties, as in the following example:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="MixedSyntax":::

<span data-ttu-id="eef27-138">Если вы определите свойства с использованием стандартного синтаксиса свойств, но опустите модификатор доступа, эти свойства неявно становятся `public`.</span><span class="sxs-lookup"><span data-stu-id="eef27-138">If you define properties by using standard property syntax but omit the access modifier, the properties are implicitly `public`.</span></span>
<!-- Todo -- Explain issues surrounding use of attributes on positional properties. -->

## <a name="immutability"></a><span data-ttu-id="eef27-139">Неизменяемость</span><span class="sxs-lookup"><span data-stu-id="eef27-139">Immutability</span></span>

<span data-ttu-id="eef27-140">Тип записи не обязательно является неизменяемым.</span><span class="sxs-lookup"><span data-stu-id="eef27-140">A record type is not necessarily immutable.</span></span> <span data-ttu-id="eef27-141">Вы можете объявить свойства с методами доступа `set` и полями без атрибута `readonly`.</span><span class="sxs-lookup"><span data-stu-id="eef27-141">You can declare properties with `set` accessors and fields that aren't `readonly`.</span></span> <span data-ttu-id="eef27-142">Но несмотря на поддержку изменения, записи лучше всего подходят для создания неизменяемых моделей данных.</span><span class="sxs-lookup"><span data-stu-id="eef27-142">But while records can be mutable, they make it easier to create immutable data models.</span></span>

<span data-ttu-id="eef27-143">Неизменяемость может быть полезной, если требуется обеспечить потокобезопасность для типа, ориентированного на данные, или существует необходимость сохранять хэш-код в неизменном виде в хэш-таблице.</span><span class="sxs-lookup"><span data-stu-id="eef27-143">Immutability can be useful when you need a data-centric type to be thread-safe or you're depending on a hash code remaining the same in a hash table.</span></span> <span data-ttu-id="eef27-144">Но все же неизменяемость пригодна не для всех сценариев работы с данными.</span><span class="sxs-lookup"><span data-stu-id="eef27-144">Immutability isn't appropriate for all data scenarios, however.</span></span> <span data-ttu-id="eef27-145">Например, [Entity Framework Core](/ef/core/) не поддерживает обновление с неизменяемыми типами сущностей.</span><span class="sxs-lookup"><span data-stu-id="eef27-145">[Entity Framework Core](/ef/core/), for example, doesn't support updating with immutable entity types.</span></span>

<span data-ttu-id="eef27-146">Свойства "только init", созданные на основе позиционных параметров или путем указания методов доступа `init`, имеют *неполную неизменяемость*.</span><span class="sxs-lookup"><span data-stu-id="eef27-146">Init-only properties, whether created from positional parameters or by specifying `init` accessors, have *shallow immutability*.</span></span> <span data-ttu-id="eef27-147">После инициализации вы не сможете изменить значения свойств с типом значения или ссылки на свойства ссылочного типа.</span><span class="sxs-lookup"><span data-stu-id="eef27-147">After initialization, you can't change the value of value-type properties or the reference of reference-type properties.</span></span> <span data-ttu-id="eef27-148">Но вы можете изменить сами данные, на которые ссылается свойство ссылочного типа.</span><span class="sxs-lookup"><span data-stu-id="eef27-148">However, the data that a reference-type property refers to can be changed.</span></span> <span data-ttu-id="eef27-149">В следующем примере показано, что содержимое неизменяемого свойства ссылочного типа (в нашем примере это массив) является по сути изменяемым:</span><span class="sxs-lookup"><span data-stu-id="eef27-149">The following example shows that the content of a reference-type immutable property (an array in this case) is mutable:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="ShallowImmutability":::

<span data-ttu-id="eef27-150">Возможности, уникальные для типов записей, реализуются синтезированными компилятором методами, ни один из которых не нарушает неизменяемость путем изменения состояния объекта.</span><span class="sxs-lookup"><span data-stu-id="eef27-150">The features unique to record types are implemented by compiler-synthesized methods, and none of these methods compromises immutability by modifying object state.</span></span>

## <a name="value-equality"></a><span data-ttu-id="eef27-151">Равенство значений</span><span class="sxs-lookup"><span data-stu-id="eef27-151">Value equality</span></span>

<span data-ttu-id="eef27-152">Равенство значений означает, что две переменные типа записи считаются равными, если совпадают типы и значения всех свойств и полей.</span><span class="sxs-lookup"><span data-stu-id="eef27-152">Value equality means that two variables of a record type are equal if the types match and all property and field values match.</span></span> <span data-ttu-id="eef27-153">Для других ссылочных типов равенство означает полную идентичность.</span><span class="sxs-lookup"><span data-stu-id="eef27-153">For other reference types, equality means identity.</span></span> <span data-ttu-id="eef27-154">То есть две переменные ссылочного типа равны только в том случае, если они ссылаются на один и тот же объект.</span><span class="sxs-lookup"><span data-stu-id="eef27-154">That is, two variables of a reference type are equal if they refer to the same object.</span></span>

<span data-ttu-id="eef27-155">Для некоторых моделей данных требуется ссылочное равенство.</span><span class="sxs-lookup"><span data-stu-id="eef27-155">Reference equality is required for some data models.</span></span> <span data-ttu-id="eef27-156">Например, [Entity Framework Core](/ef/core/) использует ссылочное равенство, чтобы гарантировать использование только одного экземпляра типа сущности в том случае, когда разные объекты концептуально являются одной сущностью.</span><span class="sxs-lookup"><span data-stu-id="eef27-156">For example, [Entity Framework Core](/ef/core/) depends on reference equality to ensure that it uses only one instance of an entity type for what is conceptually one entity.</span></span> <span data-ttu-id="eef27-157">По этой причине типы записей не подходят для использования в качестве типов сущностей в Entity Framework Core.</span><span class="sxs-lookup"><span data-stu-id="eef27-157">For this reason, record types aren't appropriate for use as entity types in Entity Framework Core.</span></span>

<span data-ttu-id="eef27-158">Следующий пример демонстрирует равенство значений для типов записей:</span><span class="sxs-lookup"><span data-stu-id="eef27-158">The following example illustrates value equality of record types:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="Equality":::

<span data-ttu-id="eef27-159">Чтобы реализовать равенство значений, компилятор синтезирует следующие методы:</span><span class="sxs-lookup"><span data-stu-id="eef27-159">To implement value equality, the compiler synthesizes the following methods:</span></span>

* <span data-ttu-id="eef27-160">Переопределение <xref:System.Object.Equals(System.Object)?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="eef27-160">An override of <xref:System.Object.Equals(System.Object)?displayProperty=nameWithType>.</span></span>

  <span data-ttu-id="eef27-161">Этот метод используется как основа для статического метода <xref:System.Object.Equals(System.Object,System.Object)?displayProperty=nameWithType>, если оба параметра имеют отличное от NULL значение.</span><span class="sxs-lookup"><span data-stu-id="eef27-161">This method is used as the basis for the <xref:System.Object.Equals(System.Object,System.Object)?displayProperty=nameWithType> static method when both parameters are non-null.</span></span>

* <span data-ttu-id="eef27-162">Виртуальный метод `Equals`, параметр которого является типом записи.</span><span class="sxs-lookup"><span data-stu-id="eef27-162">A virtual `Equals` method whose parameter is the record type.</span></span> <span data-ttu-id="eef27-163">Этот метод реализует <xref:System.IEquatable%601>.</span><span class="sxs-lookup"><span data-stu-id="eef27-163">This method implements <xref:System.IEquatable%601>.</span></span>

* <span data-ttu-id="eef27-164">Переопределение <xref:System.Object.GetHashCode?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="eef27-164">An override of <xref:System.Object.GetHashCode?displayProperty=nameWithType>.</span></span>

* <span data-ttu-id="eef27-165">Переопределения операторов `==` и `!=`.</span><span class="sxs-lookup"><span data-stu-id="eef27-165">Overrides of operators `==` and `!=`.</span></span>

<span data-ttu-id="eef27-166">В типах `class` можно вручную переопределить методы и операторы равенства, чтобы реализовать равенство значений, но разработка и тестирование такого кода занимают много времени и могут стать причиной ошибок.</span><span class="sxs-lookup"><span data-stu-id="eef27-166">In `class` types, you could manually override equality methods and operators to achieve value equality, but developing and testing that code would be time-consuming and error-prone.</span></span> <span data-ttu-id="eef27-167">Если такая функциональность встроена изначально, это позволяет избежать ошибок, которые возникнут, когда вы забудете обновить пользовательский код переопределения при добавлении или изменении свойств или полей.</span><span class="sxs-lookup"><span data-stu-id="eef27-167">Having this functionality built-in prevents bugs that would result from forgetting to update custom override code when properties or fields are added or changed.</span></span>

<span data-ttu-id="eef27-168">Вы можете написать собственные реализации и заменить ими любой из синтезированных методов.</span><span class="sxs-lookup"><span data-stu-id="eef27-168">You can write your own implementations to replace any of these synthesized methods.</span></span> <span data-ttu-id="eef27-169">Если тип записи имеет метод, совпадающий с сигнатурой какого-либо синтезируемого метода, компилятор будет его синтезировать.</span><span class="sxs-lookup"><span data-stu-id="eef27-169">If a record type has a method that matches the signature of any synthesized method, the compiler doesn't synthesize that method.</span></span>

<span data-ttu-id="eef27-170">Если вы предоставляете в типе записи собственную реализацию `Equals`, предоставьте также реализацию `GetHashCode`.</span><span class="sxs-lookup"><span data-stu-id="eef27-170">If you provide your own implementation of `Equals` in a record type, provide an implementation of `GetHashCode` also.</span></span>

## <a name="nondestructive-mutation"></a><span data-ttu-id="eef27-171">Обратимое изменение</span><span class="sxs-lookup"><span data-stu-id="eef27-171">Nondestructive mutation</span></span>

<span data-ttu-id="eef27-172">Если нужно изменить неизменяемые свойства экземпляра записи, вы можете с помощью выражения `with` выполнить *обратимое изменение*.</span><span class="sxs-lookup"><span data-stu-id="eef27-172">If you need to mutate immutable properties of a record instance, you can use a `with` expression to achieve *nondestructive mutation*.</span></span> <span data-ttu-id="eef27-173">Выражение `with` создает новый экземпляр записи, который является копией существующего экземпляра записи, и изменяет в этой копии указанные свойства и поля.</span><span class="sxs-lookup"><span data-stu-id="eef27-173">A `with` expression makes a new record instance that is a copy of an existing record instance, with specified properties and fields modified.</span></span> <span data-ttu-id="eef27-174">Для указания требуемых изменений используется синтаксис [инициализатора объектов](../../programming-guide/classes-and-structs/object-and-collection-initializers.md), как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="eef27-174">You use [object initializer](../../programming-guide/classes-and-structs/object-and-collection-initializers.md) syntax to specify the values to be changed, as shown in the following example:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="WithExpressions":::

<span data-ttu-id="eef27-175">Выражение `with` может задавать позиционные свойства или свойства, созданные с помощью стандартного синтаксиса свойств.</span><span class="sxs-lookup"><span data-stu-id="eef27-175">The `with` expression can set positional properties or properties created by using standard property syntax.</span></span> <span data-ttu-id="eef27-176">Непозиционные свойства должны иметь метод доступа `init` или `set`, чтобы их можно было изменять с помощью выражения `with`.</span><span class="sxs-lookup"><span data-stu-id="eef27-176">Non-positional properties must have an `init` or `set` accessor to be changed in a `with` expression.</span></span>

<span data-ttu-id="eef27-177">Результатом выражения `with` является *неполная копия*, то есть для ссылочных свойств в нее копируется только ссылка на экземпляр.</span><span class="sxs-lookup"><span data-stu-id="eef27-177">The result of a `with` expression is a *shallow copy*, which means that for a reference property, only the reference to an instance is copied.</span></span> <span data-ttu-id="eef27-178">В итоге исходная запись и ее копия указывают на один и тот же экземпляр.</span><span class="sxs-lookup"><span data-stu-id="eef27-178">Both the original record and the copy end up with a reference to the same instance.</span></span>

<span data-ttu-id="eef27-179">Для реализации такой возможности компилятор синтезирует метод клонирования и конструктор копии.</span><span class="sxs-lookup"><span data-stu-id="eef27-179">To implement this feature, the compiler synthesizes a clone method and a copy constructor.</span></span> <span data-ttu-id="eef27-180">Этот конструктор принимает экземпляр записи для копирования и вызывает метод клонирования (clone).</span><span class="sxs-lookup"><span data-stu-id="eef27-180">The constructor takes an instance of the record to be copied and calls the clone method.</span></span> <span data-ttu-id="eef27-181">При использовании выражения `with` компилятор создает код, который вызывает конструктор копии, а затем устанавливает указанные в выражении `with` свойства.</span><span class="sxs-lookup"><span data-stu-id="eef27-181">When you use a `with` expression, the compiler creates code that calls the copy constructor and then sets the properties that are specified in the `with` expression.</span></span>

<span data-ttu-id="eef27-182">Если требуется другое поведение копирования, вы можете написать собственный конструктор копирования.</span><span class="sxs-lookup"><span data-stu-id="eef27-182">If you need different copying behavior, you can write your own copy constructor.</span></span> <span data-ttu-id="eef27-183">В этом случае компилятор не будет синтезировать конструктор.</span><span class="sxs-lookup"><span data-stu-id="eef27-183">If you do that, the compiler won't synthesize one.</span></span> <span data-ttu-id="eef27-184">Присвойте конструктору атрибут `private`, если запись является `sealed`, или `protected` в противном случае.</span><span class="sxs-lookup"><span data-stu-id="eef27-184">Make your constructor `private` if the record is `sealed`, otherwise make it `protected`.</span></span>

<span data-ttu-id="eef27-185">Вы не можете переопределить метод клонирования или создать другой элемент с именем `Clone`.</span><span class="sxs-lookup"><span data-stu-id="eef27-185">You can't override the clone method, and you can't create a member named `Clone`.</span></span> <span data-ttu-id="eef27-186">Фактическое имя метода клонирования создается компилятором.</span><span class="sxs-lookup"><span data-stu-id="eef27-186">The actual name of the clone method is compiler-generated.</span></span>

## <a name="built-in-formatting-for-display"></a><span data-ttu-id="eef27-187">Встроенное форматирование для отображения</span><span class="sxs-lookup"><span data-stu-id="eef27-187">Built-in formatting for display</span></span>

<span data-ttu-id="eef27-188">Типы записей имеют создаваемый компилятором метод <xref:System.Object.ToString%2A>, который отображает имена и значения открытых свойств и полей.</span><span class="sxs-lookup"><span data-stu-id="eef27-188">Record types have a compiler-generated <xref:System.Object.ToString%2A> method that displays the names and values of public properties and fields.</span></span> <span data-ttu-id="eef27-189">Метод `ToString` возвращает строку в следующем формате:</span><span class="sxs-lookup"><span data-stu-id="eef27-189">The `ToString` method returns a string of the following format:</span></span>

> <span data-ttu-id="eef27-190">\<record type name> { \<property name> = \<value>, \<property name> = \<value>, ...}</span><span class="sxs-lookup"><span data-stu-id="eef27-190">\<record type name> { \<property name> = \<value>, \<property name> = \<value>, ...}</span></span>

<span data-ttu-id="eef27-191">Для ссылочных типов вместо значения свойства отображается имя типа того объекта, на который ссылается это свойство.</span><span class="sxs-lookup"><span data-stu-id="eef27-191">For reference types, the type name of the object that the property refers to is displayed instead of the property value.</span></span> <span data-ttu-id="eef27-192">В следующем примере массив имеет ссылочный тип, поэтому отображается `System.String[]` вместо фактических значений элементов массива:</span><span class="sxs-lookup"><span data-stu-id="eef27-192">In the following example, the array is a reference type, so `System.String[]` is displayed instead of the actual array element values:</span></span>

```
Person { FirstName = Nancy, LastName = Davolio, ChildNames = System.String[] }
```

<span data-ttu-id="eef27-193">Для реализации этой функциональной возможности компилятор синтезирует виртуальный метод `PrintMembers` и переопределение <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="eef27-193">To implement this feature, the compiler synthesizes a virtual `PrintMembers` method and a <xref:System.Object.ToString%2A> override.</span></span>
<span data-ttu-id="eef27-194">Переопределение `ToString` создает объект <xref:System.Text.StringBuilder> с именем типа, за которым следует открывающая квадратная скобка.</span><span class="sxs-lookup"><span data-stu-id="eef27-194">The `ToString` override creates a <xref:System.Text.StringBuilder> object with the type name followed by an opening bracket.</span></span> <span data-ttu-id="eef27-195">Затем оно вызывает метод `PrintMembers`, который добавляет имена и значения свойств, а затем добавляет закрывающую скобку.</span><span class="sxs-lookup"><span data-stu-id="eef27-195">It calls `PrintMembers` to add property names and values, then adds the closing bracket.</span></span> <span data-ttu-id="eef27-196">В следующем примере показан код, аналогичный синтезированному переопределению:</span><span class="sxs-lookup"><span data-stu-id="eef27-196">The following example shows code similar to what the synthesized override contains:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="ToStringOverrideDefault":::

<span data-ttu-id="eef27-197">Вы можете предоставить собственную реализацию `PrintMembers` или переопределения `ToString`.</span><span class="sxs-lookup"><span data-stu-id="eef27-197">You can provide your own implementation of `PrintMembers` or the `ToString` override.</span></span> <span data-ttu-id="eef27-198">Примеры можно изучить в разделе [Форматирование `PrintMembers` в производных записях](#printmembers-formatting-in-derived-records) далее в этой статье.</span><span class="sxs-lookup"><span data-stu-id="eef27-198">Examples are provided in the [`PrintMembers` formatting in derived records](#printmembers-formatting-in-derived-records) section later in this article.</span></span>

## <a name="inheritance"></a><span data-ttu-id="eef27-199">Наследование</span><span class="sxs-lookup"><span data-stu-id="eef27-199">Inheritance</span></span>

<span data-ttu-id="eef27-200">Запись может наследовать от другой записи.</span><span class="sxs-lookup"><span data-stu-id="eef27-200">A record can inherit from another record.</span></span> <span data-ttu-id="eef27-201">Но запись не может наследовать от класса, а класс не может наследовать от записи.</span><span class="sxs-lookup"><span data-stu-id="eef27-201">However, a record can't inherit from a class, and a class can't inherit from a record.</span></span>

### <a name="positional-parameters-in-derived-record-types"></a><span data-ttu-id="eef27-202">Позиционные параметры в производных типах записей</span><span class="sxs-lookup"><span data-stu-id="eef27-202">Positional parameters in derived record types</span></span>

<span data-ttu-id="eef27-203">Производная запись объявляет позиционные параметры для всех параметров, определенных в основном конструкторе базовой записи.</span><span class="sxs-lookup"><span data-stu-id="eef27-203">The derived record declares positional parameters for all the parameters in the base record primary constructor.</span></span> <span data-ttu-id="eef27-204">Базовая запись объявляет и инициализирует эти свойства.</span><span class="sxs-lookup"><span data-stu-id="eef27-204">The base record declares and initializes those properties.</span></span> <span data-ttu-id="eef27-205">Производная запись не скрывает их, но создает и инициализирует только свойства для параметров, которые не объявлены в базовой записи.</span><span class="sxs-lookup"><span data-stu-id="eef27-205">The derived record doesn't hide them, but only creates and initializes properties for parameters that aren't declared in its base record.</span></span>

<span data-ttu-id="eef27-206">Следующий пример демонстрирует наследование с использованием синтаксиса позиционных свойств:</span><span class="sxs-lookup"><span data-stu-id="eef27-206">The following example illustrates inheritance with positional property syntax:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="PositionalInheritance":::

### <a name="equality-in-inheritance-hierarchies"></a><span data-ttu-id="eef27-207">Равенство в иерархиях наследования</span><span class="sxs-lookup"><span data-stu-id="eef27-207">Equality in inheritance hierarchies</span></span>

<span data-ttu-id="eef27-208">Чтобы две переменные записи считались равными, у них должен совпадать тип времени выполнения.</span><span class="sxs-lookup"><span data-stu-id="eef27-208">For two record variables to be equal, the run-time type must be equal.</span></span> <span data-ttu-id="eef27-209">При этом типы содержащихся в них переменных могут отличаться.</span><span class="sxs-lookup"><span data-stu-id="eef27-209">The types of the containing variables might be different.</span></span> <span data-ttu-id="eef27-210">Это демонстрируется в следующем примере кода:</span><span class="sxs-lookup"><span data-stu-id="eef27-210">This is illustrated in the following code example:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="InheritanceEquality":::

<span data-ttu-id="eef27-211">В этом примере все экземпляры имеют одинаковые свойства и одинаковые значения этих свойств.</span><span class="sxs-lookup"><span data-stu-id="eef27-211">In the example, all instances have the same properties and the same property values.</span></span> <span data-ttu-id="eef27-212">Но `student == teacher` возвращает `False`, хотя обе переменные имеют тип `Person`, а `student == student2` возвращает `True`, хотя одна переменная имеет тип `Person`, а другая — `Student`.</span><span class="sxs-lookup"><span data-stu-id="eef27-212">But `student == teacher` returns `False` although both are `Person`-type variables, and `student == student2` returns `True` although one is a `Person` variable and one is a `Student` variable.</span></span>

<span data-ttu-id="eef27-213">Чтобы реализовать такое поведение, компилятор синтезирует свойство `EqualityContract`, которое возвращает объект <xref:System.Type>, соответствующий типу записи.</span><span class="sxs-lookup"><span data-stu-id="eef27-213">To implement this behavior, the compiler synthesizes an `EqualityContract` property that returns a <xref:System.Type> object that matches the type of the record.</span></span> <span data-ttu-id="eef27-214">Это позволяет методам равенства учитывать тип времени выполнения при сравнении объектов.</span><span class="sxs-lookup"><span data-stu-id="eef27-214">This enables the equality methods to compare the runtime type of objects when they are checking for equality.</span></span> <span data-ttu-id="eef27-215">Если запись имеет базовый тип `object`, это свойство получает атрибут `virtual`.</span><span class="sxs-lookup"><span data-stu-id="eef27-215">If the base type of a record is `object`, this property is `virtual`.</span></span> <span data-ttu-id="eef27-216">Если базовый тип имеет другой тип записи, это свойство становится переопределением.</span><span class="sxs-lookup"><span data-stu-id="eef27-216">If the base type is another record type, this property is an override.</span></span> <span data-ttu-id="eef27-217">Если тип записи имеет атрибут `sealed`, свойство также получает атрибут `sealed`.</span><span class="sxs-lookup"><span data-stu-id="eef27-217">If the record type is `sealed`, this property is `sealed`.</span></span>

<span data-ttu-id="eef27-218">При сравнении двух экземпляров производного типа синтезированные методы равенства проверяют на равенство все свойства базового и производного типов.</span><span class="sxs-lookup"><span data-stu-id="eef27-218">When comparing two instances of a derived type, the synthesized equality methods check all properties of the base and derived types for equality.</span></span> <span data-ttu-id="eef27-219">Синтезированный метод `GetHashCode` использует метод `GetHashCode` всех свойств и полей, объявленных в базовом типе и в производном типе записи.</span><span class="sxs-lookup"><span data-stu-id="eef27-219">The synthesized `GetHashCode` method uses the `GetHashCode` method from all properties and fields declared in the base type and the derived record type.</span></span>

### <a name="with-expressions-in-derived-records"></a><span data-ttu-id="eef27-220">Выражения `with` в производных записях</span><span class="sxs-lookup"><span data-stu-id="eef27-220">`with` expressions in derived records</span></span>

<span data-ttu-id="eef27-221">Так как синтезированной метод клонирования использует [ковариантный возвращаемый тип](~/_csharplang/proposals/csharp-9.0/covariant-returns.md), тип времени выполнения у результата выражения `with` будет таким же, как у операнда выражения.</span><span class="sxs-lookup"><span data-stu-id="eef27-221">Because the synthesized clone method uses a [covariant return type](~/_csharplang/proposals/csharp-9.0/covariant-returns.md), the result of a `with` expression has the same run-time type as the expression's operand.</span></span> <span data-ttu-id="eef27-222">Копируются все свойства с типом времени выполнения, но изменять вы можете только свойства с типом времени компиляции, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="eef27-222">All properties of the run-time type get copied, but you can only set properties of the compile-time type, as the following example shows:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="WithExpressionInheritance":::

### <a name="printmembers-formatting-in-derived-records"></a><span data-ttu-id="eef27-223">Форматирование `PrintMembers` в производных записях</span><span class="sxs-lookup"><span data-stu-id="eef27-223">`PrintMembers` formatting in derived records</span></span>

<span data-ttu-id="eef27-224">Синтезированный метод `PrintMembers` из производного типа записи вызывает базовую реализацию.</span><span class="sxs-lookup"><span data-stu-id="eef27-224">The synthesized `PrintMembers` method of a derived record type calls the base implementation.</span></span> <span data-ttu-id="eef27-225">Это означает, что в выходные данные `ToString` включаются все свойства и поля с атрибутом public, как в производных, так и базовых типах, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="eef27-225">The result is that all public properties and fields of both derived and base types are included in the `ToString` output, as shown in the following example:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="ToStringInheritance":::

<span data-ttu-id="eef27-226">Вы можете предоставить собственную реализацию метода `PrintMembers`.</span><span class="sxs-lookup"><span data-stu-id="eef27-226">You can provide your own implementation of the `PrintMembers` method.</span></span> <span data-ttu-id="eef27-227">В этом случае используйте следующую сигнатуру:</span><span class="sxs-lookup"><span data-stu-id="eef27-227">If you do that, use the following signature:</span></span>

* <span data-ttu-id="eef27-228">Для записи `sealed`, которая является производной от `object` (не объявляет базовую запись): `private bool PrintMembers(StringBuilder builder)`.</span><span class="sxs-lookup"><span data-stu-id="eef27-228">For a `sealed` record that derives from `object` (doesn't declare a base record): `private bool PrintMembers(StringBuilder builder)`;</span></span>
* <span data-ttu-id="eef27-229">Для записи `sealed`, которая является производной от другой записи: `protected sealed override bool PrintMembers(StringBuilder builder)`.</span><span class="sxs-lookup"><span data-stu-id="eef27-229">For a `sealed` record that derives from another record: `protected sealed override bool PrintMembers(StringBuilder builder)`;</span></span>
* <span data-ttu-id="eef27-230">Для записи, которая не является `sealed` и наследует от объекта: `protected virtual bool PrintMembers(StringBuilder builder);`.</span><span class="sxs-lookup"><span data-stu-id="eef27-230">For a record that isn't `sealed` and derives from object: `protected virtual bool PrintMembers(StringBuilder builder);`</span></span>
* <span data-ttu-id="eef27-231">Для записи, которая не является `sealed` и наследует от другой записи: `protected override bool PrintMembers(StringBuilder builder);`.</span><span class="sxs-lookup"><span data-stu-id="eef27-231">For a record that isn't `sealed` and derives from another record: `protected override bool PrintMembers(StringBuilder builder);`</span></span>

<span data-ttu-id="eef27-232">Ниже приведен пример кода, который заменяет синтезированные методы `PrintMembers`: один пример для типа записи, которая наследует от объекта, и другой для типа записи, которая наследует от другой записи:</span><span class="sxs-lookup"><span data-stu-id="eef27-232">Here is an example of code that replaces the synthesized `PrintMembers` methods, one for a record type that derives from object, and one for a record type that derives from another record:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="PrintMembersImplementation":::

### <a name="deconstructor-behavior-in-derived-records"></a><span data-ttu-id="eef27-233">Поведение деконструктора в производных записях</span><span class="sxs-lookup"><span data-stu-id="eef27-233">Deconstructor behavior in derived records</span></span>

<span data-ttu-id="eef27-234">Метод `Deconstruct` производной записи возвращает значения всех позиционных свойств с типом времени компиляции.</span><span class="sxs-lookup"><span data-stu-id="eef27-234">The `Deconstruct` method of a derived record returns the values of all positional properties of the compile-time type.</span></span> <span data-ttu-id="eef27-235">Если переменная имеет тип базовой записи, деконструкция выполняется только для свойств базовой записи, если объект не приведен к производному типу.</span><span class="sxs-lookup"><span data-stu-id="eef27-235">If the variable type is a base record, only the base record properties are deconstructed unless the object is cast to the derived type.</span></span> <span data-ttu-id="eef27-236">Следующий пример демонстрирует вызов деконструктора для производной записи.</span><span class="sxs-lookup"><span data-stu-id="eef27-236">The following example demonstrates calling a deconstructor on a derived record.</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="DeconstructorInheritance":::

## <a name="generic-constraints"></a><span data-ttu-id="eef27-237">Общие ограничения</span><span class="sxs-lookup"><span data-stu-id="eef27-237">Generic constraints</span></span>

<span data-ttu-id="eef27-238">Не существует общих ограничений, по которым тип обязан являться записью.</span><span class="sxs-lookup"><span data-stu-id="eef27-238">There is no generic constraint that requires a type to be a record.</span></span> <span data-ttu-id="eef27-239">Записи соответствуют ограничению `class`.</span><span class="sxs-lookup"><span data-stu-id="eef27-239">Records satisfy the `class` constraint.</span></span> <span data-ttu-id="eef27-240">Чтобы задать ограничение для конкретной иерархии типов записей, задайте это ограничение для базовой записи, как обычно для базового класса.</span><span class="sxs-lookup"><span data-stu-id="eef27-240">To make a constraint on a specific hierarchy of record types, put the constraint on the base record as you would a base class.</span></span> <span data-ttu-id="eef27-241">Дополнительные сведения см. в статье [Ограничения параметров типа](../../programming-guide/generics/constraints-on-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="eef27-241">For more information, see [Constraints on type parameters](../../programming-guide/generics/constraints-on-type-parameters.md).</span></span>

## <a name="c-language-specification"></a><span data-ttu-id="eef27-242">Спецификация языка C#</span><span class="sxs-lookup"><span data-stu-id="eef27-242">C# language specification</span></span>

<span data-ttu-id="eef27-243">Дополнительные сведения см. в разделе о [классах](~/_csharplang/spec/classes.md) в [спецификации языка C#](~/_csharplang/spec/introduction.md).</span><span class="sxs-lookup"><span data-stu-id="eef27-243">For more information, see the [Classes](~/_csharplang/spec/classes.md) section of the [C# language specification](~/_csharplang/spec/introduction.md).</span></span>

<span data-ttu-id="eef27-244">Дополнительные сведения о функциях, появившихся в C# версии 9 и более поздних, см. в следующих заметках о функциях:</span><span class="sxs-lookup"><span data-stu-id="eef27-244">For more information about features introduced in C# 9 and later, see the following feature proposal notes:</span></span>

- [<span data-ttu-id="eef27-245">Записи</span><span class="sxs-lookup"><span data-stu-id="eef27-245">Records</span></span>](~/_csharplang/proposals/csharp-9.0/records.md)
- [<span data-ttu-id="eef27-246">Методы задания init</span><span class="sxs-lookup"><span data-stu-id="eef27-246">Init-only setters</span></span>](~/_csharplang/proposals/csharp-9.0/init.md)
- [<span data-ttu-id="eef27-247">Ковариантные возвращаемые значения</span><span class="sxs-lookup"><span data-stu-id="eef27-247">Covariant returns</span></span>](~/_csharplang/proposals/csharp-9.0/covariant-returns.md)

## <a name="see-also"></a><span data-ttu-id="eef27-248">См. также раздел</span><span class="sxs-lookup"><span data-stu-id="eef27-248">See also</span></span>

- [<span data-ttu-id="eef27-249">справочник по C#</span><span class="sxs-lookup"><span data-stu-id="eef27-249">C# reference</span></span>](../index.md)
- [<span data-ttu-id="eef27-250">Рекомендации по проектированию — выбор между классом и структурой</span><span class="sxs-lookup"><span data-stu-id="eef27-250">Design guidelines - Choosing between class and struct</span></span>](../../../standard/design-guidelines/choosing-between-class-and-struct.md)
- [<span data-ttu-id="eef27-251">Рекомендации по проектированию — проектирование структуры</span><span class="sxs-lookup"><span data-stu-id="eef27-251">Design guidelines - Struct design</span></span>](../../../standard/design-guidelines/struct.md)
- [<span data-ttu-id="eef27-252">Классы и структуры</span><span class="sxs-lookup"><span data-stu-id="eef27-252">Classes and structs</span></span>](../../programming-guide/classes-and-structs/index.md)
- [<span data-ttu-id="eef27-253">Выражение `with`</span><span class="sxs-lookup"><span data-stu-id="eef27-253">`with` expression</span></span>](../operators/with-expression.md)
