---
title: Небезопасный код, указатели на данные и указатели функций
description: Сведения о небезопасном коде, указателях на данные и указателях функций. В C# необходимо объявить ненадежный контекст, чтобы можно было использовать функции языка для прямого управления памятью или указателями функций.
ms.date: 04/01/2021
helpviewer_keywords:
- security [C#], type safety
- C# language, unsafe code
- type safety [C#]
- unsafe keyword [C#]
- unsafe code [C#]
- C# language, pointers
- pointers [C#], about pointers
ms.assetid: b0fcca10-a92d-4f2a-835b-b0ccae6739ee
ms.openlocfilehash: 9c55fc48b5805ba38dcf289cb5e03626cf3e96ec
ms.sourcegitcommit: 089068389671f6f9e15fd67dcbfb0145bf72f1fb
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2021
ms.locfileid: "106499091"
---
# <a name="unsafe-code-and-pointer-types"></a><span data-ttu-id="151af-104">Небезопасный код и типы указателей</span><span class="sxs-lookup"><span data-stu-id="151af-104">Unsafe code and pointer types</span></span>

<span data-ttu-id="151af-105">Большая часть создаваемого кода C# — «проверяемо безопасный код».</span><span class="sxs-lookup"><span data-stu-id="151af-105">Most of the C# code you write is "verifiably safe code."</span></span> <span data-ttu-id="151af-106">Термин *«проверяемо безопасный код»* означает, что с помощью средств .NET можно проверить, является ли данный код безопасным.</span><span class="sxs-lookup"><span data-stu-id="151af-106">*Verifiably safe code* means .NET tools can verify that the code is safe.</span></span> <span data-ttu-id="151af-107">Как правило, в безопасном коде не используется прямой доступ к памяти с помощью указателей.</span><span class="sxs-lookup"><span data-stu-id="151af-107">In general, safe code doesn't directly access memory using pointers.</span></span> <span data-ttu-id="151af-108">В нем также не используется выделение блоков памяти в «сыром» виде.</span><span class="sxs-lookup"><span data-stu-id="151af-108">It also doesn't allocate raw memory.</span></span> <span data-ttu-id="151af-109">Вместо этого в нем создаются управляемые объекты.</span><span class="sxs-lookup"><span data-stu-id="151af-109">It creates managed objects instead.</span></span>

<span data-ttu-id="151af-110">C# поддерживает контекст [`unsafe`](keywords/unsafe.md), в котором можно писать *непроверяемый* код.</span><span class="sxs-lookup"><span data-stu-id="151af-110">C# supports an [`unsafe`](keywords/unsafe.md) context, in which you may write *unverifiable* code.</span></span> <span data-ttu-id="151af-111">В контексте `unsafe` в коде можно использовать указатели, выделять и освобождать блоки памяти, а также обращаться к методам с помощью указателей функций.</span><span class="sxs-lookup"><span data-stu-id="151af-111">In an `unsafe` context, code may use pointers, allocate and free blocks of memory, and call methods using function pointers.</span></span> <span data-ttu-id="151af-112">Небезопасный код в C# не обязательно является опасным, просто его безопасность нельзя проверить.</span><span class="sxs-lookup"><span data-stu-id="151af-112">Unsafe code in C# isn't necessarily dangerous; it's just code whose safety cannot be verified.</span></span>

<span data-ttu-id="151af-113">Небезопасный код имеет следующие свойства:</span><span class="sxs-lookup"><span data-stu-id="151af-113">Unsafe code has the following properties:</span></span>

- <span data-ttu-id="151af-114">Методы, типы и блоки кода можно определить как небезопасные.</span><span class="sxs-lookup"><span data-stu-id="151af-114">Methods, types, and code blocks can be defined as unsafe.</span></span>
- <span data-ttu-id="151af-115">В некоторых случаях небезопасный код может увеличить скорость работы приложения, если не проверяются границы массивов.</span><span class="sxs-lookup"><span data-stu-id="151af-115">In some cases, unsafe code may increase an application's performance by removing array bounds checks.</span></span>
- <span data-ttu-id="151af-116">Небезопасный код необходим при вызове встроенных стандартных функций, требующих указателей.</span><span class="sxs-lookup"><span data-stu-id="151af-116">Unsafe code is required when you call native functions that require pointers.</span></span>
- <span data-ttu-id="151af-117">Использование небезопасного кода создает риски для стабильности и безопасности.</span><span class="sxs-lookup"><span data-stu-id="151af-117">Using unsafe code introduces security and stability risks.</span></span>
- <span data-ttu-id="151af-118">Код, содержащий небезопасные блоки, должен компилироваться с параметром компилятора [**AllowUnsafeBlocks**](compiler-options/language.md#allowunsafeblocks).</span><span class="sxs-lookup"><span data-stu-id="151af-118">The code that contains unsafe blocks must be compiled with the [**AllowUnsafeBlocks**](compiler-options/language.md#allowunsafeblocks) compiler option.</span></span>

## <a name="pointer-types"></a><span data-ttu-id="151af-119">типы указателей</span><span class="sxs-lookup"><span data-stu-id="151af-119">Pointer types</span></span>

<span data-ttu-id="151af-120">В небезопасном контексте тип может быть не только типом значения или ссылочным типом, но и типом указателя.</span><span class="sxs-lookup"><span data-stu-id="151af-120">In an unsafe context, a type may be a pointer type, in addition to a value type, or a reference type.</span></span> <span data-ttu-id="151af-121">Объявления типа указателя выполняется одним из следующих способов:</span><span class="sxs-lookup"><span data-stu-id="151af-121">A pointer type declaration takes one of the following forms:</span></span>

``` csharp
type* identifier;
void* identifier; //allowed but not recommended
```

<span data-ttu-id="151af-122">Тип, указанный до `*` в типе указателя, называется **ссылочным типом**.</span><span class="sxs-lookup"><span data-stu-id="151af-122">The type specified before the `*` in a pointer type is called the **referent type**.</span></span> <span data-ttu-id="151af-123">Ссылочным типом может быть только [неуправляемый тип](builtin-types/unmanaged-types.md).</span><span class="sxs-lookup"><span data-stu-id="151af-123">Only an [unmanaged type](builtin-types/unmanaged-types.md) can be a referent type.</span></span>

<span data-ttu-id="151af-124">Типы указателей не наследуются от [объекта](builtin-types/reference-types.md), а типы указателей не преобразуются в `object`.</span><span class="sxs-lookup"><span data-stu-id="151af-124">Pointer types don't inherit from [object](builtin-types/reference-types.md) and no conversions exist between pointer types and `object`.</span></span> <span data-ttu-id="151af-125">Кроме того, упаковка-преобразование и распаковка-преобразование не поддерживают указатели.</span><span class="sxs-lookup"><span data-stu-id="151af-125">Also, boxing and unboxing don't support pointers.</span></span> <span data-ttu-id="151af-126">Однако можно выполнять преобразования между различными типами указателей, а также между типами указателей и целочисленными типами.</span><span class="sxs-lookup"><span data-stu-id="151af-126">However, you can convert between different pointer types and between pointer types and integral types.</span></span>

<span data-ttu-id="151af-127">При объявлении нескольких указателей в одном объявлении знак (`*`) указывается только с базовым типом.</span><span class="sxs-lookup"><span data-stu-id="151af-127">When you declare multiple pointers in the same declaration, you write the asterisk (`*`) together with the underlying type only.</span></span> <span data-ttu-id="151af-128">Он не используется в качестве префикса для каждого имени указателя.</span><span class="sxs-lookup"><span data-stu-id="151af-128">It isn't used as a prefix to each pointer name.</span></span> <span data-ttu-id="151af-129">Пример:</span><span class="sxs-lookup"><span data-stu-id="151af-129">For example:</span></span>

```csharp
int* p1, p2, p3;   // Ok
int *p1, *p2, *p3;   // Invalid in C#
```

<span data-ttu-id="151af-130">Указатель не может указывать на ссылку или на [структуру](builtin-types/struct.md), содержащую ссылки, поскольку ссылка на объект может быть подвергнута сбору мусора, даже если на нее указывает указатель.</span><span class="sxs-lookup"><span data-stu-id="151af-130">A pointer can't point to a reference or to a [struct](builtin-types/struct.md) that contains references, because an object reference can be garbage collected even if a pointer is pointing to it.</span></span> <span data-ttu-id="151af-131">Сборщик мусора не отслеживает наличие указателей любых типов, указывающих на объекты.</span><span class="sxs-lookup"><span data-stu-id="151af-131">The garbage collector doesn't keep track of whether an object is being pointed to by any pointer types.</span></span>

<span data-ttu-id="151af-132">Значением переменной-указателя типа `MyType*` является адрес переменной типа `MyType`.</span><span class="sxs-lookup"><span data-stu-id="151af-132">The value of the pointer variable of type `MyType*` is the address of a variable of type `MyType`.</span></span> <span data-ttu-id="151af-133">Ниже приведены примеры объявлений типов указателей.</span><span class="sxs-lookup"><span data-stu-id="151af-133">The following are examples of pointer type declarations:</span></span>

- <span data-ttu-id="151af-134">`int* p`: `p` — указатель на целое число.</span><span class="sxs-lookup"><span data-stu-id="151af-134">`int* p`: `p` is a pointer to an integer.</span></span>
- <span data-ttu-id="151af-135">`int** p`: `p` — указатель на указатель на целое число.</span><span class="sxs-lookup"><span data-stu-id="151af-135">`int** p`: `p` is a pointer to a pointer to an integer.</span></span>
- <span data-ttu-id="151af-136">`int*[] p`: `p` — одномерный массив указателей на целые числа.</span><span class="sxs-lookup"><span data-stu-id="151af-136">`int*[] p`: `p` is a single-dimensional array of pointers to integers.</span></span>
- <span data-ttu-id="151af-137">`char* p`: `p` — указатель на тип char.</span><span class="sxs-lookup"><span data-stu-id="151af-137">`char* p`: `p` is a pointer to a char.</span></span>
- <span data-ttu-id="151af-138">`void* p`: `p` — указатель на неизвестный тип.</span><span class="sxs-lookup"><span data-stu-id="151af-138">`void* p`: `p` is a pointer to an unknown type.</span></span>

<span data-ttu-id="151af-139">Оператор косвенного обращения указателя `*` можно использовать для доступа к содержимому, на которое указывает переменная-указатель.</span><span class="sxs-lookup"><span data-stu-id="151af-139">The pointer indirection operator `*` can be used to access the contents at the location pointed to by the pointer variable.</span></span> <span data-ttu-id="151af-140">В качестве примера рассмотрим следующее объявление:</span><span class="sxs-lookup"><span data-stu-id="151af-140">For example, consider the following declaration:</span></span>

```csharp
int* myVariable;
```

<span data-ttu-id="151af-141">Выражение `*myVariable` обозначает переменную `int`, находящуюся по адресу, содержащемуся в `myVariable`.</span><span class="sxs-lookup"><span data-stu-id="151af-141">The expression `*myVariable` denotes the `int` variable found at the address contained in `myVariable`.</span></span>

<span data-ttu-id="151af-142">Несколько примеров указателей можно найти в статьях, посвященных [оператору](keywords/fixed-statement.md) `fixed`.</span><span class="sxs-lookup"><span data-stu-id="151af-142">There are several examples of pointers in the articles on the [`fixed` statement](keywords/fixed-statement.md).</span></span> <span data-ttu-id="151af-143">В следующем примере используются ключевое слово `unsafe` и оператор `fixed`, а также демонстрируется способ инкрементирования внутреннего указателя.</span><span class="sxs-lookup"><span data-stu-id="151af-143">The following example uses the `unsafe` keyword and the `fixed` statement, and shows how to increment an interior pointer.</span></span>  <span data-ttu-id="151af-144">Этот код можно вставить в функцию Main консольного приложения для его запуска.</span><span class="sxs-lookup"><span data-stu-id="151af-144">You can paste this code into the Main function of a console application to run it.</span></span> <span data-ttu-id="151af-145">Эти примеры должны быть скомпилированы с заданным параметром [**AllowUnsafeBlocks**](compiler-options/language.md#allowunsafeblocks).</span><span class="sxs-lookup"><span data-stu-id="151af-145">These examples must be compiled with the [**AllowUnsafeBlocks**](compiler-options/language.md#allowunsafeblocks) compiler option set.</span></span>

:::code language="csharp" source="snippets/unsafe-code/FixedKeywordExamples.cs" ID="5":::

<span data-ttu-id="151af-146">Для указателя типа `void*` использовать оператор косвенного обращения нельзя.</span><span class="sxs-lookup"><span data-stu-id="151af-146">You can't apply the indirection operator to a pointer of type `void*`.</span></span> <span data-ttu-id="151af-147">Однако можно использовать приведение для преобразования указателя типа void в любой другой тип и наоборот.</span><span class="sxs-lookup"><span data-stu-id="151af-147">However, you can use a cast to convert a void pointer to any other pointer type, and vice versa.</span></span>

<span data-ttu-id="151af-148">Указатель может иметь значение `null`.</span><span class="sxs-lookup"><span data-stu-id="151af-148">A pointer can be `null`.</span></span> <span data-ttu-id="151af-149">При применении оператора косвенного обращения к указателю со значением null результат зависит от конкретной реализации.</span><span class="sxs-lookup"><span data-stu-id="151af-149">Applying the indirection operator to a null pointer causes an implementation-defined behavior.</span></span>

<span data-ttu-id="151af-150">При передаче указателей между методами может возникнуть неопределенное поведение.</span><span class="sxs-lookup"><span data-stu-id="151af-150">Passing pointers between methods can cause undefined behavior.</span></span> <span data-ttu-id="151af-151">Рекомендуется использовать метод, возвращающий указатель в локальную переменную с помощью параметра `in`, `out` или `ref` либо в виде результата функции.</span><span class="sxs-lookup"><span data-stu-id="151af-151">Consider a method that returns a pointer to a local variable through an `in`, `out`, or `ref` parameter or as the function result.</span></span> <span data-ttu-id="151af-152">Если указатель был задан в фиксированном блоке, переменная, на которую он указывает, больше не может быть фиксированной.</span><span class="sxs-lookup"><span data-stu-id="151af-152">If the pointer was set in a fixed block, the variable to which it points may no longer be fixed.</span></span>

<span data-ttu-id="151af-153">В следующей таблице перечислены операторы, которые можно использовать для указателей в небезопасном контексте.</span><span class="sxs-lookup"><span data-stu-id="151af-153">The following table lists the operators and statements that can operate on pointers in an unsafe context:</span></span>

|<span data-ttu-id="151af-154">Оператор</span><span class="sxs-lookup"><span data-stu-id="151af-154">Operator/Statement</span></span>|<span data-ttu-id="151af-155">Использовать</span><span class="sxs-lookup"><span data-stu-id="151af-155">Use</span></span>|
|-------------------------|---------|
|`*`|<span data-ttu-id="151af-156">Косвенное обращение к указателю.</span><span class="sxs-lookup"><span data-stu-id="151af-156">Performs pointer indirection.</span></span>|
|`->`|<span data-ttu-id="151af-157">Доступ к члену структуры через указатель.</span><span class="sxs-lookup"><span data-stu-id="151af-157">Accesses a member of a struct through a pointer.</span></span>|
|`[]`|<span data-ttu-id="151af-158">Индексирование указателя.</span><span class="sxs-lookup"><span data-stu-id="151af-158">Indexes a pointer.</span></span>|
|`&`|<span data-ttu-id="151af-159">Получение адреса переменной.</span><span class="sxs-lookup"><span data-stu-id="151af-159">Obtains the address of a variable.</span></span>|
|<span data-ttu-id="151af-160">`++` и `--`</span><span class="sxs-lookup"><span data-stu-id="151af-160">`++` and `--`</span></span>|<span data-ttu-id="151af-161">Увеличение и уменьшение указателей.</span><span class="sxs-lookup"><span data-stu-id="151af-161">Increments and decrements pointers.</span></span>|
|<span data-ttu-id="151af-162">`+` и `-`</span><span class="sxs-lookup"><span data-stu-id="151af-162">`+` and `-`</span></span>|<span data-ttu-id="151af-163">Арифметические действия с указателем.</span><span class="sxs-lookup"><span data-stu-id="151af-163">Performs pointer arithmetic.</span></span>|
|<span data-ttu-id="151af-164">`==`, `!=`, `<`, `>`, `<=` и `>=`</span><span class="sxs-lookup"><span data-stu-id="151af-164">`==`, `!=`, `<`, `>`, `<=`, and `>=`</span></span>|<span data-ttu-id="151af-165">Сравнение указателей.</span><span class="sxs-lookup"><span data-stu-id="151af-165">Compares pointers.</span></span>|
|[`stackalloc`](operators/stackalloc.md)|<span data-ttu-id="151af-166">Выделение памяти в стеке.</span><span class="sxs-lookup"><span data-stu-id="151af-166">Allocates memory on the stack.</span></span>|
|[<span data-ttu-id="151af-167">Инструкция `fixed`</span><span class="sxs-lookup"><span data-stu-id="151af-167">`fixed` statement</span></span>](keywords/fixed-statement.md)|<span data-ttu-id="151af-168">Временная фиксация переменной, чтобы можно было найти ее адрес.</span><span class="sxs-lookup"><span data-stu-id="151af-168">Temporarily fixes a variable so that its address may be found.</span></span>|

<span data-ttu-id="151af-169">Дополнительные сведения об операторах, связанных с указателем, см. в разделе [Операторы, связанные с указателем](operators/pointer-related-operators.md).</span><span class="sxs-lookup"><span data-stu-id="151af-169">For more information about pointer-related operators, see [Pointer-related operators](operators/pointer-related-operators.md).</span></span>

<span data-ttu-id="151af-170">Любой тип указателя можно неявно преобразовать в тип `void*`.</span><span class="sxs-lookup"><span data-stu-id="151af-170">Any pointer type can be implicitly converted to a `void*` type.</span></span> <span data-ttu-id="151af-171">Любому типу указателя может быть присвоено значение `null`.</span><span class="sxs-lookup"><span data-stu-id="151af-171">Any pointer type can be assigned the value `null`.</span></span> <span data-ttu-id="151af-172">Любой тип указателя можно явно преобразовать в любой другой тип указателя с помощью выражения приведения.</span><span class="sxs-lookup"><span data-stu-id="151af-172">Any pointer type can be explicitly converted to any other pointer type using a cast expression.</span></span> <span data-ttu-id="151af-173">Можно также преобразовать любой целочисленный тип в тип указателя или преобразовать любой тип указателя в целочисленный тип.</span><span class="sxs-lookup"><span data-stu-id="151af-173">You can also convert any integral type to a pointer type, or any pointer type to an integral type.</span></span> <span data-ttu-id="151af-174">Для этих преобразований требуется явным образом использовать приведение.</span><span class="sxs-lookup"><span data-stu-id="151af-174">These conversions require an explicit cast.</span></span>

<span data-ttu-id="151af-175">Например, в следующем примере тип `int*` преобразуется в тип `byte*`.</span><span class="sxs-lookup"><span data-stu-id="151af-175">The following example converts an `int*` to a `byte*`.</span></span> <span data-ttu-id="151af-176">Обратите внимание, что указатель указывает на наименьший адресуемый байт переменной.</span><span class="sxs-lookup"><span data-stu-id="151af-176">Notice that the pointer points to the lowest addressed byte of the variable.</span></span> <span data-ttu-id="151af-177">При последовательном увеличении результата до размера `int` (4 байта) можно отобразить оставшиеся байты переменной.</span><span class="sxs-lookup"><span data-stu-id="151af-177">When you successively increment the result, up to the size of `int` (4 bytes), you can display the remaining bytes of the variable.</span></span>

:::code language="csharp" source="snippets/unsafe-code/Conversions.cs" ID="Conversion":::

## <a name="fixed-size-buffers"></a><span data-ttu-id="151af-178">Буферы фиксированного размера</span><span class="sxs-lookup"><span data-stu-id="151af-178">Fixed-size buffers</span></span>

<span data-ttu-id="151af-179">В языке C# для создания буфера с массивом фиксированного размера в структуре данных можно использовать оператор [fixed](keywords/fixed-statement.md).</span><span class="sxs-lookup"><span data-stu-id="151af-179">In C#, you can use the [fixed](keywords/fixed-statement.md) statement to create a buffer with a fixed size array in a data structure.</span></span> <span data-ttu-id="151af-180">Буферы фиксированного размера полезны при написании методов, взаимодействующих с источниками данных, созданными на других языках или платформах.</span><span class="sxs-lookup"><span data-stu-id="151af-180">Fixed size buffers are useful when you write methods that interoperate with data sources from other languages or platforms.</span></span> <span data-ttu-id="151af-181">Фиксированный массив может принимать любые атрибуты или модификаторы, допустимые для обычных членов структуры.</span><span class="sxs-lookup"><span data-stu-id="151af-181">The fixed array can take any attributes or modifiers that are allowed for regular struct members.</span></span> <span data-ttu-id="151af-182">Единственным ограничением является то, что массив должен иметь тип `bool`, `byte`, `char`, `short`, `int`, `long`, `sbyte`, `ushort`, `uint`, `ulong`, `float` или `double`.</span><span class="sxs-lookup"><span data-stu-id="151af-182">The only restriction is that the array type must be `bool`, `byte`, `char`, `short`, `int`, `long`, `sbyte`, `ushort`, `uint`, `ulong`, `float`, or `double`.</span></span>

```csharp
private fixed char name[30];
```

<span data-ttu-id="151af-183">В безопасном коде структура C#, содержащая массив, не содержит элементы массива.</span><span class="sxs-lookup"><span data-stu-id="151af-183">In safe code, a C# struct that contains an array doesn't contain the array elements.</span></span> <span data-ttu-id="151af-184">Вместо этого в ней присутствуют ссылки на элементы.</span><span class="sxs-lookup"><span data-stu-id="151af-184">The struct contains a reference to the elements instead.</span></span> <span data-ttu-id="151af-185">Вы можете внедрить массив фиксированного размера в [структуру](builtin-types/struct.md), если он используется в блоке [небезопасного](keywords/unsafe.md) кода.</span><span class="sxs-lookup"><span data-stu-id="151af-185">You can embed an array of fixed size in a [struct](builtin-types/struct.md) when it's used in an [unsafe](keywords/unsafe.md) code block.</span></span>

<span data-ttu-id="151af-186">Размер следующего объекта `struct` не зависит от количества элементов в массиве, поскольку `pathName` представляет собой ссылку:</span><span class="sxs-lookup"><span data-stu-id="151af-186">The size of the following `struct` doesn't depend on the number of elements in the array, since `pathName` is a reference:</span></span>

:::code language="csharp" source="snippets/unsafe-code/FixedKeywordExamples.cs" ID="6":::

<span data-ttu-id="151af-187">`struct` может содержать внедренный массив в небезопасном коде.</span><span class="sxs-lookup"><span data-stu-id="151af-187">A `struct` can contain an embedded array in unsafe code.</span></span> <span data-ttu-id="151af-188">В приведенном ниже примере массив `fixedBuffer` имеет фиксированный размер.</span><span class="sxs-lookup"><span data-stu-id="151af-188">In the following example, the `fixedBuffer` array has a fixed size.</span></span> <span data-ttu-id="151af-189">Для установки указателя на первый элемент используется оператор `fixed`.</span><span class="sxs-lookup"><span data-stu-id="151af-189">You use a `fixed` statement to establish a pointer to the first element.</span></span> <span data-ttu-id="151af-190">С помощью этого указателя осуществляется доступ к элементам массива.</span><span class="sxs-lookup"><span data-stu-id="151af-190">You access the elements of the array through this pointer.</span></span> <span data-ttu-id="151af-191">Оператор `fixed` закрепляет поле экземпляра `fixedBuffer` в определенном месте в памяти.</span><span class="sxs-lookup"><span data-stu-id="151af-191">The `fixed` statement pins the `fixedBuffer` instance field to a specific location in memory.</span></span>

:::code language="csharp" source="snippets/unsafe-code/FixedKeywordExamples.cs" ID="7":::

<span data-ttu-id="151af-192">Размер массива из 128 элементов `char` составляет 256 байт.</span><span class="sxs-lookup"><span data-stu-id="151af-192">The size of the 128 element `char` array is 256 bytes.</span></span> <span data-ttu-id="151af-193">В буферах типа [char](builtin-types/char.md) фиксированного размера на один символ всегда приходится по 2 байта независимо от кодировки.</span><span class="sxs-lookup"><span data-stu-id="151af-193">Fixed size [char](builtin-types/char.md) buffers always take 2 bytes per character, regardless of the encoding.</span></span> <span data-ttu-id="151af-194">Этот размер массива сохраняется даже в том случае, когда буферы char маршалируются в методы API или структуры с `CharSet = CharSet.Auto` или `CharSet = CharSet.Ansi`.</span><span class="sxs-lookup"><span data-stu-id="151af-194">This array size is the same even when char buffers are marshaled to API methods or structs with `CharSet = CharSet.Auto` or `CharSet = CharSet.Ansi`.</span></span> <span data-ttu-id="151af-195">Для получения дополнительной информации см. <xref:System.Runtime.InteropServices.CharSet>.</span><span class="sxs-lookup"><span data-stu-id="151af-195">For more information, see <xref:System.Runtime.InteropServices.CharSet>.</span></span>

<span data-ttu-id="151af-196">В предыдущем примере демонстрировался доступ к полям `fixed` без закрепления в памяти, доступный в C#, начиная с версии 7.3.</span><span class="sxs-lookup"><span data-stu-id="151af-196">The  preceding example demonstrates accessing `fixed` fields without pinning, which is available starting with C# 7.3.</span></span>

<span data-ttu-id="151af-197">Еще одним распространенным массивом фиксированного размера является массив [bool](builtin-types/bool.md).</span><span class="sxs-lookup"><span data-stu-id="151af-197">Another common fixed-size array is the [bool](builtin-types/bool.md) array.</span></span> <span data-ttu-id="151af-198">Элементы в массиве `bool` всегда имеют размер в 1 байт.</span><span class="sxs-lookup"><span data-stu-id="151af-198">The elements in a `bool` array are always 1 byte in size.</span></span> <span data-ttu-id="151af-199">Массивы `bool` не подходят для создания битовых массивов или буферов.</span><span class="sxs-lookup"><span data-stu-id="151af-199">`bool` arrays aren't appropriate for creating bit arrays or buffers.</span></span>

<span data-ttu-id="151af-200">Буферы фиксированного размера компилируются с помощью класса <xref:System.Runtime.CompilerServices.UnsafeValueTypeAttribute?displayProperty=nameWithType>, что указывает среде CLR, что тип содержит неуправляемый массив, который может привести к переполнению.</span><span class="sxs-lookup"><span data-stu-id="151af-200">Fixed size buffers are compiled with the <xref:System.Runtime.CompilerServices.UnsafeValueTypeAttribute?displayProperty=nameWithType>, which instructs the common language runtime (CLR) that a type contains an unmanaged array that can potentially overflow.</span></span> <span data-ttu-id="151af-201">Кроме того, в среде CLR для памяти, выделенной с помощью функции [stackalloc](operators/stackalloc.md), автоматически включаются функции обнаружения переполнения буфера.</span><span class="sxs-lookup"><span data-stu-id="151af-201">Memory allocated using [stackalloc](operators/stackalloc.md) also automatically enables buffer overrun detection features in the CLR.</span></span> <span data-ttu-id="151af-202">В предыдущем примере показано существование буфера фиксированного размера в `unsafe struct`.</span><span class="sxs-lookup"><span data-stu-id="151af-202">The previous example shows how a fixed size buffer could exist in an `unsafe struct`.</span></span>

```csharp
internal unsafe struct Buffer
{
    public fixed char fixedBuffer[128];
}
```

<span data-ttu-id="151af-203">Созданный компилятором код C# для `Buffer` помечен с помощью атрибутов, как показано далее.</span><span class="sxs-lookup"><span data-stu-id="151af-203">The compiler-generated C# for `Buffer` is attributed as follows:</span></span>

```csharp
internal struct Buffer
{
    [StructLayout(LayoutKind.Sequential, Size = 256)]
    [CompilerGenerated]
    [UnsafeValueType]
    public struct <fixedBuffer>e__FixedBuffer
    {
        public char FixedElementField;
    }

    [FixedBuffer(typeof(char), 128)]
    public <fixedBuffer>e__FixedBuffer fixedBuffer;
}
```

<span data-ttu-id="151af-204">Буферы фиксированного размера отличаются от обычных массивов указанными ниже особенностями.</span><span class="sxs-lookup"><span data-stu-id="151af-204">Fixed size buffers differ from regular arrays in the following ways:</span></span>

- <span data-ttu-id="151af-205">Могут использоваться только в `unsafe` контексте.</span><span class="sxs-lookup"><span data-stu-id="151af-205">May only be used in an `unsafe` context.</span></span>
- <span data-ttu-id="151af-206">Могут быть только полями экземпляров структур.</span><span class="sxs-lookup"><span data-stu-id="151af-206">May only be instance fields of structs.</span></span>
- <span data-ttu-id="151af-207">Всегда являются векторами или одномерными массивами.</span><span class="sxs-lookup"><span data-stu-id="151af-207">They're always vectors, or one-dimensional arrays.</span></span>
- <span data-ttu-id="151af-208">Объявление должно включать длину, например `fixed char id[8]`.</span><span class="sxs-lookup"><span data-stu-id="151af-208">The declaration should include the length, such as `fixed char id[8]`.</span></span> <span data-ttu-id="151af-209">Вы не можете использовать `fixed char id[]`.</span><span class="sxs-lookup"><span data-stu-id="151af-209">You can't use `fixed char id[]`.</span></span>

## <a name="how-to-use-pointers-to-copy-an-array-of-bytes"></a><span data-ttu-id="151af-210">Практическое руководство. Использование указателей для копирования массива байтов</span><span class="sxs-lookup"><span data-stu-id="151af-210">How to use pointers to copy an array of bytes</span></span>

<span data-ttu-id="151af-211">В следующем примере указатели используются для копирования байт из одного массива в другой.</span><span class="sxs-lookup"><span data-stu-id="151af-211">The following example uses pointers to copy bytes from one array to another.</span></span>

<span data-ttu-id="151af-212">В этом примере применяется ключевое слово [unsafe](keywords/unsafe.md), которое позволяет использовать указатели в методе `Copy`.</span><span class="sxs-lookup"><span data-stu-id="151af-212">This example uses the [unsafe](keywords/unsafe.md) keyword, which enables you to use pointers in the `Copy` method.</span></span> <span data-ttu-id="151af-213">Оператор [fixed](keywords/fixed-statement.md) используется для объявления указателей исходного и конечного массивов.</span><span class="sxs-lookup"><span data-stu-id="151af-213">The [fixed](keywords/fixed-statement.md) statement is used to declare pointers to the source and destination arrays.</span></span> <span data-ttu-id="151af-214">Оператор `fixed`*закрепляет* расположение исходного и конечного массивов в памяти, чтобы они не перемещались при сборке мусора.</span><span class="sxs-lookup"><span data-stu-id="151af-214">The `fixed` statement *pins* the location of the source and destination arrays in memory so that they will not be moved by garbage collection.</span></span> <span data-ttu-id="151af-215">Закрепление этих блоков памяти отменяется, когда завершается обработка блока `fixed`.</span><span class="sxs-lookup"><span data-stu-id="151af-215">The memory blocks for the arrays are unpinned when the `fixed` block is completed.</span></span> <span data-ttu-id="151af-216">Поскольку метод `Copy` в этом примере использует ключевое слово `unsafe`, он должен быть скомпилирован с параметром компилятора [**AllowUnsafeBlocks**](compiler-options/language.md#allowunsafeblocks).</span><span class="sxs-lookup"><span data-stu-id="151af-216">Because the `Copy` method in this example uses the `unsafe` keyword, it must be compiled with the [**AllowUnsafeBlocks**](compiler-options/language.md#allowunsafeblocks) compiler option.</span></span>

<span data-ttu-id="151af-217">В этом примере доступ к элементам обоих массивов выполняется с помощью индексов, а не второго неуправляемого указателя.</span><span class="sxs-lookup"><span data-stu-id="151af-217">This example accesses the elements of both arrays using indices rather than a second unmanaged pointer.</span></span> <span data-ttu-id="151af-218">Объявление указателей `pSource` и `pTarget` закрепляет массивы.</span><span class="sxs-lookup"><span data-stu-id="151af-218">The declaration of the `pSource` and `pTarget` pointers pins the arrays.</span></span> <span data-ttu-id="151af-219">Эта возможность доступна начиная с C# 7.3.</span><span class="sxs-lookup"><span data-stu-id="151af-219">This feature is available starting with C# 7.3.</span></span>

:::code language="csharp" source="snippets/unsafe-code/FixedKeywordExamples.cs" ID="8":::

## <a name="function-pointers"></a><span data-ttu-id="151af-220">Указатели функций</span><span class="sxs-lookup"><span data-stu-id="151af-220">Function pointers</span></span>

<span data-ttu-id="151af-221">В C# имеются типы [`delegate`](builtin-types/reference-types.md#the-delegate-type), позволяющие определить безопасные объекты указателя функции.</span><span class="sxs-lookup"><span data-stu-id="151af-221">C# provides [`delegate`](builtin-types/reference-types.md#the-delegate-type) types to define safe function pointer objects.</span></span> <span data-ttu-id="151af-222">При вызове делегата создается экземпляр типа, производного от <xref:System.Delegate?displayProperty=nameWithType>, и вызывается его виртуальный метод `Invoke`.</span><span class="sxs-lookup"><span data-stu-id="151af-222">Invoking a delegate involves instantiating a type derived from <xref:System.Delegate?displayProperty=nameWithType> and making a virtual method call to its `Invoke` method.</span></span> <span data-ttu-id="151af-223">В этом виртуальном вызове используется инструкция IL `callvirt`.</span><span class="sxs-lookup"><span data-stu-id="151af-223">This virtual call uses the `callvirt` IL instruction.</span></span> <span data-ttu-id="151af-224">В критически важных с точки зрения производительности путях к коду использование инструкции IL `calli` является более эффективным.</span><span class="sxs-lookup"><span data-stu-id="151af-224">In performance critical code paths, using the `calli` IL instruction is more efficient.</span></span>

<span data-ttu-id="151af-225">Указатель функции можно определить, используя синтаксический элемент `delegate*`.</span><span class="sxs-lookup"><span data-stu-id="151af-225">You can define a function pointer using the `delegate*` syntax.</span></span> <span data-ttu-id="151af-226">Вместо того, чтобы создавать экземпляр объекта `delegate` и вызывать метод `Invoke`, компилятор вызывает такую функцию, используя инструкцию `calli`.</span><span class="sxs-lookup"><span data-stu-id="151af-226">The compiler will call the function using the `calli` instruction rather than instantiating a `delegate` object and calling `Invoke`.</span></span> <span data-ttu-id="151af-227">В следующем коде объявляются два метода, которые используют `delegate` или `delegate*` для объединения двух объектов одного типа.</span><span class="sxs-lookup"><span data-stu-id="151af-227">The following code declares two methods that use a `delegate` or a `delegate*` to combine two objects of the same type.</span></span> <span data-ttu-id="151af-228">В первом методе используется тип делегата <xref:System.Func%603?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="151af-228">The first method uses a <xref:System.Func%603?displayProperty=nameWithType> delegate type.</span></span> <span data-ttu-id="151af-229">Во втором методе используется объявление `delegate*` с теми же параметрами и типом возвращаемого значения:</span><span class="sxs-lookup"><span data-stu-id="151af-229">The second method uses a `delegate*` declaration with the same parameters and return type:</span></span>

:::code language="csharp" source="snippets/unsafe-code/FunctionPointers.cs" ID="UseDelegateOrPointer":::

<span data-ttu-id="151af-230">В следующем коде показано, как объявить статическую локальную функцию и вызвать метод `UnsafeCombine`, используя указатель на эту локальную функцию:</span><span class="sxs-lookup"><span data-stu-id="151af-230">The following code shows how you would declare a static local function and invoke the `UnsafeCombine` method using a pointer to that local function:</span></span>

:::code language="csharp" source="snippets/unsafe-code/FunctionPointers.cs" ID="InvokeViaFunctionPointer":::

<span data-ttu-id="151af-231">В приведенном выше коде иллюстрируется ряд правил работы с функциями, доступ к которым осуществляется по указателю:</span><span class="sxs-lookup"><span data-stu-id="151af-231">The preceding code illustrates several of the rules on the function accessed as a function pointer:</span></span>

- <span data-ttu-id="151af-232">Указатели функций могут быть объявлены только в контексте `unsafe`.</span><span class="sxs-lookup"><span data-stu-id="151af-232">Function pointers can only be declared in an `unsafe` context.</span></span>
- <span data-ttu-id="151af-233">Методы, принимающие в качестве параметра значение типа `delegate*` (или возвращающие значение типа `delegate*`), могут вызываться только в контексте `unsafe`.</span><span class="sxs-lookup"><span data-stu-id="151af-233">Methods that take a `delegate*` (or return a `delegate*`) can only be called in an `unsafe` context.</span></span>
- <span data-ttu-id="151af-234">Оператор `&` для получения адреса функции допускается только для функций `static`.</span><span class="sxs-lookup"><span data-stu-id="151af-234">The `&` operator to obtain the address of a function is allowed only on `static` functions.</span></span> <span data-ttu-id="151af-235">(Это правило применяется как к функциям-членам, так и к локальным функциям).</span><span class="sxs-lookup"><span data-stu-id="151af-235">(This rule applies to both member functions and local functions).</span></span>

<span data-ttu-id="151af-236">Синтаксис имеет сходства с объявлением типов `delegate` и использованием указателей.</span><span class="sxs-lookup"><span data-stu-id="151af-236">The syntax has parallels with declaring `delegate` types and using pointers.</span></span> <span data-ttu-id="151af-237">Суффикс `*` в служебном слове `delegate` указывает на то, что данное объявление является *указателем функции*.</span><span class="sxs-lookup"><span data-stu-id="151af-237">The `*` suffix on `delegate` indicates the declaration is a *function pointer*.</span></span> <span data-ttu-id="151af-238">Знак `&` при назначении группы методов указателю функции указывает, что операция использует адрес метода.</span><span class="sxs-lookup"><span data-stu-id="151af-238">The `&` when assigning a method group to a function pointer indicates the operation takes the address of the method.</span></span>

<span data-ttu-id="151af-239">Для `delegate*` можно указать соглашение о вызовах, используя ключевые слова `managed` и `unmanaged`.</span><span class="sxs-lookup"><span data-stu-id="151af-239">You can specify the calling convention for a `delegate*` using the keywords `managed` and `unmanaged`.</span></span> <span data-ttu-id="151af-240">Кроме того, соглашение о вызовах можно указать для указателей на функции `unmanaged`.</span><span class="sxs-lookup"><span data-stu-id="151af-240">In addition, for `unmanaged` function pointers, you can specify the calling convention.</span></span> <span data-ttu-id="151af-241">Примеры для всех этих случаев можно увидеть в объявлениях ниже.</span><span class="sxs-lookup"><span data-stu-id="151af-241">The following declarations show examples of each.</span></span> <span data-ttu-id="151af-242">В первом объявлении используется соглашение о вызовах `managed`, которое используется по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="151af-242">The first declaration uses the `managed` calling convention, which is the default.</span></span> <span data-ttu-id="151af-243">В следующих трех используется соглашение о вызовах `unmanaged`.</span><span class="sxs-lookup"><span data-stu-id="151af-243">The next three use an `unmanaged` calling convention.</span></span> <span data-ttu-id="151af-244">В каждом из них указано одно из соглашений о вызовах из стандарта ECMA 335: `Cdecl`, `Stdcall`, `Fastcall` или `Thiscall`.</span><span class="sxs-lookup"><span data-stu-id="151af-244">Each specifies one of the ECMA 335 calling conventions: `Cdecl`, `Stdcall`, `Fastcall`, or `Thiscall`.</span></span> <span data-ttu-id="151af-245">В последнем объявлении используется соглашение о вызовах `unmanaged`, что дает возможность среде CLR выбрать используемое по умолчанию соглашение о вызовах для данной платформы.</span><span class="sxs-lookup"><span data-stu-id="151af-245">The last declarations uses the `unmanaged` calling convention, instructing the CLR to pick the default calling convention for the platform.</span></span> <span data-ttu-id="151af-246">Среда CLR выберет соглашение о вызовах во время выполнения кода.</span><span class="sxs-lookup"><span data-stu-id="151af-246">The CLR will choose the calling convention at run time.</span></span>

:::code language="csharp" source="snippets/unsafe-code/FunctionPointers.cs" ID="UnmanagedFunctionPointers":::

<span data-ttu-id="151af-247">Дополнительные сведения об указателях функций см. в предложении [Указатель функции](~/_csharplang/proposals/csharp-9.0/function-pointers.md) для C# 9.0.</span><span class="sxs-lookup"><span data-stu-id="151af-247">You can learn more about function pointers in the [Function pointer](~/_csharplang/proposals/csharp-9.0/function-pointers.md) proposal for C# 9.0.</span></span>

## <a name="c-language-specification"></a><span data-ttu-id="151af-248">Спецификация языка C#</span><span class="sxs-lookup"><span data-stu-id="151af-248">C# language specification</span></span>

<span data-ttu-id="151af-249">Дополнительные сведения см. в разделе [Небезопасный код](~/_csharplang/spec/unsafe-code.md) [спецификации языка C#](~/_csharplang/spec/introduction.md).</span><span class="sxs-lookup"><span data-stu-id="151af-249">For more information, see the [Unsafe code](~/_csharplang/spec/unsafe-code.md) chapter of the [C# language specification](~/_csharplang/spec/introduction.md).</span></span>
