---
description: Справочник по C#. Предложение where (ограничение универсального типа)
title: Справочник по C#. Предложение where (ограничение универсального типа)
ms.date: 04/15/2020
f1_keywords:
- whereconstraint
- whereconstraint_CSharpKeyword
- classconstraint_CSharpKeyword
- structconstraint_CSharpKeyword
- enumconstraint_CSharpKeyword
helpviewer_keywords:
- where (generic type constraint) [C#]
ms.openlocfilehash: 83fb5b562d9e1e4caaef179ca2911adb60fc01fa
ms.sourcegitcommit: c7f0beaa2bd66ebca86362ca17d673f7e8256ca6
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/23/2021
ms.locfileid: "104872630"
---
# <a name="where-generic-type-constraint-c-reference"></a><span data-ttu-id="5e637-103">where (ограничение универсального типа) (справочник по C#)</span><span class="sxs-lookup"><span data-stu-id="5e637-103">where (generic type constraint) (C# Reference)</span></span>

<span data-ttu-id="5e637-104">Предложение `where` в универсальном определении задает ограничения на типы, которые используются в качестве аргументов для параметров типа в универсальном типе, методе, делегате или локальной функции.</span><span class="sxs-lookup"><span data-stu-id="5e637-104">The `where` clause in a generic definition specifies constraints on the types that are used as arguments for type parameters in a generic type, method, delegate, or local function.</span></span> <span data-ttu-id="5e637-105">Ограничения могут задавать интерфейсы, базовые классы или требовать, чтобы универсальный тип был ссылочным типом, типом значения или неуправляемым типом.</span><span class="sxs-lookup"><span data-stu-id="5e637-105">Constraints can specify interfaces, base classes, or require a generic type to be a reference, value, or unmanaged type.</span></span> <span data-ttu-id="5e637-106">Они объявляют характеристики, которыми должен обладать аргумент типа.</span><span class="sxs-lookup"><span data-stu-id="5e637-106">They declare capabilities that the type argument must have.</span></span>

<span data-ttu-id="5e637-107">Например, можно объявить универсальный класс `AGenericClass` так, чтобы параметр типа `T` реализовывал интерфейс <xref:System.IComparable%601>:</span><span class="sxs-lookup"><span data-stu-id="5e637-107">For example, you can declare a generic class, `AGenericClass`, such that the type parameter `T` implements the <xref:System.IComparable%601> interface:</span></span>

[!code-csharp[using an interface constraint](snippets/GenericWhereConstraints.cs#1)]

> [!NOTE]
> <span data-ttu-id="5e637-108">Дополнительные сведения о предложении where в выражении запроса см. в разделе [Предложение where](where-clause.md).</span><span class="sxs-lookup"><span data-stu-id="5e637-108">For more information on the where clause in a query expression, see [where clause](where-clause.md).</span></span>

<span data-ttu-id="5e637-109">Предложение `where` также может включать ограничение базового класса.</span><span class="sxs-lookup"><span data-stu-id="5e637-109">The `where` clause can also include a base class constraint.</span></span> <span data-ttu-id="5e637-110">Ограничение базового класса указывает, что тип, который должен использоваться как аргумент типа для этого универсального типа, имеет заданный класс в качестве базового класса или является этим базовым классом.</span><span class="sxs-lookup"><span data-stu-id="5e637-110">The base class constraint states that a type to be used as a type argument for that generic type has the specified class as a base class, or is that base class.</span></span> <span data-ttu-id="5e637-111">Если ограничение базового класса используется, оно должно быть указано перед любыми другими ограничениями данного параметра типа.</span><span class="sxs-lookup"><span data-stu-id="5e637-111">If the base class constraint is used, it must appear before any other constraints on that type parameter.</span></span> <span data-ttu-id="5e637-112">Некоторые типы не могут использоваться как ограничение базового класса: <xref:System.Object>, <xref:System.Array> и <xref:System.ValueType>.</span><span class="sxs-lookup"><span data-stu-id="5e637-112">Some types are disallowed as a base class constraint: <xref:System.Object>, <xref:System.Array>, and <xref:System.ValueType>.</span></span> <span data-ttu-id="5e637-113">До C# 7.3 <xref:System.Enum>, <xref:System.Delegate> и <xref:System.MulticastDelegate> также не могли использоваться в качестве ограничений базового класса.</span><span class="sxs-lookup"><span data-stu-id="5e637-113">Before C# 7.3, <xref:System.Enum>, <xref:System.Delegate>, and <xref:System.MulticastDelegate> were also disallowed as base class constraints.</span></span> <span data-ttu-id="5e637-114">Ниже приведен пример типов, которые теперь можно указать как базовый класс:</span><span class="sxs-lookup"><span data-stu-id="5e637-114">The following example shows the types that can now be specified as a base class:</span></span>

[!code-csharp[using an interface constraint](snippets/GenericWhereConstraints.cs#2)]

<span data-ttu-id="5e637-115">В контексте, допускающем значения NULL, в C# 8.0 и более поздних версиях принудительно применяется допустимость значений NULL для типа базового класса.</span><span class="sxs-lookup"><span data-stu-id="5e637-115">In a nullable context in C# 8.0 and later, the nullability of the base class type is enforced.</span></span> <span data-ttu-id="5e637-116">Если базовый класс не допускает значения NULL (например, `Base`), аргумент типа должен иметь значение, отличное от NULL.</span><span class="sxs-lookup"><span data-stu-id="5e637-116">If the base class is non-nullable (for example `Base`), the type argument must be non-nullable.</span></span> <span data-ttu-id="5e637-117">Если базовый класс допускает значения NULL (например, `Base?`), аргумент типа может быть ссылочным типом, допускающим или не допускающим значения NULL.</span><span class="sxs-lookup"><span data-stu-id="5e637-117">If the base class is nullable (for example `Base?`), the type argument may be either a nullable or non-nullable reference type.</span></span> <span data-ttu-id="5e637-118">Компилятор выдает предупреждение, если аргумент типа является ссылочным типом, допускающим значения NULL, когда базовый класс не допускает значения NULL.</span><span class="sxs-lookup"><span data-stu-id="5e637-118">The compiler issues a warning if the type argument is a nullable reference type when the base class is non-nullable.</span></span>

<span data-ttu-id="5e637-119">Предложение `where` может указывать, что тип является `class` или `struct`.</span><span class="sxs-lookup"><span data-stu-id="5e637-119">The `where` clause can specify that the type is a `class` or a `struct`.</span></span> <span data-ttu-id="5e637-120">Ограничение `struct` избавляет от необходимости указывать ограничение базового класса `System.ValueType`.</span><span class="sxs-lookup"><span data-stu-id="5e637-120">The `struct` constraint removes the need to specify a base class constraint of `System.ValueType`.</span></span> <span data-ttu-id="5e637-121">Тип `System.ValueType` не может использоваться как ограничение базового класса.</span><span class="sxs-lookup"><span data-stu-id="5e637-121">The `System.ValueType` type may not be used as a base class constraint.</span></span> <span data-ttu-id="5e637-122">Ограничения `class` и `struct` показаны в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="5e637-122">The following example shows both the `class` and `struct` constraints:</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#3)]

<span data-ttu-id="5e637-123">В контексте, допускающем значения NULL, в C# 8.0 и более поздних версиях для ограничения `class` требуется тип, являющийся ссылочным типом, не допускающим значения NULL.</span><span class="sxs-lookup"><span data-stu-id="5e637-123">In a nullable context in C# 8.0 and later, the `class` constraint requires a type to be a non-nullable reference type.</span></span> <span data-ttu-id="5e637-124">Чтобы разрешить ссылочные типы, допускающие значения NULL, используйте ограничение `class?`, которое разрешает ссылочные типы, допускающие и не допускающие значения NULL.</span><span class="sxs-lookup"><span data-stu-id="5e637-124">To allow nullable reference types, use the `class?` constraint, which allows both nullable and non-nullable reference types.</span></span>

<span data-ttu-id="5e637-125">Предложение `where` может включать ограничение `notnull`.</span><span class="sxs-lookup"><span data-stu-id="5e637-125">The `where` clause may include the `notnull` constraint.</span></span> <span data-ttu-id="5e637-126">Ограничение `notnull` ограничивает параметр типа типами, допускающими значение NULL.</span><span class="sxs-lookup"><span data-stu-id="5e637-126">The `notnull` constraint limits the type parameter to non-nullable types.</span></span> <span data-ttu-id="5e637-127">Этот тип может быть [типом значения](../builtin-types/value-types.md) или ссылочным типом, не допускающим значение NULL.</span><span class="sxs-lookup"><span data-stu-id="5e637-127">That type may be a [value type](../builtin-types/value-types.md) or a non-nullable reference type.</span></span> <span data-ttu-id="5e637-128">Ограничение `notnull` доступно начиная с C# 8.0 для кода, скомпилированного в [`nullable enable` контексте](../../nullable-references.md#nullable-contexts).</span><span class="sxs-lookup"><span data-stu-id="5e637-128">The `notnull` constraint is available starting in C# 8.0 for code compiled in a [`nullable enable` context](../../nullable-references.md#nullable-contexts).</span></span> <span data-ttu-id="5e637-129">В отличие от других ограничений, если аргумент типа нарушает ограничение `notnull`, компилятор генерирует предупреждение вместо ошибки.</span><span class="sxs-lookup"><span data-stu-id="5e637-129">Unlike other constraints, if a type argument violates the `notnull` constraint, the compiler generates a warning instead of an error.</span></span> <span data-ttu-id="5e637-130">Предупреждения генерируются только в контексте `nullable enable`.</span><span class="sxs-lookup"><span data-stu-id="5e637-130">Warnings are only generated in a `nullable enable` context.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5e637-131">Универсальные объявления, включающие ограничение `notnull`, можно использовать в обнуляемом контексте, допускающем значение NULL, но компилятор не применяет ограничение.</span><span class="sxs-lookup"><span data-stu-id="5e637-131">Generic declarations that include the `notnull` constraint can be used in a nullable oblivious context, but compiler does not enforce the constraint.</span></span>

[!code-csharp[using the nonnull constraint](snippets/GenericWhereConstraints.cs#NotNull)]

<span data-ttu-id="5e637-132">Предложение `where` также может включать ограничение `unmanaged`.</span><span class="sxs-lookup"><span data-stu-id="5e637-132">The `where` clause may also include an `unmanaged` constraint.</span></span> <span data-ttu-id="5e637-133">Ограничение `unmanaged` позволяет использовать в качестве параметра типа только типы, называемые [неуправляемыми типами](../builtin-types/unmanaged-types.md).</span><span class="sxs-lookup"><span data-stu-id="5e637-133">The `unmanaged` constraint limits the type parameter to types known as [unmanaged types](../builtin-types/unmanaged-types.md).</span></span> <span data-ttu-id="5e637-134">Ограничение `unmanaged` упрощает написание кода взаимодействия низкого уровня на языке C#.</span><span class="sxs-lookup"><span data-stu-id="5e637-134">The `unmanaged` constraint makes it easier to write low-level interop code in C#.</span></span> <span data-ttu-id="5e637-135">Это ограничение включает подпрограммы с возможностью повторного использования для всех неуправляемых типов.</span><span class="sxs-lookup"><span data-stu-id="5e637-135">This constraint enables reusable routines across all unmanaged types.</span></span> <span data-ttu-id="5e637-136">Ограничение `unmanaged` нельзя использовать с ограничением `class` или `struct`.</span><span class="sxs-lookup"><span data-stu-id="5e637-136">The `unmanaged` constraint can't be combined with the `class` or `struct` constraint.</span></span> <span data-ttu-id="5e637-137">Ограничение `unmanaged` требует тип `struct`:</span><span class="sxs-lookup"><span data-stu-id="5e637-137">The `unmanaged` constraint enforces that the type must be a `struct`:</span></span>

[!code-csharp[using the unmanaged constraint](snippets/GenericWhereConstraints.cs#4)]

<span data-ttu-id="5e637-138">Предложение `where` также может включать ограничение конструктора, `new()`.</span><span class="sxs-lookup"><span data-stu-id="5e637-138">The `where` clause may also include a constructor constraint, `new()`.</span></span> <span data-ttu-id="5e637-139">Это ограничение позволяет создать экземпляр параметра типа с помощью оператора `new`.</span><span class="sxs-lookup"><span data-stu-id="5e637-139">That constraint makes it possible to create an instance of a type parameter using the `new` operator.</span></span> <span data-ttu-id="5e637-140">[Ограничение new()](new-constraint.md) сообщает компилятору о том, что все предоставленные аргументы типа должны иметь доступный конструктор без параметров.</span><span class="sxs-lookup"><span data-stu-id="5e637-140">The [new() Constraint](new-constraint.md) lets the compiler know that any type argument supplied must have an accessible parameterless constructor.</span></span> <span data-ttu-id="5e637-141">Пример:</span><span class="sxs-lookup"><span data-stu-id="5e637-141">For example:</span></span>

[!code-csharp[using the new constraint](snippets/GenericWhereConstraints.cs#5)]

<span data-ttu-id="5e637-142">Ограничение `new()` отображается в предложении `where` последним.</span><span class="sxs-lookup"><span data-stu-id="5e637-142">The `new()` constraint appears last in the `where` clause.</span></span> <span data-ttu-id="5e637-143">Ограничение `new()` не может использоваться с ограничениями `struct` или `unmanaged`.</span><span class="sxs-lookup"><span data-stu-id="5e637-143">The `new()` constraint can't be combined with the `struct` or `unmanaged` constraints.</span></span> <span data-ttu-id="5e637-144">Все типы, удовлетворяющие этим ограничениям, должны иметь доступ к конструктору без параметров, поэтому ограничение `new()` будет избыточным.</span><span class="sxs-lookup"><span data-stu-id="5e637-144">All types satisfying those constraints must have an accessible parameterless constructor, making the `new()` constraint redundant.</span></span>

<span data-ttu-id="5e637-145">Если параметров типа несколько, для каждого из них необходимо использовать по одному предложению `where`, например:</span><span class="sxs-lookup"><span data-stu-id="5e637-145">With multiple type parameters, use one `where` clause for each type parameter, for example:</span></span>

[!code-csharp[using multiple where constraints](snippets/GenericWhereConstraints.cs#6)]

<span data-ttu-id="5e637-146">Кроме того, ограничения можно присоединять к параметрам типа универсальных методов следующим образом:</span><span class="sxs-lookup"><span data-stu-id="5e637-146">You can also attach constraints to type parameters of generic methods, as shown in the following example:</span></span>

[!code-csharp[where constraints with generic methods](snippets/GenericWhereConstraints.cs#7)]

<span data-ttu-id="5e637-147">Обратите внимание на то, что ограничения параметров типа для делегатов имеют такой же синтаксис, как и методы:</span><span class="sxs-lookup"><span data-stu-id="5e637-147">Notice that the syntax to describe type parameter constraints on delegates is the same as that of methods:</span></span>

[!code-csharp[where constraints with generic methods](snippets/GenericWhereConstraints.cs#8)]

<span data-ttu-id="5e637-148">Дополнительные сведения об универсальных делегатах см. в разделе [Универсальные делегаты](../../programming-guide/generics/generic-delegates.md).</span><span class="sxs-lookup"><span data-stu-id="5e637-148">For information on generic delegates, see [Generic Delegates](../../programming-guide/generics/generic-delegates.md).</span></span>

<span data-ttu-id="5e637-149">Дополнительные сведения о синтаксисе и применении ограничений см. в разделе [Ограничения параметров типа](../../programming-guide/generics/constraints-on-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="5e637-149">For details on the syntax and use of constraints, see [Constraints on Type Parameters](../../programming-guide/generics/constraints-on-type-parameters.md).</span></span>

## <a name="c-language-specification"></a><span data-ttu-id="5e637-150">Спецификация языка C#</span><span class="sxs-lookup"><span data-stu-id="5e637-150">C# language specification</span></span>

 [!INCLUDE[CSharplangspec](~/includes/csharplangspec-md.md)]

## <a name="see-also"></a><span data-ttu-id="5e637-151">См. также</span><span class="sxs-lookup"><span data-stu-id="5e637-151">See also</span></span>

- [<span data-ttu-id="5e637-152">Справочник по C#</span><span class="sxs-lookup"><span data-stu-id="5e637-152">C# Reference</span></span>](../index.md)
- [<span data-ttu-id="5e637-153">Руководство по программированию на C#</span><span class="sxs-lookup"><span data-stu-id="5e637-153">C# Programming Guide</span></span>](../../programming-guide/index.md)
- [<span data-ttu-id="5e637-154">Введение в универсальные шаблоны</span><span class="sxs-lookup"><span data-stu-id="5e637-154">Introduction to Generics</span></span>](../../programming-guide/generics/index.md)
- [<span data-ttu-id="5e637-155">Ограничение new</span><span class="sxs-lookup"><span data-stu-id="5e637-155">new Constraint</span></span>](./new-constraint.md)
- [<span data-ttu-id="5e637-156">Ограничения параметров типа</span><span class="sxs-lookup"><span data-stu-id="5e637-156">Constraints on Type Parameters</span></span>](../../programming-guide/generics/constraints-on-type-parameters.md)
