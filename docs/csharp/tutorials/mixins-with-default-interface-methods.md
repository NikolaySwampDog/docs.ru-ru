---
title: Создание типов смешения с помощью методов интерфейса по умолчанию
description: Используя элементы интерфейса по умолчанию, можно расширить интерфейсы дополнительными реализациями по умолчанию для средств реализации.
ms.technology: csharp-advanced-concepts
ms.date: 10/04/2019
ms.openlocfilehash: fb876731f1cf16840b583ea23b1dd09d8ff74bfe
ms.sourcegitcommit: 42d436ebc2a7ee02fc1848c7742bc7d80e13fc2f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/04/2021
ms.locfileid: "102103716"
---
# <a name="tutorial-mix-functionality-in-when-creating-classes-using-interfaces-with-default-interface-methods"></a><span data-ttu-id="150ef-103">Учебник. Функциональные возможности смешения при создании классов с помощью методов интерфейса по умолчанию</span><span class="sxs-lookup"><span data-stu-id="150ef-103">Tutorial: Mix functionality in when creating classes using interfaces with default interface methods</span></span>

<span data-ttu-id="150ef-104">Начиная с C# 8.0 в .NET Core 3.0 можно определить реализацию при объявлении члена интерфейса.</span><span class="sxs-lookup"><span data-stu-id="150ef-104">Beginning with C# 8.0 on .NET Core 3.0, you can define an implementation when you declare a member of an interface.</span></span> <span data-ttu-id="150ef-105">Эта функция предоставляет новые возможности, позволяющие определить реализации по умолчанию для компонентов, объявленных в интерфейсах.</span><span class="sxs-lookup"><span data-stu-id="150ef-105">This feature provides new capabilities where you can define default implementations for features declared in interfaces.</span></span> <span data-ttu-id="150ef-106">Классы могут выбирать, когда следует переопределять функциональность, когда следует использовать функциональную возможность по умолчанию и когда не следует объявлять поддержку отдельных функций.</span><span class="sxs-lookup"><span data-stu-id="150ef-106">Classes can pick when to override functionality, when to use the default functionality, and when not to declare support for discrete features.</span></span>

<span data-ttu-id="150ef-107">В этом руководстве вы узнаете, как:</span><span class="sxs-lookup"><span data-stu-id="150ef-107">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> * <span data-ttu-id="150ef-108">Создать интерфейсы с реализациями, описывающими отдельные функции.</span><span class="sxs-lookup"><span data-stu-id="150ef-108">Create interfaces with implementations that describe discrete features.</span></span>
> * <span data-ttu-id="150ef-109">Создать классы, которые используют реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="150ef-109">Create classes that use the default implementations.</span></span>
> * <span data-ttu-id="150ef-110">Создать классы, которые переопределяют некоторые или все реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="150ef-110">Create classes that override some or all of the default implementations.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="150ef-111">Предварительные требования</span><span class="sxs-lookup"><span data-stu-id="150ef-111">Prerequisites</span></span>

<span data-ttu-id="150ef-112">Вам нужно настроить свой компьютер для выполнения .NET Core, включая компилятор C# 8.0.</span><span class="sxs-lookup"><span data-stu-id="150ef-112">You’ll need to set up your machine to run .NET Core, including the C# 8.0 compiler.</span></span> <span data-ttu-id="150ef-113">Компилятор C# 8.0 доступен в [Visual Studio 2019 версии 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) и выше или [пакете SDK .NET Core 3.0](https://dotnet.microsoft.com/download/dotnet) и выше.</span><span class="sxs-lookup"><span data-stu-id="150ef-113">The C# 8.0 compiler is available starting with [Visual Studio 2019 version 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019), or the [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download/dotnet) or later.</span></span>

## <a name="limitations-of-extension-methods"></a><span data-ttu-id="150ef-114">Ограничения методов расширения</span><span class="sxs-lookup"><span data-stu-id="150ef-114">Limitations of extension methods</span></span>

<span data-ttu-id="150ef-115">Одним из способов реализации поведения, проявляемого в рамках интерфейса, является определение [методов расширения](../programming-guide/classes-and-structs/extension-methods.md), которые обеспечивают поведение по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="150ef-115">One way you can implement behavior that appears as part of an interface is to define [extension methods](../programming-guide/classes-and-structs/extension-methods.md) that provide the default behavior.</span></span> <span data-ttu-id="150ef-116">Интерфейсы объявляют минимальный набор элементов, предоставляя большую контактную зону для любого класса, реализующего этот интерфейс.</span><span class="sxs-lookup"><span data-stu-id="150ef-116">Interfaces declare a minimum set of members while providing a greater surface area for any class that implements that interface.</span></span> <span data-ttu-id="150ef-117">Например, методы расширения в <xref:System.Linq.Enumerable> обеспечивают реализацию любой последовательности в качестве источника запроса LINQ.</span><span class="sxs-lookup"><span data-stu-id="150ef-117">For example, the extension methods in <xref:System.Linq.Enumerable> provide the implementation for any sequence to be the source of a LINQ query.</span></span>

<span data-ttu-id="150ef-118">Методы расширения разрешаются с использованием объявленного типа переменной во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="150ef-118">Extension methods are resolved at compile time, using the declared type of the variable.</span></span> <span data-ttu-id="150ef-119">Реализующие интерфейс классы могут обеспечить лучшую реализацию для любого метода расширения.</span><span class="sxs-lookup"><span data-stu-id="150ef-119">Classes that implement the interface can provide a better implementation for any extension method.</span></span> <span data-ttu-id="150ef-120">Объявления переменных должны соответствовать реализующему типу, чтобы позволить компилятору выбрать эту реализацию.</span><span class="sxs-lookup"><span data-stu-id="150ef-120">Variable declarations must match the implementing type to enable the compiler to choose that implementation.</span></span> <span data-ttu-id="150ef-121">Если тип во время компиляции соответствует интерфейсу, метод вызывает разрешение для метода расширения.</span><span class="sxs-lookup"><span data-stu-id="150ef-121">When the compile-time type matches the interface, method calls resolve to the extension method.</span></span> <span data-ttu-id="150ef-122">Другая проблема с методами расширения заключается в том, что эти методы доступны везде, где доступен класс, содержащий методы расширения.</span><span class="sxs-lookup"><span data-stu-id="150ef-122">Another concern with extension methods is that those methods are accessible wherever the class containing the extension methods is accessible.</span></span> <span data-ttu-id="150ef-123">Классы не могут объявлять, должны они или не должны предоставлять функции, объявленные в методах расширения.</span><span class="sxs-lookup"><span data-stu-id="150ef-123">Classes cannot declare if they should or should not provide features declared in extension methods.</span></span>

<span data-ttu-id="150ef-124">Начиная с C# 8.0, можно объявить реализации по умолчанию как методы интерфейса.</span><span class="sxs-lookup"><span data-stu-id="150ef-124">Starting with C# 8.0, you can declare the default implementations as interface methods.</span></span> <span data-ttu-id="150ef-125">Так каждый класс автоматически использует реализацию по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="150ef-125">Then, every class automatically uses the default implementation.</span></span> <span data-ttu-id="150ef-126">Классы, обеспечивающие лучшую реализацию, могут переопределить определение метода интерфейса с помощью более эффективного алгоритма.</span><span class="sxs-lookup"><span data-stu-id="150ef-126">Any class that can provide a better implementation can override the interface method definition with a better algorithm.</span></span> <span data-ttu-id="150ef-127">В каком-то смысле этот прием напоминает то, как можно использовать [метод расширения](../programming-guide/classes-and-structs/extension-methods.md).</span><span class="sxs-lookup"><span data-stu-id="150ef-127">In one sense, this technique sounds similar to how you could use [extension methods](../programming-guide/classes-and-structs/extension-methods.md).</span></span>

<span data-ttu-id="150ef-128">В этой статье вы узнаете, как реализации интерфейса по умолчанию позволяют поддерживать новые сценарии.</span><span class="sxs-lookup"><span data-stu-id="150ef-128">In this article, you'll learn how default interface implementations enable new scenarios.</span></span>

## <a name="design-the-application"></a><span data-ttu-id="150ef-129">Разработка приложения</span><span class="sxs-lookup"><span data-stu-id="150ef-129">Design the application</span></span>

<span data-ttu-id="150ef-130">Рассмотрим приложение для системы домашней автоматики.</span><span class="sxs-lookup"><span data-stu-id="150ef-130">Consider a home automation application.</span></span> <span data-ttu-id="150ef-131">Возможно, у вас есть много типов разного освещения и индикаторов, которые можно использовать во всем доме.</span><span class="sxs-lookup"><span data-stu-id="150ef-131">You probably have many different types of lights and indicators that could be used throughout the house.</span></span> <span data-ttu-id="150ef-132">Каждый источник освещения должен поддерживать интерфейсы API, позволяющие включать и выключать эти источники, а также передавать данные о текущем состоянии.</span><span class="sxs-lookup"><span data-stu-id="150ef-132">Every light must support APIs to turn them on and off, and to report the current state.</span></span> <span data-ttu-id="150ef-133">Некоторые источники освещения и индикаторы могут поддерживать другие функции, такие как:</span><span class="sxs-lookup"><span data-stu-id="150ef-133">Some lights and indicators may support other features, such as:</span></span>

- <span data-ttu-id="150ef-134">включение освещения, а затем его отключение по таймеру;</span><span class="sxs-lookup"><span data-stu-id="150ef-134">Turn light on, then turn it off after a timer.</span></span>
- <span data-ttu-id="150ef-135">мигание освещения в течение определенного периода времени.</span><span class="sxs-lookup"><span data-stu-id="150ef-135">Blink the light for a period of time.</span></span>

<span data-ttu-id="150ef-136">Некоторые из этих расширенных возможностей можно эмулировать на устройствах, поддерживающих минимальный набор.</span><span class="sxs-lookup"><span data-stu-id="150ef-136">Some of these extended capabilities could be emulated in devices that support the minimal set.</span></span> <span data-ttu-id="150ef-137">Это соответствует реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="150ef-137">That indicates providing a default implementation.</span></span> <span data-ttu-id="150ef-138">Для устройств со встроенными дополнительными возможностями программное обеспечение устройства будет использовать собственные возможности.</span><span class="sxs-lookup"><span data-stu-id="150ef-138">For those devices that have more capabilities built in, the device software would use the native capabilities.</span></span> <span data-ttu-id="150ef-139">Для других источников освещения они могут реализовать интерфейс и использовать реализацию по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="150ef-139">For other lights, they could choose to implement the interface and use the default implementation.</span></span>

<span data-ttu-id="150ef-140">Элементы интерфейса по умолчанию являются лучшим решением для этого сценария, чем методы расширения.</span><span class="sxs-lookup"><span data-stu-id="150ef-140">Default interface members is a better solution for this scenario than extension methods.</span></span> <span data-ttu-id="150ef-141">Авторы классов могут управлять выбором интерфейсов для реализации.</span><span class="sxs-lookup"><span data-stu-id="150ef-141">Class authors can control which interfaces they choose to implement.</span></span> <span data-ttu-id="150ef-142">Выбранные ими интерфейсы доступны как методы.</span><span class="sxs-lookup"><span data-stu-id="150ef-142">Those interfaces they choose are available as methods.</span></span> <span data-ttu-id="150ef-143">Кроме того, так как методы стандартного интерфейса являются виртуальными по умолчанию, диспетчеризация методов всегда выбирает реализацию в классе.</span><span class="sxs-lookup"><span data-stu-id="150ef-143">In addition, because default interface methods are virtual by default, the method dispatch always chooses the implementation in the class.</span></span>

<span data-ttu-id="150ef-144">Давайте создадим код для демонстрации этих различий.</span><span class="sxs-lookup"><span data-stu-id="150ef-144">Let's create the code to demonstrate these differences.</span></span>

## <a name="create-interfaces"></a><span data-ttu-id="150ef-145">Создание интерфейсов</span><span class="sxs-lookup"><span data-stu-id="150ef-145">Create interfaces</span></span>

<span data-ttu-id="150ef-146">Сначала можно создать интерфейс, который определяет поведение для всех источников освещения.</span><span class="sxs-lookup"><span data-stu-id="150ef-146">Start by creating the interface that defines the behavior for all lights:</span></span>

[!code-csharp[Declare base interface](./snippets/mixins-with-default-interface-methods/UnusedExampleCode.cs?name=SnippetILightInterfaceV1)]

<span data-ttu-id="150ef-147">Основное средство тестирования верхнего освещения может реализовать этот интерфейс, как показано в следующем коде.</span><span class="sxs-lookup"><span data-stu-id="150ef-147">A basic overhead light fixture might implement this interface as shown in the following code:</span></span>

[!code-csharp[First overhead light](./snippets/mixins-with-default-interface-methods/UnusedExampleCode.cs?name=SnippetOverheadLightV1)]

<span data-ttu-id="150ef-148">В этом учебнике код не поддерживает устройства Интернета вещей, но эмулирует такие действия, записывая сообщения в консоль.</span><span class="sxs-lookup"><span data-stu-id="150ef-148">In this tutorial, the code doesn't drive IoT devices, but emulates those activities by writing messages to the console.</span></span> <span data-ttu-id="150ef-149">Вы можете исследовать код без автоматизации дома.</span><span class="sxs-lookup"><span data-stu-id="150ef-149">You can explore the code without automating your house.</span></span>

<span data-ttu-id="150ef-150">Теперь определим интерфейс, автоматически отключающий освещение по истечении времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="150ef-150">Next, let's define the interface for a light that can automatically turn off after a timeout:</span></span>

[!code-csharp[pure Timer interface](./snippets/mixins-with-default-interface-methods/UnusedExampleCode.cs?name=SnippetPureTimerInterface)]

<span data-ttu-id="150ef-151">Можно добавить базовую реализацию к верхнему освещению, но лучшим решением является изменение этого определения интерфейса для предоставления реализации по умолчанию типа `virtual`.</span><span class="sxs-lookup"><span data-stu-id="150ef-151">You could add a basic implementation to the overhead light, but a better solution is to modify this interface definition to provide a `virtual` default implementation:</span></span>

[!code-csharp[Timer interface](./snippets/mixins-with-default-interface-methods/ITimerLight.cs?name=SnippetTimerLightFinal)]

<span data-ttu-id="150ef-152">После добавления этого изменения класс `OverheadLight` может реализовать функцию таймера, объявляя поддержку интерфейса.</span><span class="sxs-lookup"><span data-stu-id="150ef-152">By adding that change, the `OverheadLight` class can implement the timer function by declaring support for the interface:</span></span>

```csharp
public class OverheadLight : ITimerLight { }
```

<span data-ttu-id="150ef-153">Другой тип освещения может поддерживать более сложный протокол.</span><span class="sxs-lookup"><span data-stu-id="150ef-153">A different light type may support a more sophisticated protocol.</span></span> <span data-ttu-id="150ef-154">Он может предоставить собственную реализацию для `TurnOnFor`, как показано в следующем коде.</span><span class="sxs-lookup"><span data-stu-id="150ef-154">It can provide its own implementation for `TurnOnFor`, as shown in the following code:</span></span>

[!code-csharp[Override the timer function](./snippets/mixins-with-default-interface-methods/HalogenLight.cs?name=SnippetHalogenLight)]

<span data-ttu-id="150ef-155">В отличие от переопределения виртуальных методов классов, объявление `TurnOnFor` в классе `HalogenLight` не использует ключевое слово `override`.</span><span class="sxs-lookup"><span data-stu-id="150ef-155">Unlike overriding virtual class methods, the declaration of `TurnOnFor` in the `HalogenLight` class does not use the `override` keyword.</span></span>

## <a name="mix-and-match-capabilities"></a><span data-ttu-id="150ef-156">Смешение и сопоставление возможностей</span><span class="sxs-lookup"><span data-stu-id="150ef-156">Mix and match capabilities</span></span>

<span data-ttu-id="150ef-157">Преимущества методов интерфейса по умолчанию становятся понятнее, когда вы добавляете расширенные возможности.</span><span class="sxs-lookup"><span data-stu-id="150ef-157">The advantages of default interface methods become clearer as you introduce more advanced capabilities.</span></span> <span data-ttu-id="150ef-158">Использование интерфейса позволяет смешивать и сопоставлять возможности.</span><span class="sxs-lookup"><span data-stu-id="150ef-158">Using interfaces enables you to mix and match capabilities.</span></span> <span data-ttu-id="150ef-159">Это также позволяет каждому автору класса выбирать между реализацией по умолчанию и пользовательской реализацией.</span><span class="sxs-lookup"><span data-stu-id="150ef-159">It also enables each class author to choose between the default implementation and a custom implementation.</span></span> <span data-ttu-id="150ef-160">Давайте добавим интерфейс с реализацией по умолчанию для мигающего освещения.</span><span class="sxs-lookup"><span data-stu-id="150ef-160">Let's add an interface with a default implementation for a blinking light:</span></span>

[!code-csharp[Define the blinking light interface](./snippets/mixins-with-default-interface-methods/IBlinkingLight.cs?name=SnippetBlinkingLight)]

<span data-ttu-id="150ef-161">Реализация по умолчанию позволяет освещению мигать.</span><span class="sxs-lookup"><span data-stu-id="150ef-161">The default implementation enables any light to blink.</span></span> <span data-ttu-id="150ef-162">С помощью реализации по умолчанию к верхнему освещению можно добавить возможности таймера и мигания.</span><span class="sxs-lookup"><span data-stu-id="150ef-162">The overhead light can add both timer and blink capabilities using the default implementation:</span></span>

[!code-csharp[Use the default blink function](./snippets/mixins-with-default-interface-methods/OverheadLight.cs?name=SnippetOverheadLight)]

<span data-ttu-id="150ef-163">Новый тип освещения `LEDLight` поддерживает функцию таймера и функцию мигания напрямую.</span><span class="sxs-lookup"><span data-stu-id="150ef-163">A new light type, the `LEDLight` supports both the timer function and the blink function directly.</span></span> <span data-ttu-id="150ef-164">Такой стиль освещения реализует интерфейсы `ITimerLight` и `IBlinkingLight`, а также переопределяет метод `Blink`.</span><span class="sxs-lookup"><span data-stu-id="150ef-164">This light style implements both the `ITimerLight` and `IBlinkingLight` interfaces, and overrides the `Blink` method:</span></span>

[!code-csharp[Override the blink function](./snippets/mixins-with-default-interface-methods/LEDLight.cs?name=SnippetLEDLight)]

<span data-ttu-id="150ef-165">`ExtraFancyLight` может напрямую поддерживать функции мигания и таймера.</span><span class="sxs-lookup"><span data-stu-id="150ef-165">An `ExtraFancyLight` might support both blink and timer functions directly:</span></span>

[!code-csharp[Override the blink and timer function](./snippets/mixins-with-default-interface-methods/ExtraFancyLight.cs?name=SnippetExtraFancyLight)]

<span data-ttu-id="150ef-166">Ранее созданный класс `HalogenLight` не поддерживает мигание.</span><span class="sxs-lookup"><span data-stu-id="150ef-166">The `HalogenLight` you created earlier doesn't support blinking.</span></span> <span data-ttu-id="150ef-167">Поэтому не добавляйте `IBlinkingLight` в список его поддерживаемых интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="150ef-167">So, don't add the `IBlinkingLight` to the list of its supported interfaces.</span></span>

## <a name="detect-the-light-types-using-pattern-matching"></a><span data-ttu-id="150ef-168">Определение типов освещения с помощью сопоставления шаблонов</span><span class="sxs-lookup"><span data-stu-id="150ef-168">Detect the light types using pattern matching</span></span>

<span data-ttu-id="150ef-169">Теперь давайте напишем тестовый код.</span><span class="sxs-lookup"><span data-stu-id="150ef-169">Next, let's write some test code.</span></span> <span data-ttu-id="150ef-170">С помощью функции [сопоставления шаблонов](../pattern-matching.md) в C# можно определить возможности освещения путем проверки поддерживаемых им интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="150ef-170">You can make use of C#'s [pattern matching](../pattern-matching.md) feature to determine a light's capabilities by examining which interfaces it supports.</span></span>  <span data-ttu-id="150ef-171">Следующий метод выполняет поддерживаемые возможности для каждого источника освещения.</span><span class="sxs-lookup"><span data-stu-id="150ef-171">The following method exercises the supported capabilities of each light:</span></span>

[!code-csharp[Test a light's capabilities](./snippets/mixins-with-default-interface-methods/Program.cs?name=SnippetTestLightFunctions)]

<span data-ttu-id="150ef-172">Следующий код в методе `Main` последовательно создает каждый тип освещения и тестирует его.</span><span class="sxs-lookup"><span data-stu-id="150ef-172">The following code in your `Main` method creates each light type in sequence and tests that light:</span></span>

[!code-csharp[Test a light's capabilities](./snippets/mixins-with-default-interface-methods/Program.cs?name=SnippetMainMethod)]

## <a name="how-the-compiler-determines-best-implementation"></a><span data-ttu-id="150ef-173">Как компилятор определяет наилучшую реализацию</span><span class="sxs-lookup"><span data-stu-id="150ef-173">How the compiler determines best implementation</span></span>

<span data-ttu-id="150ef-174">В этом сценарии показан базовый интерфейс без каких-либо реализаций.</span><span class="sxs-lookup"><span data-stu-id="150ef-174">This scenario shows a base interface without any implementations.</span></span> <span data-ttu-id="150ef-175">Добавление метода в интерфейс `ILight` вводит новые сложности.</span><span class="sxs-lookup"><span data-stu-id="150ef-175">Adding a method into the `ILight` interface introduces new complexities.</span></span> <span data-ttu-id="150ef-176">Языковые правила, управляющие методами интерфейса по умолчанию, снижают влияние на конкретные классы, которые реализуют несколько производных интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="150ef-176">The language rules governing default interface methods minimize the effect on the concrete classes that implement multiple derived interfaces.</span></span> <span data-ttu-id="150ef-177">Попробуем улучшить исходный интерфейс с помощью нового метода, чтобы продемонстрировать, как это изменит использование интерфейса.</span><span class="sxs-lookup"><span data-stu-id="150ef-177">Let's enhance the original interface with a new method to show how that changes its use.</span></span> <span data-ttu-id="150ef-178">Каждый световой индикатор может сообщать о своем состоянии питания в виде перечисленного значения.</span><span class="sxs-lookup"><span data-stu-id="150ef-178">Every indicator light can report its power status as an enumerated value:</span></span>

[!code-csharp[Enumeration for power status](./snippets/mixins-with-default-interface-methods/ILight.cs?name=SnippetPowerStatus)]

<span data-ttu-id="150ef-179">Реализация по умолчанию предполагает отключение питания от сети.</span><span class="sxs-lookup"><span data-stu-id="150ef-179">The default implementation assumes no power:</span></span>

[!code-csharp[Report a default power status](./snippets/mixins-with-default-interface-methods/ILight.cs?name=SnippetILightInterface)]

<span data-ttu-id="150ef-180">Эти изменения компилируются правильно, несмотря на то что `ExtraFancyLight` объявляет поддержку интерфейса `ILight` и производных интерфейсов `ITimerLight` и `IBlinkingLight`.</span><span class="sxs-lookup"><span data-stu-id="150ef-180">These changes compile cleanly, even though the `ExtraFancyLight` declares support for the `ILight` interface and both derived interfaces, `ITimerLight` and `IBlinkingLight`.</span></span> <span data-ttu-id="150ef-181">В интерфейсе `ILight` объявлена только одна "ближайшая" реализация.</span><span class="sxs-lookup"><span data-stu-id="150ef-181">There's only one "closest" implementation declared in the `ILight` interface.</span></span> <span data-ttu-id="150ef-182">Любой класс, который объявляет переопределение, стает "ближайшей" реализацией.</span><span class="sxs-lookup"><span data-stu-id="150ef-182">Any class that declared an override would become the one "closest" implementation.</span></span> <span data-ttu-id="150ef-183">Вы видели примеры с предыдущими классами, которые переопределили элементы других производных интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="150ef-183">You saw examples in the preceding classes that overrode the members of other derived interfaces.</span></span>

<span data-ttu-id="150ef-184">Старайтесь не переопределять один и тот же метод в нескольких производных интерфейсах.</span><span class="sxs-lookup"><span data-stu-id="150ef-184">Avoid overriding the same method in multiple derived interfaces.</span></span> <span data-ttu-id="150ef-185">При этом создается неоднозначный вызов метода каждый раз, когда класс реализует оба производных интерфейса.</span><span class="sxs-lookup"><span data-stu-id="150ef-185">Doing so creates an ambiguous method call whenever a class implements both derived interfaces.</span></span> <span data-ttu-id="150ef-186">Компилятор не может выбрать один лучший метод, поэтому выдает ошибку.</span><span class="sxs-lookup"><span data-stu-id="150ef-186">The compiler can't pick a single better method so it issues an error.</span></span> <span data-ttu-id="150ef-187">Например, если и `IBlinkingLight`, и `ITimerLight` реализовали переопределение `PowerStatus`, то для `OverheadLight` потребуется предоставить более конкретное переопределение.</span><span class="sxs-lookup"><span data-stu-id="150ef-187">For example, if both the `IBlinkingLight` and `ITimerLight` implemented an override of `PowerStatus`, the `OverheadLight` would need to provide a more specific override.</span></span> <span data-ttu-id="150ef-188">В противном случае компилятор не сможет выбрать между реализациями двух производных интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="150ef-188">Otherwise, the compiler can't pick between the implementations in the two derived interfaces.</span></span> <span data-ttu-id="150ef-189">Обычно эту ситуацию можно избежать, сохраняя определения интерфейсов компактными и направленными на одну функцию.</span><span class="sxs-lookup"><span data-stu-id="150ef-189">You can usually avoid this situation by keeping interface definitions small and focused on one feature.</span></span> <span data-ttu-id="150ef-190">В этом сценарии каждая возможность освещения является собственным интерфейсом. Несколько интерфейсов наследуются только классами.</span><span class="sxs-lookup"><span data-stu-id="150ef-190">In this scenario, each capability of a light is its own interface; multiple interfaces are only inherited by classes.</span></span>

<span data-ttu-id="150ef-191">В этом примере показан один из сценариев, в котором можно определить отдельные функции, которые можно комбинировать в классы.</span><span class="sxs-lookup"><span data-stu-id="150ef-191">This sample shows one scenario where you can define discrete features that can be mixed into classes.</span></span> <span data-ttu-id="150ef-192">Вы объявили любой набор поддерживаемых функциональных возможностей, объявляя интерфейсы, поддерживаемые классом.</span><span class="sxs-lookup"><span data-stu-id="150ef-192">You declare any set of supported functionality by declaring which interfaces a class supports.</span></span> <span data-ttu-id="150ef-193">Виртуальные методы интерфейса по умолчанию позволяют классам использовать или определять различные реализации для любого или всех методов интерфейса.</span><span class="sxs-lookup"><span data-stu-id="150ef-193">The use of virtual default interface methods enables classes to use or define a different implementation for any or all the interface methods.</span></span> <span data-ttu-id="150ef-194">Такая возможность языка предоставляет новые способы для моделирования реальных систем, которые вы создаете.</span><span class="sxs-lookup"><span data-stu-id="150ef-194">This language capability provides new ways to model the real-world systems you're building.</span></span> <span data-ttu-id="150ef-195">Методы интерфейса по умолчанию предоставляют более понятный способ для выражения связанных классов, которые могут смешивать и сопоставлять различные возможности с помощью их виртуальных реализаций.</span><span class="sxs-lookup"><span data-stu-id="150ef-195">Default interface methods provide a clearer way to express related classes that may mix and match different features using virtual implementations of those capabilities.</span></span>
