---
title: Использование типов записей — учебник по C#
description: Сведения об использовании типов записей, построении иерархий записей, а также о том, когда следует выбирать записи вместо классов.
ms.date: 11/12/2020
ms.openlocfilehash: 301eaf1ddf6d6b7dc1f88ffa4c790e2c2b01862f
ms.sourcegitcommit: b27645cb378d4e8137a267e5467ff31409acf6c0
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2021
ms.locfileid: "103231437"
---
# <a name="create-record-types"></a><span data-ttu-id="d5733-103">Создание типов записей</span><span class="sxs-lookup"><span data-stu-id="d5733-103">Create record types</span></span>

<span data-ttu-id="d5733-104">В C# 9 появились *записи* — новый тип ссылки, который можно создать вместо классов или структур.</span><span class="sxs-lookup"><span data-stu-id="d5733-104">C# 9 introduces *records*, a new reference type that you can create instead of classes or structs.</span></span> <span data-ttu-id="d5733-105">Записи отличаются от классов тем, что типы записей используют *равенство на основе значений*.</span><span class="sxs-lookup"><span data-stu-id="d5733-105">Records are distinct from classes in that record types use *value-based equality*.</span></span> <span data-ttu-id="d5733-106">Две переменные типа записи равны, если определения типов записей идентичны и если для каждого поля значения в обеих записях равны.</span><span class="sxs-lookup"><span data-stu-id="d5733-106">Two variables of a record type are equal if the record type definitions are identical, and if for every field, the values in both records are equal.</span></span> <span data-ttu-id="d5733-107">Две переменные типа класса равны, если объекты, на которые они ссылаются, относятся к одному и тому же типу класса, а переменные ссылаются на один и тот же объект.</span><span class="sxs-lookup"><span data-stu-id="d5733-107">Two variables of a class type are equal if the objects referred to are the same class type and the variables refer to the same object.</span></span> <span data-ttu-id="d5733-108">Равенство на основе значений подразумевает другие полезные возможности.</span><span class="sxs-lookup"><span data-stu-id="d5733-108">Value-based equality implies other capabilities you'll probably want in record types.</span></span> <span data-ttu-id="d5733-109">Компилятор создает многие из этих элементов при объявлении `record` вместо `class`.</span><span class="sxs-lookup"><span data-stu-id="d5733-109">The compiler generates many of those members when you declare a `record` instead of a `class`.</span></span>

<span data-ttu-id="d5733-110">Из этого руководства вы узнаете, как выполнять следующие задачи:</span><span class="sxs-lookup"><span data-stu-id="d5733-110">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> - <span data-ttu-id="d5733-111">Решите, следует ли объявлять `class` или `record`.</span><span class="sxs-lookup"><span data-stu-id="d5733-111">Decide if you should declare a `class` or a `record`.</span></span>
> - <span data-ttu-id="d5733-112">Объявите типы записей и типы позиционных записей.</span><span class="sxs-lookup"><span data-stu-id="d5733-112">Declare record types and positional record types.</span></span>
> - <span data-ttu-id="d5733-113">Замените методы на созданные компилятором методы в записях.</span><span class="sxs-lookup"><span data-stu-id="d5733-113">Substitute your methods for compiler generated methods in records.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="d5733-114">Предварительные условия</span><span class="sxs-lookup"><span data-stu-id="d5733-114">Prerequisites</span></span>

<span data-ttu-id="d5733-115">Вам нужно настроить компьютер для выполнения .NET 5 или более поздней версии, включая компилятор C# 9.0 или более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="d5733-115">You'll need to set up your machine to run .NET 5 or later, including the C# 9.0 or later compiler.</span></span> <span data-ttu-id="d5733-116">Компилятор C# 9.0 доступен начиная с [версии 16.8 Visual Studio 2019](https://visualstudio.microsoft.com/vs) или [пакета SDK для .NET Core 5.0](https://dotnet.microsoft.com/download).</span><span class="sxs-lookup"><span data-stu-id="d5733-116">The C# 9.0 compiler is available starting with [Visual Studio 2019 version 16.8](https://visualstudio.microsoft.com/vs) or the [.NET 5.0 SDK](https://dotnet.microsoft.com/download).</span></span>

## <a name="characteristics-of-records"></a><span data-ttu-id="d5733-117">Характеристики записей</span><span class="sxs-lookup"><span data-stu-id="d5733-117">Characteristics of records</span></span>

<span data-ttu-id="d5733-118">Вы определяете *запись*, объявляя тип с помощью ключевого слова `record` вместо ключевого слова `class` или `struct`.</span><span class="sxs-lookup"><span data-stu-id="d5733-118">You define a *record* by declaring a type with the `record` keyword, instead of the `class` or `struct` keyword.</span></span> <span data-ttu-id="d5733-119">Запись является ссылочным типом и соответствует семантике равенства на основе значений.</span><span class="sxs-lookup"><span data-stu-id="d5733-119">A record is a reference type and follows value-based equality semantics.</span></span> <span data-ttu-id="d5733-120">Чтобы обеспечить такую семантику, компилятор создает несколько методов для типа записи:</span><span class="sxs-lookup"><span data-stu-id="d5733-120">To enforce value semantics, the compiler generates several methods for your record type:</span></span>

- <span data-ttu-id="d5733-121">Переопределение <xref:System.Object.Equals(System.Object)?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d5733-121">An override of <xref:System.Object.Equals(System.Object)?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="d5733-122">Виртуальный метод `Equals`, параметр которого является типом записи.</span><span class="sxs-lookup"><span data-stu-id="d5733-122">A virtual `Equals` method whose parameter is the record type.</span></span>
- <span data-ttu-id="d5733-123">Переопределение <xref:System.Object.GetHashCode?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d5733-123">An override of <xref:System.Object.GetHashCode?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="d5733-124">Методы для `operator ==` и `operator !=`.</span><span class="sxs-lookup"><span data-stu-id="d5733-124">Methods for `operator ==` and `operator !=`.</span></span>
- <span data-ttu-id="d5733-125">Типы записей реализуют <xref:System.IEquatable%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d5733-125">Record types implement <xref:System.IEquatable%601?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="d5733-126">Кроме того, записи обеспечивают переопределение <xref:System.Object.ToString?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d5733-126">In addition, records provide an override of <xref:System.Object.ToString?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d5733-127">Компилятор синтезирует методы для отображения записей с помощью <xref:System.Object.ToString?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d5733-127">The compiler synthesizes methods for displaying records using <xref:System.Object.ToString?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d5733-128">Эти элементы будут рассмотрены при написании кода для этого учебника.</span><span class="sxs-lookup"><span data-stu-id="d5733-128">You'll explore those members as you write the code for this tutorial.</span></span> <span data-ttu-id="d5733-129">Записи поддерживают выражения `with`, позволяющие выполнять обратимое изменение записей.</span><span class="sxs-lookup"><span data-stu-id="d5733-129">Records support `with` expressions to enable non-destructive mutation of records.</span></span>

<span data-ttu-id="d5733-130">Вы также можете объявить *позиционные записи*, используя более краткий синтаксис.</span><span class="sxs-lookup"><span data-stu-id="d5733-130">You can also declare *positional records* using a more concise syntax.</span></span> <span data-ttu-id="d5733-131">При объявлении позиционных записей компилятор синтезирует дополнительные методы:</span><span class="sxs-lookup"><span data-stu-id="d5733-131">The compiler synthesizes more methods for you when you declare positional records:</span></span>

- <span data-ttu-id="d5733-132">Основной конструктор, параметры которого соответствуют позиционным параметрам в объявлении записи.</span><span class="sxs-lookup"><span data-stu-id="d5733-132">A primary constructor whose parameters match the positional parameters on the record declaration.</span></span>
- <span data-ttu-id="d5733-133">Открытые свойства только для инициализации для каждого параметра основного конструктора.</span><span class="sxs-lookup"><span data-stu-id="d5733-133">Public init-only properties for each parameter of a primary constructor.</span></span>
- <span data-ttu-id="d5733-134">Метод `Deconstruct` для извлечения свойств из записи.</span><span class="sxs-lookup"><span data-stu-id="d5733-134">A `Deconstruct` method to extract properties from the record.</span></span>

## <a name="build-temperature-data"></a><span data-ttu-id="d5733-135">Создание данных о температуре</span><span class="sxs-lookup"><span data-stu-id="d5733-135">Build temperature data</span></span>

<span data-ttu-id="d5733-136">Данные и статистика представляют собой сценарии, в которых необходимо использовать записи.</span><span class="sxs-lookup"><span data-stu-id="d5733-136">Data and statistics are among the scenarios where you'll want to use records.</span></span> <span data-ttu-id="d5733-137">В этом учебнике вы создадите приложение, которое вычисляет *градусо-дни* для разных целей.</span><span class="sxs-lookup"><span data-stu-id="d5733-137">For this tutorial, you'll build an application that computes *degree days* for different uses.</span></span> <span data-ttu-id="d5733-138">*Градусо-дни* представляют собой меру тепла (или недостатка тепла) в течение нескольких дней, недель или месяцев.</span><span class="sxs-lookup"><span data-stu-id="d5733-138">*Degree days* are a measure of heat (or lack of heat) over a period of days, weeks, or months.</span></span> <span data-ttu-id="d5733-139">Градусо-дни позволяют отслеживать и прогнозировать использование энергии.</span><span class="sxs-lookup"><span data-stu-id="d5733-139">Degree days track and predict energy usage.</span></span> <span data-ttu-id="d5733-140">Чем больше жарких дней, тем больше будет использоваться кондиционер, а чем больше холодных дней, тем больше будут использоваться обогреватели.</span><span class="sxs-lookup"><span data-stu-id="d5733-140">More hotter days means more air conditioning, and more colder days means more furnace usage.</span></span> <span data-ttu-id="d5733-141">Градусо-дни помогают управлять популяциями растений и учитывать рост растений по мере смены времен года.</span><span class="sxs-lookup"><span data-stu-id="d5733-141">Degree days help manage plant populations and correlate to plant growth as the seasons change.</span></span> <span data-ttu-id="d5733-142">Градусо-дни помогают отслеживать миграцию животных в зависимости от климата.</span><span class="sxs-lookup"><span data-stu-id="d5733-142">Degree days help track animal migrations for species that travel to match climate.</span></span>

<span data-ttu-id="d5733-143">Формула основана на средней температуре в определенный день и базовой температуре.</span><span class="sxs-lookup"><span data-stu-id="d5733-143">The formula is based on the mean temperature on a given day and a baseline temperature.</span></span> <span data-ttu-id="d5733-144">Чтобы вычислить градусо-дни за период времени, вам нужно знать высокую и низкую температуру каждого дня этого периода.</span><span class="sxs-lookup"><span data-stu-id="d5733-144">To compute degree days over time, you'll need the high and low temperature each day for a period of time.</span></span> <span data-ttu-id="d5733-145">Давайте начнем с создания нового приложения.</span><span class="sxs-lookup"><span data-stu-id="d5733-145">Let's start by creating a new application.</span></span> <span data-ttu-id="d5733-146">Создание нового консольного приложения.</span><span class="sxs-lookup"><span data-stu-id="d5733-146">Make a new console application.</span></span> <span data-ttu-id="d5733-147">Создать новый тип записи в новом файле с именем DailyTemperature.cs:</span><span class="sxs-lookup"><span data-stu-id="d5733-147">Create a new record type in a new file named "DailyTemperature.cs":</span></span>

:::code language="csharp" source="snippets/record-types/InterimSteps.cs" ID="DailyRecord":::

<span data-ttu-id="d5733-148">В предыдущем коде определяется *позиционная запись*.</span><span class="sxs-lookup"><span data-stu-id="d5733-148">The preceding code defines a *positional record*.</span></span> <span data-ttu-id="d5733-149">Вы создали ссылочный тип, содержащий два свойства: `HighTemp` и `LowTemp`.</span><span class="sxs-lookup"><span data-stu-id="d5733-149">You've created a reference type that contains two properties: `HighTemp`, and `LowTemp`.</span></span> <span data-ttu-id="d5733-150">Эти свойства являются *свойствами только для инициализации*, то есть их можно задать в конструкторе или с помощью инициализатора свойств.</span><span class="sxs-lookup"><span data-stu-id="d5733-150">Those properties are *init only properties*, meaning they can be set in the constructor or using a property initializer.</span></span> <span data-ttu-id="d5733-151">Тип `DailyTemperature` также имеет *основной конструктор* с двумя параметрами, соответствующими двум свойствам.</span><span class="sxs-lookup"><span data-stu-id="d5733-151">The `DailyTemperature` type also has a *primary constructor* that has two parameters that match the two properties.</span></span> <span data-ttu-id="d5733-152">Основной конструктор используется для инициализации записи `DailyTemperature`:</span><span class="sxs-lookup"><span data-stu-id="d5733-152">You use the primary constructor to initialize a `DailyTemperature` record:</span></span>

:::code language="csharp" source="snippets/record-types/Program.cs" ID="DeclareData":::

<span data-ttu-id="d5733-153">В записи можно добавлять собственные свойства или методы, включая позиционные записи.</span><span class="sxs-lookup"><span data-stu-id="d5733-153">You can add your own properties or methods to records, including positional records.</span></span> <span data-ttu-id="d5733-154">Необходимо вычислить среднюю температуру каждого дня.</span><span class="sxs-lookup"><span data-stu-id="d5733-154">You'll need to compute the mean temperature for each day.</span></span> <span data-ttu-id="d5733-155">Это свойство можно добавить в запись `DailyTemperature`:</span><span class="sxs-lookup"><span data-stu-id="d5733-155">You can add that property to the `DailyTemperature` record:</span></span>

:::code language="csharp" source="snippets/record-types/DailyTemperature.cs" ID="TemperatureRecord":::

<span data-ttu-id="d5733-156">Давайте убедимся, что вы можете использовать эти данные.</span><span class="sxs-lookup"><span data-stu-id="d5733-156">Let's make sure you can use this data.</span></span> <span data-ttu-id="d5733-157">Добавьте приведенный ниже код в метод `Main`:</span><span class="sxs-lookup"><span data-stu-id="d5733-157">Add the following code to your `Main` method:</span></span>

```csharp
foreach (var item in data)
    Console.WriteLine(item);
```

<span data-ttu-id="d5733-158">Запустите приложение, и вы увидите результат, похожий на следующий (несколько строк удалено для экономии места):</span><span class="sxs-lookup"><span data-stu-id="d5733-158">Run your application, and you'll see output that looks similar to the following display (several rows removed for space):</span></span>

```dotnetcli
DailyTemperature { HighTemp = 57, LowTemp = 30, Mean = 43.5 }
DailyTemperature { HighTemp = 60, LowTemp = 35, Mean = 47.5 }


DailyTemperature { HighTemp = 80, LowTemp = 60, Mean = 70 }
DailyTemperature { HighTemp = 85, LowTemp = 66, Mean = 75.5 }
```

<span data-ttu-id="d5733-159">В приведенном выше коде показаны выходные данные переопределения `ToString`, синтезированные компилятором.</span><span class="sxs-lookup"><span data-stu-id="d5733-159">The preceding code shows the output from the override of `ToString` synthesized by the compiler.</span></span> <span data-ttu-id="d5733-160">Если вы предпочитаете другой текст, то можете написать собственную версию `ToString`. При этом компилятор не будет синтезировать версию автоматически.</span><span class="sxs-lookup"><span data-stu-id="d5733-160">If you prefer different text, you can write your own version of `ToString` that prevents the compiler from synthesizing a version for you.</span></span>

## <a name="compute-degree-days"></a><span data-ttu-id="d5733-161">Вычисление градусо-дней</span><span class="sxs-lookup"><span data-stu-id="d5733-161">Compute degree days</span></span>

<span data-ttu-id="d5733-162">Чтобы вычислить градусо-дни, нужно взять разность между базовой температурой и средней температурой за определенный день.</span><span class="sxs-lookup"><span data-stu-id="d5733-162">To compute degree days, you take the difference from a baseline temperature and the mean temperature on a given day.</span></span> <span data-ttu-id="d5733-163">Чтобы измерить теплые дни за период времени, не учитывайте дни, когда средняя температура была ниже базовой.</span><span class="sxs-lookup"><span data-stu-id="d5733-163">To measure heat over time, you discard any days where the mean temperature is below the baseline.</span></span> <span data-ttu-id="d5733-164">Чтобы измерить холодные дни за период времени, не учитывайте дни, когда средняя температура была выше базовой.</span><span class="sxs-lookup"><span data-stu-id="d5733-164">To measure cold over time, you discard any days where the mean temperature is above the baseline.</span></span> <span data-ttu-id="d5733-165">Например, в США за основу берется 65 градусов по Фаренгейту.</span><span class="sxs-lookup"><span data-stu-id="d5733-165">For example, the U.S. uses 65F as the base for both heating  and cooling degree days.</span></span> <span data-ttu-id="d5733-166">В эту температуру не требуется включать нагрев или охлаждение.</span><span class="sxs-lookup"><span data-stu-id="d5733-166">That's the temperature where no heating or cooling is needed.</span></span> <span data-ttu-id="d5733-167">Если средняя температура дня составляет 70 градусов по Фаренгейту, это 5 градусо-дней в плане охлаждения и 0 градусо-дней в плане обогрева.</span><span class="sxs-lookup"><span data-stu-id="d5733-167">If a day has a mean temperature of 70F, that day is 5 cooling degree days and 0 heating degree days.</span></span> <span data-ttu-id="d5733-168">Если средняя температура дня составляет 55 градусов по Фаренгейту, это 0 градусо-дней в плане охлаждения и 10 градусо-дней в плане обогрева.</span><span class="sxs-lookup"><span data-stu-id="d5733-168">Conversely, if the mean temperature is 55F, that day is 10 heating degree days and 0 cooling degree days.</span></span>

<span data-ttu-id="d5733-169">Эти формулы можно выразить как небольшую иерархию типов записей: абстрактный тип градусо-дней и два конкретных типа для градусо-дней обогрева и градусо-дней охлаждения.</span><span class="sxs-lookup"><span data-stu-id="d5733-169">You can express these formulas as a small hierarchy of record types: an abstract degree day type and two concrete types for heating degree days and cooling degree days.</span></span> <span data-ttu-id="d5733-170">Эти типы также могут быть позиционными записями.</span><span class="sxs-lookup"><span data-stu-id="d5733-170">These types can also be positional records.</span></span> <span data-ttu-id="d5733-171">Они принимают базовую температуру и последовательность ежедневных записей температуры в качестве аргументов для основного конструктора:</span><span class="sxs-lookup"><span data-stu-id="d5733-171">They take a baseline temperature and a sequence of daily temperature records as arguments to the primary constructor:</span></span>

:::code language="csharp" source="snippets/record-types/InterimSteps.cs" ID="DegreeDaysRecords":::

<span data-ttu-id="d5733-172">Абстрактная запись `DegreeDays` является общим базовым классом для записей `HeatingDegreeDays` и `CoolingDegreeDays`.</span><span class="sxs-lookup"><span data-stu-id="d5733-172">The abstract `DegreeDays` record is the shared base class for both the `HeatingDegreeDays` and `CoolingDegreeDays` records.</span></span> <span data-ttu-id="d5733-173">Объявления основного конструктора в производных записях показывают, как управлять инициализацией базовой записи.</span><span class="sxs-lookup"><span data-stu-id="d5733-173">The primary constructor declarations on the derived records show how to manage base record initialization.</span></span> <span data-ttu-id="d5733-174">Ваша производная запись объявляет параметры для всех параметров в основном конструкторе базовой записи.</span><span class="sxs-lookup"><span data-stu-id="d5733-174">Your derived record declares parameters for all the parameters in the base record primary constructor.</span></span> <span data-ttu-id="d5733-175">Базовая запись объявляет и инициализирует эти свойства.</span><span class="sxs-lookup"><span data-stu-id="d5733-175">The base record declares and initializes those properties.</span></span> <span data-ttu-id="d5733-176">Производная запись не скрывает их, но создает и инициализирует только свойства для параметров, которые не объявлены в базовой записи.</span><span class="sxs-lookup"><span data-stu-id="d5733-176">The derived record doesn't hide them, but only creates and initializes properties for parameters that aren't declared in its base record.</span></span> <span data-ttu-id="d5733-177">В этом примере производные записи не добавляют новые параметры основного конструктора.</span><span class="sxs-lookup"><span data-stu-id="d5733-177">In this example, the derived records don't add new primary constructor parameters.</span></span> <span data-ttu-id="d5733-178">Протестируйте код, добавив следующий код в метод `Main`:</span><span class="sxs-lookup"><span data-stu-id="d5733-178">Test your code by adding the following code to your `Main` method:</span></span>

:::code language="csharp" source="snippets/record-types/Program.cs" ID="HeatingAndCooling":::

<span data-ttu-id="d5733-179">Вы получите выходные данные, подобные следующим:</span><span class="sxs-lookup"><span data-stu-id="d5733-179">You'll get output like the following display:</span></span>

```dotnetcli
HeatingDegreeDays { BaseTemperature = 65, TempRecords = record_types.DailyTemperature[], DegreeDays = 85 }
CoolingDegreeDays { BaseTemperature = 65, TempRecords = record_types.DailyTemperature[], DegreeDays = 71.5 }
```

## <a name="define-compiler-synthesized-methods"></a><span data-ttu-id="d5733-180">Определение методов, синтезируемых компилятором</span><span class="sxs-lookup"><span data-stu-id="d5733-180">Define compiler-synthesized methods</span></span>

<span data-ttu-id="d5733-181">В коде вычисляется правильное число градусо-дней обогрева и охлаждения за этот период времени.</span><span class="sxs-lookup"><span data-stu-id="d5733-181">Your code calculates the correct number of heating and cooling degree days over that period of time.</span></span> <span data-ttu-id="d5733-182">Но в этом примере показано, почему может потребоваться заменить некоторые синтезированные методы на записи.</span><span class="sxs-lookup"><span data-stu-id="d5733-182">But this example shows why you may want to replace some of the synthesized methods for records.</span></span> <span data-ttu-id="d5733-183">Вы можете объявить собственную версию любых синтезированных компилятором методов в типе записи, за исключением метода клонирования.</span><span class="sxs-lookup"><span data-stu-id="d5733-183">You can declare your own version of any of the compiler-synthesized methods in a record type except the clone method.</span></span> <span data-ttu-id="d5733-184">Метод клонирования имеет имя, созданное компилятором, и вы не можете предоставить другую реализацию.</span><span class="sxs-lookup"><span data-stu-id="d5733-184">The clone method has a compiler generated name and you cannot provide a different implementation.</span></span> <span data-ttu-id="d5733-185">Эти синтезированные методы включают конструктор копий, элементы интерфейса <xref:System.IEquatable%601?displayProperty=nameWithType>, проверки равенства и неравенства, а также <xref:System.Object.GetHashCode>.</span><span class="sxs-lookup"><span data-stu-id="d5733-185">These synthesized methods include a copy constructor, the members of the <xref:System.IEquatable%601?displayProperty=nameWithType> interface, equality and inequality tests, and <xref:System.Object.GetHashCode>.</span></span> <span data-ttu-id="d5733-186">Для этой цели вы создадите `PrintMembers`.</span><span class="sxs-lookup"><span data-stu-id="d5733-186">For this purpose, you'll synthesize `PrintMembers`.</span></span> <span data-ttu-id="d5733-187">Можно также объявить собственный `ToString`, но `PrintMembers` предоставляет лучший вариант для сценариев наследования.</span><span class="sxs-lookup"><span data-stu-id="d5733-187">You could also declare your own `ToString`, but `PrintMembers` provides a better option for inheritance scenarios.</span></span> <span data-ttu-id="d5733-188">Чтобы предоставить собственную версию синтезированного метода, сигнатура должна соответствовать синтезированному методу.</span><span class="sxs-lookup"><span data-stu-id="d5733-188">To provide your own version of a synthesized method, the signature must match the synthesized method.</span></span>

<span data-ttu-id="d5733-189">Элемент `TempRecords` в выходных данных консоли не имеет смысла.</span><span class="sxs-lookup"><span data-stu-id="d5733-189">The `TempRecords` element in the console output isn't useful.</span></span> <span data-ttu-id="d5733-190">Он отображает тип, но больше ничего.</span><span class="sxs-lookup"><span data-stu-id="d5733-190">It displays the type, but nothing else.</span></span> <span data-ttu-id="d5733-191">Это поведение можно изменить, предоставив собственную реализацию синтезированного метода `PrintMembers`.</span><span class="sxs-lookup"><span data-stu-id="d5733-191">You can change this behavior by providing your own implementation of the synthesized `PrintMembers` method.</span></span> <span data-ttu-id="d5733-192">Сигнатура зависит от модификаторов, применяемых к объявлению `record`:</span><span class="sxs-lookup"><span data-stu-id="d5733-192">The signature depends on modifiers applied to the `record` declaration:</span></span>

- <span data-ttu-id="d5733-193">Если тип записи — `sealed`, то сигнатура — `private bool PrintMembers(StringBuilder builder);`</span><span class="sxs-lookup"><span data-stu-id="d5733-193">If a record type is `sealed`, the signature is `private bool PrintMembers(StringBuilder builder);`</span></span>
- <span data-ttu-id="d5733-194">Если тип записи не `sealed` и является производным от `object` (то есть базовая запись не объявляется), то сигнатура — `protected virtual bool PrintMembers(StringBuilder builder);`</span><span class="sxs-lookup"><span data-stu-id="d5733-194">If a record type isn't `sealed` and derives from `object` (that is, it doesn't declare a base record), the signature is `protected virtual bool PrintMembers(StringBuilder builder);`</span></span>
- <span data-ttu-id="d5733-195">Если тип записи не `sealed` и является производным от другой записи, то сигнатура — `protected override bool PrintMembers(StringBuilder builder);`</span><span class="sxs-lookup"><span data-stu-id="d5733-195">If a record type isn't `sealed` and derives from another record, the signature is `protected override bool PrintMembers(StringBuilder builder);`</span></span>

<span data-ttu-id="d5733-196">Эти правила проще всего осмыслить, поняв цель `PrintMembers`.</span><span class="sxs-lookup"><span data-stu-id="d5733-196">These rules are easiest to comprehend through understanding the purpose of `PrintMembers`.</span></span> <span data-ttu-id="d5733-197">`PrintMembers` добавляет сведения о каждом свойстве в типе записи в строку.</span><span class="sxs-lookup"><span data-stu-id="d5733-197">`PrintMembers` adds information about each property in a record type to a string.</span></span> <span data-ttu-id="d5733-198">По контракту базовые записи должны добавлять свои элементы в отображение. Предполагается, что производные элементы будут добавлять свои элементы.</span><span class="sxs-lookup"><span data-stu-id="d5733-198">The contract requires base records to add their members to the display and assumes derived members will add their members.</span></span> <span data-ttu-id="d5733-199">Каждый тип записи синтезирует переопределение `ToString`, которое выглядит следующим образом для `HeatingDegreeDays`:</span><span class="sxs-lookup"><span data-stu-id="d5733-199">Each record type synthesizes a `ToString` override that looks similar to the following example for `HeatingDegreeDays`:</span></span>

```csharp
public override string ToString()
{
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.Append("HeatingDegreeDays");
    stringBuilder.Append(" { ");
    if (PrintMembers(stringBuilder))
    {
        stringBuilder.Append(" ");
    }
    stringBuilder.Append("}");
    return stringBuilder.ToString();
}
```

<span data-ttu-id="d5733-200">Вы объявляете метод `PrintMembers` в записи `DegreeDays`, которая не выводит тип коллекции:</span><span class="sxs-lookup"><span data-stu-id="d5733-200">You declare a `PrintMembers` method in the `DegreeDays` record that doesn't print the type of the collection:</span></span>

:::code language="csharp" source="snippets/record-types/DegreeDays.cs" ID="AddPrintMembers":::

<span data-ttu-id="d5733-201">Сигнатура объявляет метод `virtual protected`, чтобы обеспечить соответствие версии компилятора.</span><span class="sxs-lookup"><span data-stu-id="d5733-201">The signature declares a `virtual protected` method to match the compiler's version.</span></span> <span data-ttu-id="d5733-202">Не беспокойтесь, если получаете неправильные методы доступа; язык применит правильную сигнатуру.</span><span class="sxs-lookup"><span data-stu-id="d5733-202">Don't worry if you get the accessors wrong; the language enforces the correct signature.</span></span> <span data-ttu-id="d5733-203">Если вы забыли правильные модификаторы для синтезированного метода, компилятор выдает предупреждения или ошибки, которые помогут получить правильную сигнатуру.</span><span class="sxs-lookup"><span data-stu-id="d5733-203">If you forget the correct modifiers for any synthesized method, the compiler issues warnings or errors that help you get the right signature.</span></span>

## <a name="non-destructive-mutation"></a><span data-ttu-id="d5733-204">Обратимое изменение</span><span class="sxs-lookup"><span data-stu-id="d5733-204">Non-destructive mutation</span></span>

<span data-ttu-id="d5733-205">Синтезированные элементы в позиционной записи не изменяют состояние записи.</span><span class="sxs-lookup"><span data-stu-id="d5733-205">The synthesized members in a positional record don't modify the state of the record.</span></span> <span data-ttu-id="d5733-206">Главная цель — упростить создание неизменяемых записей.</span><span class="sxs-lookup"><span data-stu-id="d5733-206">The goal is that you can more easily create immutable records.</span></span> <span data-ttu-id="d5733-207">Просмотрите предыдущие объявления для `HeatingDegreeDays` и `CoolingDegreeDays`.</span><span class="sxs-lookup"><span data-stu-id="d5733-207">Look again at the preceding declarations for `HeatingDegreeDays` and `CoolingDegreeDays`.</span></span> <span data-ttu-id="d5733-208">Добавленные элементы выполняют вычисления со значениями для записи, но не изменяют состояние.</span><span class="sxs-lookup"><span data-stu-id="d5733-208">The members added perform computations on the values for the record, but don't mutate state.</span></span> <span data-ttu-id="d5733-209">Позиционные записи упрощают создание неизменяемых ссылочных типов.</span><span class="sxs-lookup"><span data-stu-id="d5733-209">Positional records make it easier for you to create immutable reference types.</span></span>

<span data-ttu-id="d5733-210">Создание неизменяемых ссылочных типов означает, что необходимо использовать обратимое изменение.</span><span class="sxs-lookup"><span data-stu-id="d5733-210">Creating immutable reference types means you'll want to use non-destructive mutation.</span></span> <span data-ttu-id="d5733-211">Вы создаете новые экземпляры записей, аналогичные существующим экземплярам записей, используя [выражения `with`](../../language-reference/operators/with-expression.md).</span><span class="sxs-lookup"><span data-stu-id="d5733-211">You  create new record instances that are similar to existing record instances using [`with` expressions](../../language-reference/operators/with-expression.md).</span></span> <span data-ttu-id="d5733-212">Эти выражения являются конструкцией копии с дополнительными назначениями, которые изменяют копию.</span><span class="sxs-lookup"><span data-stu-id="d5733-212">These expressions are a copy construction with additional assignments that modify the copy.</span></span> <span data-ttu-id="d5733-213">Результатом является новый экземпляр записи, где каждое свойство было скопировано из существующей записи и при необходимости изменено.</span><span class="sxs-lookup"><span data-stu-id="d5733-213">The result is a new record instance where each property has been copied from the existing record and optionally modified.</span></span> <span data-ttu-id="d5733-214">Исходная запись не изменится.</span><span class="sxs-lookup"><span data-stu-id="d5733-214">The original record is unchanged.</span></span>

<span data-ttu-id="d5733-215">Давайте добавим в программу несколько функций, демонстрирующих выражения `with`.</span><span class="sxs-lookup"><span data-stu-id="d5733-215">Let's add a couple features to your program that demonstrate `with` expressions.</span></span> <span data-ttu-id="d5733-216">Во-первых, создадим новую запись для вычислений рост градусо-дней, используя те же данные.</span><span class="sxs-lookup"><span data-stu-id="d5733-216">First, let's create a new record to compute growing degree days using the same data.</span></span> <span data-ttu-id="d5733-217">*Рост градусо-дней* обычно использует 41 градус по Фаренгейту в качестве базового показателя и измеряет температуру выше базовой.</span><span class="sxs-lookup"><span data-stu-id="d5733-217">*Growing degree days* typically uses 41F as the baseline and measures temperatures above the baseline.</span></span> <span data-ttu-id="d5733-218">Чтобы использовать те же данные, можно создать новую запись, похожую на `coolingDegreeDays`, но с другой базовой температурой:</span><span class="sxs-lookup"><span data-stu-id="d5733-218">To use the same data, you can create a new record that is similar to the `coolingDegreeDays`, but with a different base temperature:</span></span>

:::code language="csharp" source="snippets/record-types/Program.cs" ID="GrowingDegreeDays":::

<span data-ttu-id="d5733-219">Вы можете сравнить число рассчитанных градусов с числом, вычисленным при более высокой базовой температуре.</span><span class="sxs-lookup"><span data-stu-id="d5733-219">You can compare the number of degrees computed to the numbers generated with a higher baseline temperature.</span></span> <span data-ttu-id="d5733-220">Помните, что записи являются *ссылочными типами*, и эти копии являются поверхностными копиями.</span><span class="sxs-lookup"><span data-stu-id="d5733-220">Remember that records are *reference types* and these copies are shallow copies.</span></span> <span data-ttu-id="d5733-221">Массив данных не копируется, но обе записи ссылаются на одни и те же данные.</span><span class="sxs-lookup"><span data-stu-id="d5733-221">The array for the data isn't copied, but both records refer to the same data.</span></span> <span data-ttu-id="d5733-222">Этот факт является преимуществом в еще одном сценарии.</span><span class="sxs-lookup"><span data-stu-id="d5733-222">That fact is an advantage in one other scenario.</span></span> <span data-ttu-id="d5733-223">Для растущих градусо-дней полезно отслеживать общее число за предыдущие 5 дней.</span><span class="sxs-lookup"><span data-stu-id="d5733-223">For growing degree days, it's useful to keep track of the total for the previous 5 days.</span></span> <span data-ttu-id="d5733-224">С помощью выражений `with` можно создавать новые записи с разными исходными данными.</span><span class="sxs-lookup"><span data-stu-id="d5733-224">You can create new records with different source data using `with` expressions.</span></span> <span data-ttu-id="d5733-225">Следующий код создает коллекцию этих сумм, а затем отображает значения:</span><span class="sxs-lookup"><span data-stu-id="d5733-225">The following code builds a collection of these accumulations, then displays the values:</span></span>

:::code language="csharp" source="snippets/record-types/Program.cs" ID="RunningFiveDayTotal":::

<span data-ttu-id="d5733-226">Можно также использовать выражения `with` для создания копий записей.</span><span class="sxs-lookup"><span data-stu-id="d5733-226">You can also use `with` expressions to create copies of records.</span></span> <span data-ttu-id="d5733-227">Не указывайте свойства между фигурными скобками в выражении `with`.</span><span class="sxs-lookup"><span data-stu-id="d5733-227">Don't specify any properties between the braces for the `with` expression.</span></span> <span data-ttu-id="d5733-228">Это означает, что нужно создать копию и не менять свойства:</span><span class="sxs-lookup"><span data-stu-id="d5733-228">That means create a copy, and don't change any properties:</span></span>

```csharp
var growingDegreeDaysCopy = growingDegreeDays with { };
```

<span data-ttu-id="d5733-229">Запустите готовое приложение, чтобы увидеть результаты.</span><span class="sxs-lookup"><span data-stu-id="d5733-229">Run the finished application to see the results.</span></span>

## <a name="summary"></a><span data-ttu-id="d5733-230">Сводка</span><span class="sxs-lookup"><span data-stu-id="d5733-230">Summary</span></span>

<span data-ttu-id="d5733-231">В этом учебнике мы рассмотрели несколько аспектов записей.</span><span class="sxs-lookup"><span data-stu-id="d5733-231">This tutorial showed several aspects of records.</span></span> <span data-ttu-id="d5733-232">Записи предоставляют краткий синтаксис для ссылочных типов, где главная цель — хранение данных.</span><span class="sxs-lookup"><span data-stu-id="d5733-232">Records provide concise syntax for reference types where the fundamental use is storing data.</span></span> <span data-ttu-id="d5733-233">Для объектно-ориентированных классов основным назначением является определение обязанностей.</span><span class="sxs-lookup"><span data-stu-id="d5733-233">For object-oriented classes, the fundamental use is defining responsibilities.</span></span> <span data-ttu-id="d5733-234">В этом учебнике вы узнали о *позиционных записях*, где можно использовать краткий синтаксис для объявления свойств записи, предназначенных только для инициализации.</span><span class="sxs-lookup"><span data-stu-id="d5733-234">This tutorial focused on *positional records*, where you can use a concise syntax to declare the init-only properties for a record.</span></span> <span data-ttu-id="d5733-235">Компилятор синтезирует несколько элементов записи для копирования и сравнения записей.</span><span class="sxs-lookup"><span data-stu-id="d5733-235">The compiler synthesizes several members of the record for copying and comparing records.</span></span> <span data-ttu-id="d5733-236">Вы можете добавить любые другие элементы, необходимые для ваших типов записей.</span><span class="sxs-lookup"><span data-stu-id="d5733-236">You can add any other members you need for your record types.</span></span> <span data-ttu-id="d5733-237">Вы можете создавать неизменяемые типы записей, зная, что ни один из созданных компилятором элементов не изменит состояние.</span><span class="sxs-lookup"><span data-stu-id="d5733-237">You can create immutable record types knowing that none of the compiler-generated members would mutate state.</span></span> <span data-ttu-id="d5733-238">Выражения `with` упрощают поддержку обратимого изменения.</span><span class="sxs-lookup"><span data-stu-id="d5733-238">And `with` expressions make it easy to support non-destructive mutation.</span></span>

<span data-ttu-id="d5733-239">Записи добавляют еще один способ определения типов.</span><span class="sxs-lookup"><span data-stu-id="d5733-239">Records add another way to define types.</span></span> <span data-ttu-id="d5733-240">Определения `class` используются для создания объектно-ориентированных иерархий, в которых основное внимание уделяется обязанностям и поведению объектов.</span><span class="sxs-lookup"><span data-stu-id="d5733-240">You use `class` definitions to create object-oriented hierarchies that focus on the responsibilities and behavior of objects.</span></span> <span data-ttu-id="d5733-241">Вы создаете типы `struct` для структур данных, которые хранят данные и достаточно малы для эффективного копирования.</span><span class="sxs-lookup"><span data-stu-id="d5733-241">You create `struct` types for data structures that store data and are small enough to copy efficiently.</span></span> <span data-ttu-id="d5733-242">Типы `record` создаются, когда требуется определить равенство и сравнение на основе значений, но не нужно копировать значения, а вы хотите использовать ссылочные переменные.</span><span class="sxs-lookup"><span data-stu-id="d5733-242">You create `record` types when you want value-based equality and comparison, don't want to copy values, and want to use reference variables.</span></span>

<span data-ttu-id="d5733-243">Полное описание записей можно узнать, прочитав [справочную статью по языку C# для типа записи](../../language-reference/builtin-types/record.md) и [предлагаемую спецификацию типа записи](~/_csharplang/proposals/csharp-9.0/records.md).</span><span class="sxs-lookup"><span data-stu-id="d5733-243">You can learn the complete description of records by reading the [C# language reference article for the record type)](../../language-reference/builtin-types/record.md) and the [proposed record type specification](~/_csharplang/proposals/csharp-9.0/records.md).</span></span>
