---
title: Начало работы с синтаксическими преобразованиями (API-интерфейсы Roslyn)
description: Введение в обходы, отправка запросов и прохождение деревьев синтаксиса.
ms.date: 06/01/2018
ms.custom: mvc
ms.openlocfilehash: f12727332256acd9bbe828b9149376080facd156
ms.sourcegitcommit: 652f62fc8f3ab6a264681b6eb5211ac7539bd115
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/30/2021
ms.locfileid: "105964827"
---
# <a name="get-started-with-syntax-transformation"></a><span data-ttu-id="124e2-103">Начало работы с синтаксическими преобразованиями</span><span class="sxs-lookup"><span data-stu-id="124e2-103">Get started with syntax transformation</span></span>

<span data-ttu-id="124e2-104">В основе этого руководства лежат концепции и методы, описанные в кратких руководствах [Начало работы с функциями синтаксического анализа](syntax-analysis.md) и [Начало работы с семантическим анализом](semantic-analysis.md).</span><span class="sxs-lookup"><span data-stu-id="124e2-104">This tutorial builds on concepts and techniques explored in the [Get started with syntax analysis](syntax-analysis.md) and [Get started with semantic analysis](semantic-analysis.md) quickstarts.</span></span> <span data-ttu-id="124e2-105">Если вы еще не изучили их, сделайте это до начала работы с этим руководством.</span><span class="sxs-lookup"><span data-stu-id="124e2-105">If you haven't already, you should complete those quickstarts before beginning this one.</span></span>

<span data-ttu-id="124e2-106">В этом кратком руководстве вы изучите методы создания и преобразования деревьев синтаксиса.</span><span class="sxs-lookup"><span data-stu-id="124e2-106">In this quickstart, you explore techniques for creating and transforming syntax trees.</span></span> <span data-ttu-id="124e2-107">Объединив их с методами, рассмотренными в предыдущих кратких руководствах, вы сможете создать рефакторинг в командной строке!</span><span class="sxs-lookup"><span data-stu-id="124e2-107">In combination with the techniques you learned in previous quickstarts, you create your first command-line refactoring!</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="immutability-and-the-net-compiler-platform"></a><span data-ttu-id="124e2-108">Неизменность и платформа компилятора .NET</span><span class="sxs-lookup"><span data-stu-id="124e2-108">Immutability and the .NET compiler platform</span></span>

<span data-ttu-id="124e2-109">**Неизменность** является фундаментальным принципом платформы компилятора .NET.</span><span class="sxs-lookup"><span data-stu-id="124e2-109">**Immutability** is a fundamental tenet of the .NET compiler platform.</span></span> <span data-ttu-id="124e2-110">Неизменяемые структуры данных невозможно изменить после их создания.</span><span class="sxs-lookup"><span data-stu-id="124e2-110">Immutable data structures can't be changed after they're created.</span></span> <span data-ttu-id="124e2-111">Такие структуры данных могут безопасно анализироваться и совместно использоваться несколькими объектами-получателями одновременно.</span><span class="sxs-lookup"><span data-stu-id="124e2-111">Immutable data structures can be safely shared and analyzed by multiple consumers simultaneously.</span></span> <span data-ttu-id="124e2-112">Не возникает опасности, что один объект-получатель непредсказуемо повлияет на работу других.</span><span class="sxs-lookup"><span data-stu-id="124e2-112">There's no danger that one consumer affects another in unpredictable ways.</span></span> <span data-ttu-id="124e2-113">Это означает, что анализатору не нужно применять блокировки или другие меры для поддержки параллелизма.</span><span class="sxs-lookup"><span data-stu-id="124e2-113">Your analyzer doesn't need locks or other concurrency measures.</span></span> <span data-ttu-id="124e2-114">Это правило применяется к деревьям синтаксиса, компиляциям, символам, семантическим моделям и любым другим структурам данных, с которыми вы можете работать.</span><span class="sxs-lookup"><span data-stu-id="124e2-114">This rule applies to syntax trees, compilations, symbols, semantic models, and every other data structure you encounter.</span></span> <span data-ttu-id="124e2-115">Вместо того чтобы изменять существующие структуры, интерфейсы API создают новые объекты с учетом требуемых изменений.</span><span class="sxs-lookup"><span data-stu-id="124e2-115">Instead of modifying existing structures, APIs create new objects based on specified differences to the old ones.</span></span> <span data-ttu-id="124e2-116">Чтобы применить этот принцип к деревьям синтаксиса, после преобразования следует создавать новые деревья.</span><span class="sxs-lookup"><span data-stu-id="124e2-116">You apply this concept to syntax trees to create new trees using transformations.</span></span>

## <a name="create-and-transform-trees"></a><span data-ttu-id="124e2-117">Создание и преобразование деревьев</span><span class="sxs-lookup"><span data-stu-id="124e2-117">Create and transform trees</span></span>

<span data-ttu-id="124e2-118">Для синтаксических преобразований можно выбрать одну из двух стратегий.</span><span class="sxs-lookup"><span data-stu-id="124e2-118">You choose one of two strategies for syntax transformations.</span></span> <span data-ttu-id="124e2-119">**Фабричные методы** лучше всего использовать при поиске конкретных узлов для замены или конкретных расположений, в которые нужно вставить новый код.</span><span class="sxs-lookup"><span data-stu-id="124e2-119">**Factory methods** are best used when you're searching for specific nodes to replace, or specific locations where you want to insert new code.</span></span> <span data-ttu-id="124e2-120">**Модули записи** лучше подходят, когда нужно просканировать весь проект и найти структуры кода, которые нужно заменить.</span><span class="sxs-lookup"><span data-stu-id="124e2-120">**Rewriters** are best when you want to scan an entire project for code patterns that you want to replace.</span></span>

### <a name="create-nodes-with-factory-methods"></a><span data-ttu-id="124e2-121">Создание узлов с помощью фабричных методов</span><span class="sxs-lookup"><span data-stu-id="124e2-121">Create nodes with factory methods</span></span>

<span data-ttu-id="124e2-122">В первом синтаксическом преобразовании демонстрируется использование фабричных методов.</span><span class="sxs-lookup"><span data-stu-id="124e2-122">The first syntax transformation demonstrates the factory methods.</span></span> <span data-ttu-id="124e2-123">Здесь вы замените инструкцию `using System.Collections;` инструкцией `using System.Collections.Generic;`.</span><span class="sxs-lookup"><span data-stu-id="124e2-123">You're going to replace a `using System.Collections;` statement with a `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="124e2-124">В этом примере показано, как создать объекты <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> с помощью фабричных методов <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="124e2-124">This example demonstrates how you create <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> objects using the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> factory methods.</span></span> <span data-ttu-id="124e2-125">Для каждого типа **узла**, **маркера** или **trivia** имеется фабричный метод, создающий экземпляр этого типа.</span><span class="sxs-lookup"><span data-stu-id="124e2-125">For each kind of **node**, **token**, or **trivia**, there's a factory method that creates an instance of that type.</span></span> <span data-ttu-id="124e2-126">Чтобы создать синтаксическое дерево, нужно иерархически создавать его узлы, начиная снизу.</span><span class="sxs-lookup"><span data-stu-id="124e2-126">You create syntax trees by composing nodes hierarchically in a bottom-up fashion.</span></span> <span data-ttu-id="124e2-127">Затем преобразуйте существующую программу, заменив существующие узлы только что созданным деревом.</span><span class="sxs-lookup"><span data-stu-id="124e2-127">Then, you'll transform the existing program by replacing existing nodes with the new tree you've created.</span></span>

<span data-ttu-id="124e2-128">Запустите Visual Studio и создайте проект C# для **автономного средства анализа кода**.</span><span class="sxs-lookup"><span data-stu-id="124e2-128">Start Visual Studio, and create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="124e2-129">В Visual Studio последовательно выберите **Файл** > **Создать** > **Проект**, чтобы открыть диалоговое окно "Новый проект".</span><span class="sxs-lookup"><span data-stu-id="124e2-129">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span> <span data-ttu-id="124e2-130">В разделе **Visual C#**  > **Расширяемость** выберите **Stand-Alone Code Analysis Tool** (Автономное средство анализа кода).</span><span class="sxs-lookup"><span data-stu-id="124e2-130">Under **Visual C#** > **Extensibility** choose a **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="124e2-131">Это краткое руководство содержит два примера проектов. Присвойте решению имя **SyntaxTransformationQuickStart**, а проекту — имя **ConstructionCS**.</span><span class="sxs-lookup"><span data-stu-id="124e2-131">This quickstart has two example projects, so name the solution **SyntaxTransformationQuickStart**, and name the project **ConstructionCS**.</span></span> <span data-ttu-id="124e2-132">Нажмите кнопку **ОК**.</span><span class="sxs-lookup"><span data-stu-id="124e2-132">Click **OK**.</span></span>

<span data-ttu-id="124e2-133">Этот проект использует методы класса <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> для создания объекта <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>, представляющего пространство имен `System.Collections.Generic`.</span><span class="sxs-lookup"><span data-stu-id="124e2-133">This project uses the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> class methods to construct a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> representing the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="124e2-134">Добавьте следующую директиву в начало `Program.cs`.</span><span class="sxs-lookup"><span data-stu-id="124e2-134">Add the following using directive to the top of the `Program.cs`.</span></span>

[!code-csharp[import the SyntaxFactory class](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#StaticUsings "import the Syntax Factory class and the System.Console class")]

<span data-ttu-id="124e2-135">Создайте **узлы синтаксиса имени** для построения дерева, представляющего инструкцию `using System.Collections.Generic;`.</span><span class="sxs-lookup"><span data-stu-id="124e2-135">You'll create **name syntax nodes** to build the tree that represents the `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="124e2-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> является базовым классом для четырех типов имен, применяющихся в C#.</span><span class="sxs-lookup"><span data-stu-id="124e2-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> is the base class for four types of names that appear in C#.</span></span> <span data-ttu-id="124e2-137">Сочетания этих четырех типов имен позволяют создать любое имя, которое может присутствовать в языке C#:</span><span class="sxs-lookup"><span data-stu-id="124e2-137">You compose these four types of names together to create any name that can appear in the C# language:</span></span>

* <span data-ttu-id="124e2-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> представляет имена простых одиночных идентификаторов, например `System` и `Microsoft`;</span><span class="sxs-lookup"><span data-stu-id="124e2-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>, which represents simple single identifier names like `System` and `Microsoft`.</span></span>
* <span data-ttu-id="124e2-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType> представляет имя универсального типа или метода, например `List<int>`;</span><span class="sxs-lookup"><span data-stu-id="124e2-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType>, which represents a generic type or method name such as `List<int>`.</span></span>
* <span data-ttu-id="124e2-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType> представляет полное имя в формате `<left-name>.<right-identifier-or-generic-name>`, например `System.IO`;</span><span class="sxs-lookup"><span data-stu-id="124e2-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType>, which represents a qualified name of the form `<left-name>.<right-identifier-or-generic-name>` such as `System.IO`.</span></span>
* <span data-ttu-id="124e2-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType> представляет выражение имени через внешний псевдоним сборки, например `LibraryV2::Foo`.</span><span class="sxs-lookup"><span data-stu-id="124e2-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType>, which represents a name using an assembly extern alias such a `LibraryV2::Foo`.</span></span>

<span data-ttu-id="124e2-142">Используйте метод <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)>, чтобы создать узел <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>.</span><span class="sxs-lookup"><span data-stu-id="124e2-142">You use the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> method to create a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> node.</span></span> <span data-ttu-id="124e2-143">Добавьте приведенный ниже код в метод `Main` объекта `Program.cs`:</span><span class="sxs-lookup"><span data-stu-id="124e2-143">Add the following code in your `Main` method in `Program.cs`:</span></span>

[!code-csharp[create the system identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateIdentifierName "Create and display the system name identifier")]

<span data-ttu-id="124e2-144">В представленном выше коде создается объект <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> и присваивается его переменной `name`.</span><span class="sxs-lookup"><span data-stu-id="124e2-144">The preceding code creates an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> object and assigns it to the variable `name`.</span></span> <span data-ttu-id="124e2-145">Многие API-интерфейсы Roslyn возвращают базовые классы, что упрощает работу со связанными типами.</span><span class="sxs-lookup"><span data-stu-id="124e2-145">Many of the Roslyn APIs return base classes to make it easier to work with related types.</span></span> <span data-ttu-id="124e2-146">Переменную `name` класса <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> можно использовать многократно при создании <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span><span class="sxs-lookup"><span data-stu-id="124e2-146">The variable `name`, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>, can be reused as you build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="124e2-147">Не используйте определение типа при создании образца.</span><span class="sxs-lookup"><span data-stu-id="124e2-147">Don't use type inference as you build the sample.</span></span> <span data-ttu-id="124e2-148">Этот шаг для проекта вы сделаете автоматическим.</span><span class="sxs-lookup"><span data-stu-id="124e2-148">You'll automate that step in this project.</span></span>

<span data-ttu-id="124e2-149">Итак, вы создали имя.</span><span class="sxs-lookup"><span data-stu-id="124e2-149">You've created the name.</span></span> <span data-ttu-id="124e2-150">Теперь нужно добавить в дерево больше узлов, создав <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span><span class="sxs-lookup"><span data-stu-id="124e2-150">Now, it's time to build more nodes into the tree by building a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="124e2-151">Новое дерево использует `name` в качестве левой части имени, а новый объект <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> в качестве пространства имен `Collections`, то есть в правой части <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span><span class="sxs-lookup"><span data-stu-id="124e2-151">The new tree uses `name` as the left of the name, and a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> for the `Collections` namespace as the right side of the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="124e2-152">Добавьте следующий код в файл `program.cs`:</span><span class="sxs-lookup"><span data-stu-id="124e2-152">Add the following code to `program.cs`:</span></span>

[!code-csharp[create the collections identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateQualifiedIdentifierName "Build the System.Collections identifier")]

<span data-ttu-id="124e2-153">Снова выполните этот код и проверьте результаты.</span><span class="sxs-lookup"><span data-stu-id="124e2-153">Run the code again, and see the results.</span></span> <span data-ttu-id="124e2-154">Вы создаете дерево узлов, представляющее код.</span><span class="sxs-lookup"><span data-stu-id="124e2-154">You're building a tree of nodes that represents code.</span></span> <span data-ttu-id="124e2-155">Точно так же вы создадите <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> для пространства имен `System.Collections.Generic`.</span><span class="sxs-lookup"><span data-stu-id="124e2-155">You'll continue this pattern to build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> for the namespace `System.Collections.Generic`.</span></span> <span data-ttu-id="124e2-156">Добавьте следующий код в файл `Program.cs`:</span><span class="sxs-lookup"><span data-stu-id="124e2-156">Add the following code to `Program.cs`:</span></span>

[!code-csharp[create the full identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateFullNamespace "Build the System.Collections.Generic identifier")]

<span data-ttu-id="124e2-157">Запустите программу еще раз и убедитесь, что вы создаете дерево для добавления кода.</span><span class="sxs-lookup"><span data-stu-id="124e2-157">Run the program again to see that you've built the tree for the code to add.</span></span>

### <a name="create-a-modified-tree"></a><span data-ttu-id="124e2-158">Создание измененного дерева</span><span class="sxs-lookup"><span data-stu-id="124e2-158">Create a modified tree</span></span>

<span data-ttu-id="124e2-159">На текущий момент вы создали небольшое синтаксическое дерево, которое содержит одну инструкцию.</span><span class="sxs-lookup"><span data-stu-id="124e2-159">You've built a small syntax tree that contains one statement.</span></span> <span data-ttu-id="124e2-160">API-интерфейсы для создания узлов отлично подходят для создания блоков небольшого размера, например для одного оператора.</span><span class="sxs-lookup"><span data-stu-id="124e2-160">The APIs to create new nodes are the right choice to create single statements or other small code blocks.</span></span> <span data-ttu-id="124e2-161">Но для более крупных блоков кода следует использовать методы, которые заменяют или добавляют узлы в существующее дерево.</span><span class="sxs-lookup"><span data-stu-id="124e2-161">However, to build larger blocks of code, you should use methods that replace nodes or insert nodes into an existing tree.</span></span> <span data-ttu-id="124e2-162">Не забывайте, что синтаксические деревья являются неизменяемыми.</span><span class="sxs-lookup"><span data-stu-id="124e2-162">Remember that syntax trees are immutable.</span></span> <span data-ttu-id="124e2-163">**API синтаксиса** не предоставляет механизмов для изменения существующего синтаксического дерева после его создания.</span><span class="sxs-lookup"><span data-stu-id="124e2-163">The **Syntax API** doesn't provide any mechanism for modifying an existing syntax tree after construction.</span></span> <span data-ttu-id="124e2-164">Но зато в нем есть методы, которые позволяют создавать новые деревья на основе существующих с определенными изменениями.</span><span class="sxs-lookup"><span data-stu-id="124e2-164">Instead, it provides methods that produce new trees based on changes to existing ones.</span></span> <span data-ttu-id="124e2-165">Методы `With*` определяются в конкретных классах, производных от <xref:Microsoft.CodeAnalysis.SyntaxNode>, или в методах расширения, объявленных в классе <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions>.</span><span class="sxs-lookup"><span data-stu-id="124e2-165">`With*` methods are defined in concrete classes that derive from <xref:Microsoft.CodeAnalysis.SyntaxNode> or in extension methods declared in the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions> class.</span></span> <span data-ttu-id="124e2-166">Эти методы позволяют создать узел, применяя изменения к дочерним свойствам существующего узла.</span><span class="sxs-lookup"><span data-stu-id="124e2-166">These methods create a new node by applying changes to an existing node's child properties.</span></span> <span data-ttu-id="124e2-167">Кроме того, можно использовать метод расширения <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> для замены узлов-потомков в поддереве.</span><span class="sxs-lookup"><span data-stu-id="124e2-167">Additionally, the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method can be used to replace a descendent node in a subtree.</span></span> <span data-ttu-id="124e2-168">Этот метод также позволяет обновить родительский узел, чтобы он указывал на новый дочерний элемент, и повторяет этот процесс вверх по всему дереву. Этот процесс называется _повторным прохождением_.</span><span class="sxs-lookup"><span data-stu-id="124e2-168">This method also updates the parent to point to the newly created child and repeats this process up the entire tree - a process known as _re-spinning_ the tree.</span></span>

<span data-ttu-id="124e2-169">На следующем шаге вы создадите дерево, которое представляет целую (небольшую) программу и измените его.</span><span class="sxs-lookup"><span data-stu-id="124e2-169">The next step is to create a tree that represents an entire (small) program and then modify it.</span></span> <span data-ttu-id="124e2-170">Добавьте следующий код в начало класса `Program`:</span><span class="sxs-lookup"><span data-stu-id="124e2-170">Add the following code to the beginning of the `Program` class:</span></span>

[!code-csharp[create a parse tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#DeclareSampleCode "Create a tree that represents a small program")]

> [!NOTE]
> <span data-ttu-id="124e2-171">В примере кода используется пространство имен `System.Collections`, а не `System.Collections.Generic`.</span><span class="sxs-lookup"><span data-stu-id="124e2-171">The example code uses the `System.Collections` namespace and not the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="124e2-172">Добавьте следующий код в нижнюю часть метода `Main`, чтобы выполнить синтаксический анализ текста и создать дерево:</span><span class="sxs-lookup"><span data-stu-id="124e2-172">Next, add the following code to the bottom of the `Main` method to parse the text and create a tree:</span></span>

[!code-csharp[create a parse tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateParseTree "Create a tree that represents a small program")]

<span data-ttu-id="124e2-173">В этом примере используется метод <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType>, чтобы заменить имя в узле <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> тем именем, созданном в предыдущем фрагменте кода.</span><span class="sxs-lookup"><span data-stu-id="124e2-173">This example uses the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> method to replace the name in a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node with the one constructed in the preceding code.</span></span>

<span data-ttu-id="124e2-174">Создайте узел <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> с помощью метода <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)>, чтобы заменить имя `System.Collections` тем именем, которое создано в предыдущем фрагменте кода.</span><span class="sxs-lookup"><span data-stu-id="124e2-174">Create a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node using the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> method to update the `System.Collections` name with the name you created in the preceding code.</span></span> <span data-ttu-id="124e2-175">Добавьте следующий код в конец метода `Main`:</span><span class="sxs-lookup"><span data-stu-id="124e2-175">Add the following code to the bottom of the `Main` method:</span></span>

[!code-csharp[create a new subtree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#BuildNewUsing "Create the subtree with the replaced namespace")]

<span data-ttu-id="124e2-176">Запустите программу и внимательно изучите выходные данные.</span><span class="sxs-lookup"><span data-stu-id="124e2-176">Run the program and look carefully at the output.</span></span> <span data-ttu-id="124e2-177">`newUsing` не помещается в корневой узел дерева.</span><span class="sxs-lookup"><span data-stu-id="124e2-177">The `newUsing` hasn't been placed in the root tree.</span></span> <span data-ttu-id="124e2-178">Исходное дерево не изменяется.</span><span class="sxs-lookup"><span data-stu-id="124e2-178">The original tree hasn't been changed.</span></span>

<span data-ttu-id="124e2-179">Добавьте следующий код, используя метод расширения <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A>, чтобы создать новое дерево.</span><span class="sxs-lookup"><span data-stu-id="124e2-179">Add the following code using the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method to create a new tree.</span></span> <span data-ttu-id="124e2-180">Новое дерево формируется путем замены существующего импорта обновленным узлом `newUsing`.</span><span class="sxs-lookup"><span data-stu-id="124e2-180">The new tree is the result of replacing the existing import with the updated `newUsing` node.</span></span> <span data-ttu-id="124e2-181">Назначьте это новое дерево существующей переменной `root`:</span><span class="sxs-lookup"><span data-stu-id="124e2-181">You assign this new tree to the existing `root` variable:</span></span>

[!code-csharp[create a new root tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#TransformTree "Create the transformed root tree with the replaced namespace")]

<span data-ttu-id="124e2-182">Запустите программу еще раз.</span><span class="sxs-lookup"><span data-stu-id="124e2-182">Run the program again.</span></span> <span data-ttu-id="124e2-183">На этот раз дерево правильно импортирует пространство имен `System.Collections.Generic`.</span><span class="sxs-lookup"><span data-stu-id="124e2-183">This time the tree now correctly imports the `System.Collections.Generic` namespace.</span></span>

### <a name="transform-trees-using-syntaxrewriters"></a><span data-ttu-id="124e2-184">Преобразование деревьев с помощью `SyntaxRewriters`</span><span class="sxs-lookup"><span data-stu-id="124e2-184">Transform trees using `SyntaxRewriters`</span></span>

<span data-ttu-id="124e2-185">Методы `With*` и <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> удобны для преобразования отдельных ветвей в синтаксическом дереве.</span><span class="sxs-lookup"><span data-stu-id="124e2-185">The `With*` and <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> methods provide convenient means to transform individual branches of a syntax tree.</span></span> <span data-ttu-id="124e2-186">Класс <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> выполняет множественные преобразования синтаксического дерева.</span><span class="sxs-lookup"><span data-stu-id="124e2-186">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class performs multiple transformations on a syntax tree.</span></span> <span data-ttu-id="124e2-187">Класс <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> является подклассом <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="124e2-187">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class is a subclass of <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="124e2-188"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> применяет преобразование к конкретному типу объекта <xref:Microsoft.CodeAnalysis.SyntaxNode>.</span><span class="sxs-lookup"><span data-stu-id="124e2-188">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> applies a transformation to a specific type of <xref:Microsoft.CodeAnalysis.SyntaxNode>.</span></span> <span data-ttu-id="124e2-189">Преобразования можно применить к нескольким типам объектов <xref:Microsoft.CodeAnalysis.SyntaxNode> везде, где они встречаются в синтаксическом дереве.</span><span class="sxs-lookup"><span data-stu-id="124e2-189">You can apply transformations to multiple types of <xref:Microsoft.CodeAnalysis.SyntaxNode> objects wherever they appear in a syntax tree.</span></span> <span data-ttu-id="124e2-190">В втором проекте в этом кратком руководстве выполняется рефакторинг в командной строке, при котором удаляются явные типы из объявлений локальных переменных везде, где используются определения типа.</span><span class="sxs-lookup"><span data-stu-id="124e2-190">The second project in this quickstart creates a command-line refactoring that removes explicit types in local variable declarations anywhere that type inference could be used.</span></span>

<span data-ttu-id="124e2-191">Создайте новый проект C# для **автономного средства анализа кода**.</span><span class="sxs-lookup"><span data-stu-id="124e2-191">Create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="124e2-192">В Visual Studio щелкните правой кнопкой мыши узел решения `SyntaxTransformationQuickStart`.</span><span class="sxs-lookup"><span data-stu-id="124e2-192">In Visual Studio, right-click the `SyntaxTransformationQuickStart` solution node.</span></span> <span data-ttu-id="124e2-193">Выберите **Добавить** > **Новый проект**, чтобы открыть диалоговое окно **Новый проект**.</span><span class="sxs-lookup"><span data-stu-id="124e2-193">Choose **Add** > **New Project** to display the **New Project dialog**.</span></span> <span data-ttu-id="124e2-194">В разделе **Visual C#**  > **Расширяемость** выберите **Автономное средство анализа кода**.</span><span class="sxs-lookup"><span data-stu-id="124e2-194">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="124e2-195">Присвойте проекту имя `TransformationCS` и нажмите кнопку "ОК".</span><span class="sxs-lookup"><span data-stu-id="124e2-195">Name your project `TransformationCS` and click OK.</span></span>

<span data-ttu-id="124e2-196">На первом шаге создается класс, производный от <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter>, чтобы выполнять преобразования.</span><span class="sxs-lookup"><span data-stu-id="124e2-196">The first step is to create a class that derives from <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> to perform your transformations.</span></span> <span data-ttu-id="124e2-197">Добавьте в проект новый файл класса.</span><span class="sxs-lookup"><span data-stu-id="124e2-197">Add a new class file to the project.</span></span> <span data-ttu-id="124e2-198">В Visual Studio выберите **Проект** > **Добавить класс...** . В диалоговом окне **Добавление нового элемента** введите имя файла `TypeInferenceRewriter.cs`.</span><span class="sxs-lookup"><span data-stu-id="124e2-198">In Visual Studio, choose **Project** > **Add Class...**. In the **Add New Item** dialog type `TypeInferenceRewriter.cs` as the filename.</span></span>

<span data-ttu-id="124e2-199">В файл `TypeInferenceRewriter.cs` добавьте следующие директивы using:</span><span class="sxs-lookup"><span data-stu-id="124e2-199">Add the following using directives to the `TypeInferenceRewriter.cs` file:</span></span>

[!code-csharp[add necessary usings](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#AddUsings "Add required usings")]

<span data-ttu-id="124e2-200">Теперь укажите класс `TypeInferenceRewriter` как расширение класса <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter>:</span><span class="sxs-lookup"><span data-stu-id="124e2-200">Next, make the `TypeInferenceRewriter` class extend the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> class:</span></span>

[!code-csharp[add base class](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BaseClass "Add base class")]

<span data-ttu-id="124e2-201">Добавьте следующий код, чтобы объявить частное поле только для чтения, в котором будет храниться объект <xref:Microsoft.CodeAnalysis.SemanticModel>, и инициализируйте его в конструкторе.</span><span class="sxs-lookup"><span data-stu-id="124e2-201">Add the following code to declare a private read-only field to hold a <xref:Microsoft.CodeAnalysis.SemanticModel> and initialize it in the constructor.</span></span> <span data-ttu-id="124e2-202">Это поле потребуется вам позже, чтобы указать, где можно использовать определение типа:</span><span class="sxs-lookup"><span data-stu-id="124e2-202">You will need this field later on to determine where type inference can be used:</span></span>

[!code-csharp[initialize members](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Construction "Declare and initialize member variables")]

<span data-ttu-id="124e2-203">Переопределите метод <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)>:</span><span class="sxs-lookup"><span data-stu-id="124e2-203">Override the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method:</span></span>

```csharp
public override SyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
{

}
```

> [!NOTE]
> <span data-ttu-id="124e2-204">Многие API-интерфейсы Roslyn объявляют типы возвращаемых значений, которые являются базовыми классами для фактически возвращаемых типов среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="124e2-204">Many of the Roslyn APIs declare return types that are base classes of the actual runtime types returned.</span></span> <span data-ttu-id="124e2-205">Во многих сценариях один тип узла может быть заменен другим типом или даже удален.</span><span class="sxs-lookup"><span data-stu-id="124e2-205">In many scenarios, one kind of node may be replaced by another kind of node entirely - or even removed.</span></span> <span data-ttu-id="124e2-206">В этом примере метод <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> возвращает <xref:Microsoft.CodeAnalysis.SyntaxNode>, а не тип, производный от <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>.</span><span class="sxs-lookup"><span data-stu-id="124e2-206">In this example, the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method returns a <xref:Microsoft.CodeAnalysis.SyntaxNode>, instead of the derived type of   <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>.</span></span> <span data-ttu-id="124e2-207">Этот модуль записи возвращает новый узел <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>, основанный на существующем узле.</span><span class="sxs-lookup"><span data-stu-id="124e2-207">This rewriter returns a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> node based on the existing one.</span></span>

<span data-ttu-id="124e2-208">В этом кратком руководстве рассматриваются объявления локальных переменных.</span><span class="sxs-lookup"><span data-stu-id="124e2-208">This quickstart handles local variable declarations.</span></span> <span data-ttu-id="124e2-209">Вы можете добавить в пример кода другие объявления, например циклов `foreach`, циклов `for`, выражений LINQ и лямбда-выражений.</span><span class="sxs-lookup"><span data-stu-id="124e2-209">You could extend it to other declarations such as `foreach` loops, `for` loops, LINQ expressions, and lambda expressions.</span></span> <span data-ttu-id="124e2-210">Также этот модуль записи преобразует объявления только в простейшем формате:</span><span class="sxs-lookup"><span data-stu-id="124e2-210">Furthermore this rewriter will only transform declarations of the simplest form:</span></span>

```csharp
Type variable = expression;
```

<span data-ttu-id="124e2-211">Если вы хотите поэкспериментировать самостоятельно, в готовый пример попробуйте добавить объявления переменных следующих типов:</span><span class="sxs-lookup"><span data-stu-id="124e2-211">If you want to explore on your own, consider extending the finished sample for these types of variable declarations:</span></span>

```csharp
// Multiple variables in a single declaration.
Type variable1 = expression1,
     variable2 = expression2;
// No initializer.
Type variable;
```

<span data-ttu-id="124e2-212">Добавьте следующий код в текст метода `VisitLocalDeclarationStatement`, чтобы пропускать перезапись этих форм объявления:</span><span class="sxs-lookup"><span data-stu-id="124e2-212">Add the following code to the body of the `VisitLocalDeclarationStatement` method to skip rewriting these forms of declarations:</span></span>

[!code-csharp[exclude other declarations](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Exclusions "Exclude variables declarations not processed by this sample")]

<span data-ttu-id="124e2-213">Этот метод указывает, что перезапись не происходит, возвращая неизмененное значение параметра `node`.</span><span class="sxs-lookup"><span data-stu-id="124e2-213">The method indicates that no rewriting takes place by returning the `node` parameter unmodified.</span></span> <span data-ttu-id="124e2-214">Если ни одно из выражений `if` не принимает значение true, этот узел представляет возможное объявление с инициализацией.</span><span class="sxs-lookup"><span data-stu-id="124e2-214">If neither of those `if` expressions are true, the node represents a possible declaration with initialization.</span></span> <span data-ttu-id="124e2-215">Добавьте следующие инструкции, чтобы извлечь имя типа, указанное в объявлении, и связать его с помощью поля <xref:Microsoft.CodeAnalysis.SemanticModel> для получения символа типа:</span><span class="sxs-lookup"><span data-stu-id="124e2-215">Add these statements to extract the type name specified in the declaration and bind it using the <xref:Microsoft.CodeAnalysis.SemanticModel> field to obtain a type symbol:</span></span>

[!code-csharp[extract type name](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#ExtractTypeSymbol "Extract the type name specified by the declaration")]

<span data-ttu-id="124e2-216">Теперь, чтобы связать выражение инициализатора, добавьте такое выражение:</span><span class="sxs-lookup"><span data-stu-id="124e2-216">Now, add this statement to bind the initializer expression:</span></span>

[!code-csharp[bind initializer](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BindInitializer "Bind the initializer expressions")]

<span data-ttu-id="124e2-217">Наконец, добавьте следующую инструкцию `if`, чтобы заменять существующее имя типа ключевым словом `var`, если тип выражения инициализатора соответствует указанному типу:</span><span class="sxs-lookup"><span data-stu-id="124e2-217">Finally, add the following `if` statement to replace the existing type name with the `var` keyword if the type of the initializer expression matches the type specified:</span></span>

[!code-csharp[ReplaceNode](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#ReplaceNode "Replace the initializer node")]

<span data-ttu-id="124e2-218">Условная запись нужна потому, что объявление может приводить выражение инициализатора к базовому классу или интерфейсу.</span><span class="sxs-lookup"><span data-stu-id="124e2-218">The conditional is required because the declaration may cast the initializer expression to a base class or interface.</span></span> <span data-ttu-id="124e2-219">Если вам потребуется такое поведение, типы слева и справа от оператора назначения не будут совпадать.</span><span class="sxs-lookup"><span data-stu-id="124e2-219">If that's desired, the types on the left and right-hand side of the assignment don't match.</span></span> <span data-ttu-id="124e2-220">Удаление явного указания типа в таких случаях изменит семантику программы.</span><span class="sxs-lookup"><span data-stu-id="124e2-220">Removing the explicit type in these cases would change the semantics of a program.</span></span> <span data-ttu-id="124e2-221">`var` задается как идентификатор, а не ключевое слово, так как `var` является контекстным ключевым словом.</span><span class="sxs-lookup"><span data-stu-id="124e2-221">`var` is specified as an identifier rather than a keyword because `var` is a contextual keyword.</span></span> <span data-ttu-id="124e2-222">Начальные и конечные элементы trivia (пробелы) передаются из старого имени типа в ключевое слово `var`, чтобы сохранить вертикальные пробелы и отступы.</span><span class="sxs-lookup"><span data-stu-id="124e2-222">The leading and trailing trivia (white space) are transferred from the old type name to the `var` keyword to maintain vertical white space and indentation.</span></span> <span data-ttu-id="124e2-223">Гораздо проще использовать `ReplaceNode` вместо `With*` для преобразования <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>, так как имя типа по сути является внучатым элементом для оператора объявления.</span><span class="sxs-lookup"><span data-stu-id="124e2-223">It's simpler to use `ReplaceNode` rather than `With*` to transform the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> because the type name is actually the grandchild of the declaration statement.</span></span>

<span data-ttu-id="124e2-224">Итак, вы завершили создание `TypeInferenceRewriter`.</span><span class="sxs-lookup"><span data-stu-id="124e2-224">You've finished the `TypeInferenceRewriter`.</span></span> <span data-ttu-id="124e2-225">Теперь вернитесь к файлу `Program.cs`, чтобы завершить работу с этим примером.</span><span class="sxs-lookup"><span data-stu-id="124e2-225">Now return to your `Program.cs` file to finish the example.</span></span> <span data-ttu-id="124e2-226">Создайте тест <xref:Microsoft.CodeAnalysis.Compilation> и получите из него <xref:Microsoft.CodeAnalysis.SemanticModel>.</span><span class="sxs-lookup"><span data-stu-id="124e2-226">Create a test <xref:Microsoft.CodeAnalysis.Compilation> and obtain the <xref:Microsoft.CodeAnalysis.SemanticModel> from it.</span></span> <span data-ttu-id="124e2-227">Используйте этот <xref:Microsoft.CodeAnalysis.SemanticModel> для проверки `TypeInferenceRewriter`.</span><span class="sxs-lookup"><span data-stu-id="124e2-227">Use that <xref:Microsoft.CodeAnalysis.SemanticModel> to try your `TypeInferenceRewriter`.</span></span> <span data-ttu-id="124e2-228">Это будет последний шаг процедуры.</span><span class="sxs-lookup"><span data-stu-id="124e2-228">You'll do this step last.</span></span> <span data-ttu-id="124e2-229">Одновременно с этим объявите переменную, которая будет выполнять роль заполнителя для тестовой компиляции:</span><span class="sxs-lookup"><span data-stu-id="124e2-229">In the meantime declare a placeholder variable representing your test compilation:</span></span>

[!code-csharp[DeclareCompilation](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#DeclareTestCompilation "Declare the test compilation")]

<span data-ttu-id="124e2-230">Подождите пару секунд, и в этой строке появится волнистая линия, которая обозначает ошибку: метод `CreateTestCompilation` не существует.</span><span class="sxs-lookup"><span data-stu-id="124e2-230">After pausing a moment, you should see an error squiggle appear reporting that no `CreateTestCompilation` method exists.</span></span> <span data-ttu-id="124e2-231">Нажмите клавиши **CTRL+точка**, чтобы открыть меню лампочки. Затем нажмите клавишу "ВВОД", чтобы вызвать команду **Сгенерировать заглушку метода**.</span><span class="sxs-lookup"><span data-stu-id="124e2-231">Press **Ctrl+Period** to open the light-bulb and then press Enter to invoke the **Generate Method Stub** command.</span></span> <span data-ttu-id="124e2-232">Эта команда создаст заглушку для метода `CreateTestCompilation` в классе `Program`.</span><span class="sxs-lookup"><span data-stu-id="124e2-232">This command will generate a method stub for the `CreateTestCompilation` method in the `Program` class.</span></span> <span data-ttu-id="124e2-233">Этот метод вы заполните позднее:</span><span class="sxs-lookup"><span data-stu-id="124e2-233">You'll come back to fill in this method later:</span></span>

![Создание метода C# по данным использования](./media/syntax-transformation/generate-from-usage.png)

<span data-ttu-id="124e2-235&quot;>Создайте следующий код, который последовательно перебирает все <xref:Microsoft.CodeAnalysis.SyntaxTree> в тесте <xref:Microsoft.CodeAnalysis.Compilation>.</span><span class=&quot;sxs-lookup&quot;><span data-stu-id=&quot;124e2-235&quot;>Write the following code to iterate over each <xref:Microsoft.CodeAnalysis.SyntaxTree> in the test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id=&quot;124e2-236&quot;>Для каждого из них инициализируйте новый `TypeInferenceRewriter` с классом <xref:Microsoft.CodeAnalysis.SemanticModel> для этого дерева:</span><span class=&quot;sxs-lookup&quot;><span data-stu-id=&quot;124e2-236&quot;>For each one, initialize a new `TypeInferenceRewriter` with the <xref:Microsoft.CodeAnalysis.SemanticModel> for that tree:</span></span>

[!code-csharp[IterateTrees](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#IterateTrees &quot;Iterate all the source trees in the test compilation")]

<span data-ttu-id="124e2-237">В созданной инструкции `foreach` добавьте приведенный ниже код, чтобы выполнить преобразование для каждого исходного дерева.</span><span class="sxs-lookup"><span data-stu-id="124e2-237">Inside the `foreach` statement you created, add the following code to perform the transformation on each source tree.</span></span> <span data-ttu-id="124e2-238">Этот код проверяет, были ли внесены правки, и если были — записывает преобразованное дерево.</span><span class="sxs-lookup"><span data-stu-id="124e2-238">This code conditionally writes out the new transformed tree if any edits were made.</span></span> <span data-ttu-id="124e2-239">Модуль записи должен изменять дерево только в том случае, если он встречает одно или несколько объявлений локальных переменных, которые можно упростить с помощью определения типа:</span><span class="sxs-lookup"><span data-stu-id="124e2-239">Your rewriter should only modify a tree if it encounters one or more local variable declarations that could be simplified using type inference:</span></span>

[!code-csharp[TransformTrees](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#TransformTrees "Transform and save any trees that are modified by the rewriter")]

<span data-ttu-id="124e2-240">Вы увидите волнистые линии под фрагментом кода `File.WriteAllText`.</span><span class="sxs-lookup"><span data-stu-id="124e2-240">You should see squiggles under the `File.WriteAllText` code.</span></span> <span data-ttu-id="124e2-241">Выберите значок лампочки и добавьте необходимую инструкцию `using System.IO;`.</span><span class="sxs-lookup"><span data-stu-id="124e2-241">Select the light bulb, and add the necessary `using System.IO;` statement.</span></span>

<span data-ttu-id="124e2-242">Вы почти закончили!</span><span class="sxs-lookup"><span data-stu-id="124e2-242">You're almost done!</span></span> <span data-ttu-id="124e2-243">Осталось только последнее действие: создать тест <xref:Microsoft.CodeAnalysis.Compilation>.</span><span class="sxs-lookup"><span data-stu-id="124e2-243">There's one step left: creating a test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="124e2-244">Так как вы еще не использовали определение типа в этом кратком руководстве, это будет отличным тестовым случаем.</span><span class="sxs-lookup"><span data-stu-id="124e2-244">Since you haven't been using type inference at all during this quickstart, it would have made a perfect test case.</span></span> <span data-ttu-id="124e2-245">К сожалению, создание компиляции из файла проекта C# не входит в это пошаговое руководство.</span><span class="sxs-lookup"><span data-stu-id="124e2-245">Unfortunately, creating a Compilation from a C# project file is beyond the scope of this walkthrough.</span></span> <span data-ttu-id="124e2-246">Но вы можете применить обходной путь, если внимательно выполняли все инструкции.</span><span class="sxs-lookup"><span data-stu-id="124e2-246">But fortunately, if you've been following instructions carefully, there's hope.</span></span> <span data-ttu-id="124e2-247">Замените содержимое метода `CreateTestCompilation` следующим кодом.</span><span class="sxs-lookup"><span data-stu-id="124e2-247">Replace the contents of the `CreateTestCompilation` method with the following code.</span></span> <span data-ttu-id="124e2-248">Этот код позволяет создать компиляцию теста, которая очень удачно совпадает с проектом, описанным в этом кратком руководстве:</span><span class="sxs-lookup"><span data-stu-id="124e2-248">It creates a test compilation that coincidentally matches the project described in this quickstart:</span></span>

[!code-csharp[CreateTestCompilation](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#CreateTestCompilation "Create a test compilation using the code written for this quickstart.")]

<span data-ttu-id="124e2-249">Скрестите пальцы и запустите проект.</span><span class="sxs-lookup"><span data-stu-id="124e2-249">Cross your fingers and run the project.</span></span> <span data-ttu-id="124e2-250">В Visual Studio выберите **Отладка** > **Начать отладку**.</span><span class="sxs-lookup"><span data-stu-id="124e2-250">In Visual Studio, choose **Debug** > **Start Debugging**.</span></span> <span data-ttu-id="124e2-251">В Visual Studio появится сообщение о том, что файлы в проекте были изменены.</span><span class="sxs-lookup"><span data-stu-id="124e2-251">You should be prompted by Visual Studio that the files in your project have changed.</span></span> <span data-ttu-id="124e2-252">Щелкните **Да для всех**, чтобы повторно загрузить все измененные файлы.</span><span class="sxs-lookup"><span data-stu-id="124e2-252">Click "**Yes to All**" to reload the modified files.</span></span> <span data-ttu-id="124e2-253">Изучите их и поразитесь, что вам удалось сделать.</span><span class="sxs-lookup"><span data-stu-id="124e2-253">Examine them to observe your awesomeness.</span></span> <span data-ttu-id="124e2-254">Обратите особое внимание, насколько чище выглядит код без ненужных явных описателей типов.</span><span class="sxs-lookup"><span data-stu-id="124e2-254">Note how much cleaner the code looks without all those explicit and redundant type specifiers.</span></span>

<span data-ttu-id="124e2-255">Поздравляем!</span><span class="sxs-lookup"><span data-stu-id="124e2-255">Congratulations!</span></span> <span data-ttu-id="124e2-256">С помощью **API-интерфейсов компилятора** вы создали собственное средство для рефакторинга, которое ищет определенные синтаксические выражения во всех файлах проекта C#, анализирует и преобразует семантику исходного кода по указанным шаблонам.</span><span class="sxs-lookup"><span data-stu-id="124e2-256">You've used the **Compiler APIs** to write your own refactoring that searches all files in a C# project for certain syntactic patterns, analyzes the semantics of source code that matches those patterns, and transforms it.</span></span> <span data-ttu-id="124e2-257">Теперь вы официально считаетесь разработчиком средства рефакторинга!</span><span class="sxs-lookup"><span data-stu-id="124e2-257">You're now officially a refactoring author!</span></span>
