---
title: Методы | Руководство по C#
description: Общие сведения о методах, их параметрах и возвращаемых значениях
ms.technology: csharp-fundamentals
ms.date: 03/16/2021
ms.assetid: 577a8527-1081-4b36-9b9e-0685b6553c6e
ms.openlocfilehash: 5d7f654ca268deff4a0c8e69b76e4d636d2f495e
ms.sourcegitcommit: 1dbe25ff484a02025d5c34146e517c236f7161fb
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "104652936"
---
# <a name="methods-in-c"></a>Методы в (C#)

Метод — это блок кода, содержащий ряд инструкций. Программа инициирует выполнение инструкций, вызывая метод и указывая все аргументы, необходимые для этого метода. В C# все инструкции выполняются в контексте метода. Метод `Main` является точкой входа для каждого приложения C#, и вызывается общеязыковой средой выполнения (CLR) при запуске программы.

> [!NOTE]
> В этом разделе рассматриваются названные методы. Сведения об анонимных функциях см. в разделе [Анонимные функции](programming-guide/statements-expressions-operators/anonymous-functions.md).

<a name="signatures"></a>

## <a name="method-signatures"></a>Сигнатуры методов

Методы объявляются в `class` или `struct`, для чего указывается следующее:

- Уровень доступа (необязательно), например `public` или `private`. Значение по умолчанию — `private`.
- Необязательные модификаторы, например `abstract` или `sealed`.
- Возвращаемое значение или `void`, если у метода его нет.
- Имя метода.
- Любые параметры методов. Параметры метода заключаются в скобки и разделяются запятыми. Пустые скобки указывают, что параметры методу не требуются.

Вместе все эти части формируют сигнатуру метода.

> [!IMPORTANT]
> Тип возврата метода не является частью сигнатуры метода в целях перегрузки метода. Однако он является частью сигнатуры метода при определении совместимости между делегатом и методом, который он указывает.

В следующем примере определяется класс с именем `Motorcycle`, содержащий пять методов:

[!code-csharp[csSnippets.Methods#40](../../samples/snippets/csharp/concepts/methods/methods40.cs#40)]

Обратите внимание на то, что класс `Motorcycle` включает перегруженный метод `Drive`. Оба метода называются одинаково, но различаются по типам параметров.

<a name="invocation"></a>

## <a name="method-invocation"></a>Вызов метода

Можно использовать метод *instance* или *static*. Для того чтобы вызвать метод instance, необходимо создать экземпляр объекта и вызвать для него метод; метод instance будет применен к этому экземпляру и его данным. Статический метод вызывается путем ссылки на имя типа, к которому относится метод; статические методы не работают с данными экземпляров. При попытке вызвать статический метод с помощью экземпляра объекта возникает ошибка компилятора.

Вызов метода аналогичен доступу к полю. После имени объекта (при вызове метода экземпляра) или имени типа (при вызове метода `static`) добавьте точку, имя метода и круглые скобки. Аргументы перечисляются в этих скобках и разделяются запятыми.

Определение метода задает имена и типы всех необходимых параметров. Когда вызывающий код вызывает метод, он предоставляет конкретные значения, называемые аргументами, для каждого параметра. Аргументы должны быть совместимы с типом параметра, но имя аргумента (если оно используется в вызывающем коде) может не совпадать с именем параметра, указанным в методе. В следующем примере метод `Square` имеет один параметр типа `int` с именем *i*. Первый вызов метода передает методу `Square` переменную типа `int` с именем *num*; второй — числовую константу, а третий — выражение.

[!code-csharp[csSnippets.Methods#74](../../samples/snippets/csharp/concepts/methods/params74.cs#74)]

В наиболее распространенной форме вызова методов используются позиционные аргументы; они передаются в том же порядке, что и параметры метода. Таким образом, методы класса `Motorcycle` могут вызываться, как показано в следующем примере. Например, вызов метода `Drive` включает два аргумента, которые соответствуют двум параметрам в синтаксисе метода. Первый становится значением параметра `miles`, а второй — значением параметра `speed`.

[!code-csharp[csSnippets.Methods#41](../../samples/snippets/csharp/concepts/methods/methods40.cs#41)]

При вызове метода вместо позиционных аргументов можно также использовать *именованные аргументы*. При использовании именованных аргументов необходимо указать имя параметра, двоеточие (":"), а затем аргумент. Аргументы для метода могут отображаться в любом порядке, при условии, что все обязательные аргументы присутствуют. В следующем примере для вызова метода `TestMotorcycle.Drive` используются именованные аргументы. В этом примере именованные аргументы передаются из списка параметров метода в обратном порядке.

[!code-csharp[csSnippets.Methods#45](../../samples/snippets/csharp/concepts/methods/named1.cs#45)]

Метод можно вызывать, используя и позиционные, и именованные аргументы. Однако позиционные аргументы могут следовать за именованными аргументами, только если именованные аргументы находятся в правильных позициях. В следующем примере метод `TestMotorcycle.Drive` из предыдущего примера вызывается с использованием одного позиционного и одного именованного аргумента.

[!code-csharp[csSnippets.Methods#46](../../samples/snippets/csharp/concepts/methods/named2.cs#46)]

<a name="inherited"></a>

## <a name="inherited-and-overridden-methods"></a>Унаследованные и переопределенные методы

Помимо членов, определенных в нем явно, тип наследует члены, определенные в его базовых классах. Так как все типы в системе управляемых типов напрямую или косвенно наследуются из класса <xref:System.Object>, все типы наследуют его члены, такие как <xref:System.Object.Equals(System.Object)>, <xref:System.Object.GetType> и <xref:System.Object.ToString>. В следующем примере определяется класс `Person`, который создает экземпляры двух объектов `Person` и вызывает метод `Person.Equals`, чтобы определить, равны ли эти объекты. При этом метод `Equals` в классе `Person` не определяется, он наследуется из <xref:System.Object>.

[!code-csharp[csSnippets.Methods#104](../../samples/snippets/csharp/concepts/methods/inherited1.cs#104)]

Типы могут переопределять унаследованные члены, используя ключевое слово `override` и обеспечивая реализацию переопределенного метода. Сигнатура метода должна быть такой же, как у переопределенного метода. Следующий пример аналогичен предыдущему за тем исключением, что переопределяет метод <xref:System.Object.Equals(System.Object)>. (Он также переопределяет метод <xref:System.Object.GetHashCode>, поскольку оба эти метода предназначены для получения согласованных результатов.)

[!code-csharp[csSnippets.Methods#105](../../samples/snippets/csharp/concepts/methods/overridden1.cs#105)]

<a name="passing"></a>

## <a name="passing-parameters"></a>Передача параметров

Типы в C# делятся на *типы значений* и *ссылочные типы*. Список встроенных типов значений см. в разделе [Типы](./tour-of-csharp/types.md). По умолчанию и типы значений, и ссылочные типы передаются в метод по значению.

<a name="byval"></a>

### <a name="passing-parameters-by-value"></a>Передача параметров по значению

При передаче типа значения в метод по значению вместо самого объекта передается его копия. Это значит, что изменения объекта в вызываемом методе не отражаются на исходном объекте, когда управление возвращается вызывающему объекту.

Код в следующем примере передает тип значения в метод по значению, а вызываемый метод пытается изменить значение типа значения. Он определяет переменную типа `int`, который является типом значения, присваивает ему значение 20 и передает его в метод с именем `ModifyValue`, который изменяет значение переменной на 30. Однако, когда метод возвращается, значение переменной остается неизменным.

[!code-csharp[csSnippets.Methods#10](../../samples/snippets/csharp/concepts/methods/byvalue10.cs#10)]

Если объект ссылочного типа передается в метод по значению, ссылка на этот объект передается по значению. Это значит, что метод получает не сам объект, а аргумент, который указывает расположение объекта. Если с помощью этой ссылки в член объекта вносится изменение, это изменение отражается в объекте, даже если управление возвращается вызывающему объекту. При этом изменения в объекте, переданном в метод, не отражаются на исходном объекте, когда управление возвращается вызывающему объекту.

В следующем примере определяется класс (ссылочного типа) с именем `SampleRefType`. Он создает экземпляр объекта `SampleRefType`, задает в его поле `value` значение 44 и передает объект в метод `ModifyObject`. В этом примере, в сущности, происходит то же самое, что и в предыдущем, — аргумент передается в метод по значению. Однако поскольку здесь используется ссылочный тип, результат будет другим. В данном случае в методе `ModifyObject` изменено поле `obj.value`, при этом поле `value` аргумента `rt` в методе `Main` также изменяется на 33, как видно из результатов в предыдущем примере.

[!code-csharp[csSnippets.Methods#42](../../samples/snippets/csharp/concepts/methods/byvalue42.cs#42)]

<a name="byref"></a>

### <a name="passing-parameters-by-reference"></a>Передача параметров по ссылке

Параметр передается по ссылке, когда нужно изменить значение аргумента в методе и сохранить это изменение после того, как управление вернется вызывающему методу. Для передачи параметра по ссылке используйте ключевое слово [`ref`](language-reference/keywords/ref.md) или [`out`](language-reference/keywords/out-parameter-modifier.md). Можно также передать значение по ссылке, чтобы предотвратить копирование, и при этом запретить внесение изменений с помощью ключевого слова [`in`](language-reference/keywords/in-parameter-modifier.md).

Следующий пример идентичен предыдущему за тем исключением, что значение передается в метод `ModifyValue` по ссылке. Если значение параметра в методе `ModifyValue` будет изменено, при возвращении управления вызывающему объекту это изменение не сохранится.

[!code-csharp[csSnippets.Methods#106](../../samples/snippets/csharp/concepts/methods/byref106.cs#106)]

Общий шаблон, в котором используются параметры по ссылке, включает замену значений переменных. Когда две переменные передаются в метод по ссылке, он меняет их содержимое местами. В следующем примере меняются местами целочисленные значения.

[!code-csharp[csSnippets.Methods#106](../../samples/snippets/csharp/concepts/methods/swap107.cs#107)]

Передача параметров ссылочного типа позволяет изменить значение самой ссылки, а не отдельных ее элементов или полей.

<a name="paramarray"></a>

### <a name="parameter-arrays"></a>Массивы параметров

В некоторых случаях требование об указании точного числа аргументов для метода является строгим. Если параметр в массиве параметров указывается с помощью ключевого слова `params`, метод можно вызывать с переменным числом аргументов. Параметр, помеченный ключевым словом `params`, должен быть типом массива и занимать последнюю позицию в списке параметров метода.

После этого вызывающий объект можно вызвать одним из четырех способов:

- передавая массив соответствующего типа, содержащий требуемое число элементов;
- передавая в метод список отдельных аргументов соответствующего типа, разделенный запятыми;
- Путем передачи `null`.
- не передавая никакие аргументы в массив параметров.

В следующем примере определяется метод с именем `GetVowels`, возвращающий все гласные из массива параметров. Метод `Main` демонстрирует все четыре способа вызова метода. От вызывающих объектов не требуются аргументы для параметров, которые включают модификатор `params`. В этом случае параметр является пустым массивом.

[!code-csharp[csSnippets.Methods#75](~/samples/snippets/csharp/concepts/methods/params75.cs#75)]

<a name="optional"></a>

## <a name="optional-parameters-and-arguments"></a>Необязательные параметры и аргументы

В определении метода может быть указано, являются его параметры обязательными или нет. По умолчанию параметры обязательны. Для определения необязательных параметров значения параметра по умолчанию включаются в определение метода. Если при вызове метода никакие аргументы для необязательного параметры не указываются, вместо них используется значение по умолчанию.

Значение параметра по умолчанию должно быть назначено одним из следующих видов выражений:

- Константа, например, строковый литерал или число.
- Выражение в форме `new ValType()`, где `ValType` — это тип значения. Обратите внимание на то, что при этом вызывается не имеющий параметров неявный конструктор типа значения, который не является фактическим членом типа.
- Выражение в форме `default(ValType)`, где `ValType` — это тип значения.

Если метод содержит как обязательные, так и необязательные параметры, необязательные параметры определяются в конце списка параметров после всех обязательных параметров.

В следующем примере определяется метод `ExampleMethod`, который имеет один обязательный и два необязательных параметра.

[!code-csharp[csSnippets.Methods#21](../../samples/snippets/csharp/concepts/methods/optional1.cs#21)]

Если для вызова метода с несколькими необязательными аргументами используются позиционные аргументы, вызывающий объект должен предоставить аргумент для всех необязательных параметров, для которых предоставлен аргумент, от первого до последнего. Например, если при использовании метода `ExampleMethod` вызывающий объект предоставляет аргумент для параметра `description`, он должен также предоставить его для параметра `optionalInt`. `opt.ExampleMethod(2, 2, "Addition of 2 and 2");` — допустимый вызов метода; `opt.ExampleMethod(2, , "Addition of 2 and 0");` вызывает ошибку компилятора "Аргумент отсутствует".

Если метод вызывается с помощью именованных аргументов или комбинации позиционных и именованных аргументов, вызывающий объект может опустить любые аргументы, следующие за последним позиционным аргументом в вызове метода.

В следующем примере метод `ExampleMethod` вызывается трижды.  В первых двух вызовах метода используются позиционные аргументы. В первом пропускаются оба необязательных аргумента, а во втором — последний. Третий вызов метода предоставляет позиционный аргумент для обязательного параметра, но использует именованный аргумент для передачи значения в параметр `description`, в то время как аргумент `optionalInt` опускается.

[!code-csharp[csSnippets.Methods#22](../../samples/snippets/csharp/concepts/methods/optional1.cs#22)]

Использование необязательных параметров влияет на *разрешение перегрузки* или на способ, с помощью которого компилятор C# определяет, какая именно перегрузка должна вызываться при вызове метода, следующим образом:

- Метод, индексатор или конструктор является кандидатом на выполнение, если каждый из его параметров необязателен либо по имени или позиции соответствует одному и тому же аргументу в операторе вызова, и этот аргумент можно преобразовать в тип параметра.
- Если найдено более одного кандидата, правила разрешения перегрузки для предпочтительных преобразований применяются к аргументам, указанным явно. Опущенные аргументы для необязательных параметров игнорируются.
- Если два кандидата определяются как равно подходящие, предпочтение отдается кандидату без необязательных параметров, аргументы которых в вызове были опущены. Это — последовательность определения приоритетов в разрешении перегрузки для кандидатов с меньшим числом параметров.

<a name="return"></a>

## <a name="return-values"></a>Возвращаемые значения

Методы могут возвращать значение вызывающему объекту. Если тип возврата, указываемый перед именем метода, не `void`, этот метод может возвращать значение с помощью ключевого слова `return`. Инструкция с ключевым словом `return`, за которым следует переменная, константа или выражение, соответствующие типу возврата, будут возвращать это значение объекту, вызвавшему метод. Методы с типом возврата, отличным от void, должны использовать ключевое слово `return` для возврата значения. Ключевое слове `return` также останавливает выполнение метода.

Если тип возврата — `void`, инструкцию `return` без значения по-прежнему можно использовать для завершения выполнения метода. Без ключевого слова `return` этот метод будет останавливать выполнение при достижении конца блока кода.

Например, в следующих двух методах ключевое слово `return` используется для возврата целочисленных значений.

[!code-csharp[csSnippets.Methods#44](../../samples/snippets/csharp/concepts/methods/return44.cs#44)]

Чтобы использовать значение, возвращаемое из метода, вызывающий метод может применять сам вызов метода везде, где будет достаточно значения того же типа. Можно также назначить возвращаемое значение переменной. Например, следующие два примера кода достигают одной и той же цели.

[!code-csharp[csSnippets.Methods#45](../../samples/snippets/csharp/concepts/methods/return44.cs#45)]

[!code-csharp[csSnippets.Methods#46](../../samples/snippets/csharp/concepts/methods/return44.cs#46)]

Использование локальной переменной, в данном случае `result`, для сохранения значения является необязательным. Это может улучшить читаемость кода или может оказаться необходимым, если нужно сохранить исходное значение аргумента для всей области метода.

В некоторых случаях нужно, чтобы метод возвращал больше одного значения. Начиная с C# версии 7.0, это легко можно сделать с помощью *типов кортежей* и *литералов кортежей*. Тип кортежа определяет типы данных для элементов кортежа. Литералы кортежей предоставляют фактические значения возвращаемого кортежа. В следующем примере `(string, string, string, int)` определяет тип кортежа, возвращаемый методом `GetPersonalInfo`. Выражение `(per.FirstName, per.MiddleName, per.LastName, per.Age)` представляет собой литерал кортежа; метод возвращает имя, отчество и фамилию, а также возраст объекта `PersonInfo`.

```csharp
public (string, string, string, int) GetPersonalInfo(string id)
{
    PersonInfo per = PersonInfo.RetrieveInfoById(id);
    return (per.FirstName, per.MiddleName, per.LastName, per.Age);
}
```

После этого вызывающий объект может использовать возвращенный кортеж в коде следующего вида:

```csharp
var person = GetPersonalInfo("111111111")
Console.WriteLine($"{person.Item1} {person.Item3}: age = {person.Item4}");
```

Имена могут также назначаться элементам кортежа в определении типа кортежа. В следующих примерах демонстрируется альтернативная версия метода `GetPersonalInfo`, в котором используются именованные элементы:

```csharp
public (string FName, string MName, string LName, int Age) GetPersonalInfo(string id)
{
    PersonInfo per = PersonInfo.RetrieveInfoById(id);
    return (per.FirstName, per.MiddleName, per.LastName, per.Age);
}
```

После этого предыдущий вызов метода `GetPersonInfo` можно изменить следующим образом:

```csharp
var person = GetPersonalInfo("111111111");
Console.WriteLine($"{person.FName} {person.LName}: age = {person.Age}");
```

Если в качестве аргумента метод получает массив, а затем изменяет значение отдельных элементов, он может не возвращать массив, однако при желании вы можете это изменить для соблюдения правильного стиля или обеспечения эффективного потока передачи значений.  Это связано с тем, что C# передает все ссылочные типы по значению, а значением ссылки на массив является указатель на массив. В следующем примере изменения в содержимом массива `values`, сделанные в методе `DoubleValues`, может отслеживать любой код, имеющий ссылку на этот массив.

[!code-csharp[csSnippets.Methods#101](../../samples/snippets/csharp/concepts/methods/returnarray1.cs#101)]

<a name="extension"></a>

## <a name="extension-methods"></a>Методы расширения

Как правило, добавлять методы в существующий тип можно двумя способами:

- Изменение исходного кода для этого типа. Конечно, если вы не владеете исходным кодом этого типа, сделать это невозможно. Если при этом в поддержку метода также добавляются поля закрытых данных, это изменение становится критическим.
- Определение нового метода в производном классе. Нельзя добавить метод этим способом, используя наследование для других типов, таких как структуры и перечисления. Кроме того, оно не позволяет "добавить" метод в запечатанный класс.

Методы расширения позволяют "добавить" метод в существующий тип, не меняя сам тип и не реализуя новый метод в наследуемом типе. Кроме того, метод расширения может не входить в ту же сборку, в которую входит расширяемый им тип. Вызовите метод расширения, как будто он является определенным членом типа.

Дополнительные сведения см. в статье [Методы расширения](programming-guide/classes-and-structs/extension-methods.md).

<a name="async"></a>

## <a name="async-methods"></a>Асинхронные методы

С помощью функции async можно вызывать асинхронные методы, не прибегая к использованию явных обратных вызовов или ручному разделению кода между несколькими методами или лямбда-выражениями.

Если пометить метод с помощью модификатора [async](language-reference/keywords/async.md) , можно использовать в этом методе инструкцию [await](language-reference/operators/await.md) . Если ожидаемая задача не завершена, то достигнув выражения `await` в асинхронном методе, управление возвращается вызывающему объекту, а выполнение метода с ключевым словом `await` приостанавливается до завершения выполнения ожидаемой задачи. После завершения задачи можно возобновить выполнение в методе.

> [!NOTE]
> Асинхронный метод возвращается в вызывающий объект, когда он встречает первый ожидаемый объект, выполнение которого еще не завершено, или когда выполнение асинхронного метода доходит до конца — в зависимости от того, что происходит раньше.

Асинхронный метод обычно имеет тип возвращаемого значения <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.Task>, <xref:System.Collections.Generic.IAsyncEnumerable%601> или `void`. Тип возвращаемого значения `void` в основном используется для определения обработчиков событий, где требуется возвращать тип `void`. Асинхронный метод, который возвращает тип `void`, не может быть ожидающим. Вызывающий объект метода, возвращающего значение типа void, не может перехватывать исключения, которые выдает этот метод. Начиная с C# 7.0 асинхронный метод может возвращать [любой тип вида задачи](./whats-new/csharp-7.md#generalized-async-return-types).

В следующем примере `DelayAsync` представляет собой асинхронный метод с оператором return, который возвращает целое число. Поскольку этот метод асинхронный, его объявление должно иметь тип возвращаемого значения `Task<int>`. Поскольку тип возврата — `Task<int>`, вычисление выражения `await` в `DoSomethingAsync` создает целое число, как показывает следующий оператор: `int result = await delayTask`.

:::code language="csharp" source="programming-guide/classes-and-structs/snippets/classes-and-structs/methods/Program.cs":::

Асинхронный метод не может объявлять параметры [in](language-reference/keywords/in-parameter-modifier.md), [ref](language-reference/keywords/ref.md) или [out](language-reference/keywords/out-parameter-modifier.md), но может вызывать методы, имеющие такие параметры.

 Дополнительные сведения об асинхронных методах см. в разделах [Асинхронное программирование с использованием ключевых слов async и await (C#)](async.md) и [Типы возвращаемых значений асинхронных операций](programming-guide/concepts/async/async-return-types.md).

<a name="expr"></a>

## <a name="expression-bodied-members"></a>Элементы, воплощающие выражение

Часто используются определения методов, которые просто немедленно возвращаются с результатом выражения или которые имеют единственную инструкцию в тексте метода.  Для определения таких методов существует сокращенный синтаксис с использованием `=>`:

```csharp
public Point Move(int dx, int dy) => new Point(x + dx, y + dy);
public void Print() => Console.WriteLine(First + " " + Last);
// Works with operators, properties, and indexers too.
public static Complex operator +(Complex a, Complex b) => a.Add(b);
public string Name => First + " " + Last;
public Customer this[long id] => store.LookupCustomer(id);
```

Если метод возвращает `void` или является асинхронным, текст этого метода должен быть выражением оператора (как и при использовании лямбда-выражений).  Свойства и индексаторы должны быть доступны только для чтения, и использовать ключевое слово метода доступа `get` не следует.

<a name="iterators"></a>

## <a name="iterators"></a>Iterators

Итератор выполняет настраиваемую итерацию по коллекции, например по списку или массиву. Итератор использует инструкцию [yield return](language-reference/keywords/yield.md) для возврата всех элементов по одному. По достижении оператора `yield return` текущее расположение запоминается, чтобы вызывающий объект мог запросить следующий элемент в последовательности.

Тип возврата итератора может быть <xref:System.Collections.IEnumerable>, <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.IEnumerator> или <xref:System.Collections.Generic.IEnumerator%601>.

Дополнительные сведения см. в разделе [Итераторы](programming-guide/concepts/iterators.md).

## <a name="see-also"></a>См. также раздел

- [Модификаторы доступа](language-reference/keywords/access-modifiers.md)
- [Статические классы и члены статических классов](programming-guide/classes-and-structs/static-classes-and-static-class-members.md)
- [Наследование](programming-guide/classes-and-structs/inheritance.md)
- [Абстрактные и запечатанные классы и члены классов](programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md)
- [params](language-reference/keywords/params.md)
- [out](language-reference/keywords/out-parameter-modifier.md)
- [ref](language-reference/keywords/ref.md)
- [in](language-reference/keywords/in-parameter-modifier.md)
- [Передача параметров](programming-guide/classes-and-structs/passing-parameters.md)
