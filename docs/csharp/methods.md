---
title: Методы | Руководство по C#
description: Общие сведения о методах, их параметрах и возвращаемых значениях
ms.technology: csharp-fundamentals
ms.date: 03/16/2021
ms.assetid: 577a8527-1081-4b36-9b9e-0685b6553c6e
ms.openlocfilehash: 5d7f654ca268deff4a0c8e69b76e4d636d2f495e
ms.sourcegitcommit: 1dbe25ff484a02025d5c34146e517c236f7161fb
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/19/2021
ms.locfileid: "104652936"
---
# <a name="methods-in-c"></a><span data-ttu-id="f5e99-103">Методы в (C#)</span><span class="sxs-lookup"><span data-stu-id="f5e99-103">Methods in (C#)</span></span>

<span data-ttu-id="f5e99-104">Метод — это блок кода, содержащий ряд инструкций.</span><span class="sxs-lookup"><span data-stu-id="f5e99-104">A method is a code block that contains a series of statements.</span></span> <span data-ttu-id="f5e99-105">Программа инициирует выполнение инструкций, вызывая метод и указывая все аргументы, необходимые для этого метода.</span><span class="sxs-lookup"><span data-stu-id="f5e99-105">A program causes the statements to be executed by calling the method and specifying any required method arguments.</span></span> <span data-ttu-id="f5e99-106">В C# все инструкции выполняются в контексте метода.</span><span class="sxs-lookup"><span data-stu-id="f5e99-106">In C#, every executed instruction is performed in the context of a method.</span></span> <span data-ttu-id="f5e99-107">Метод `Main` является точкой входа для каждого приложения C#, и вызывается общеязыковой средой выполнения (CLR) при запуске программы.</span><span class="sxs-lookup"><span data-stu-id="f5e99-107">The `Main` method is the entry point for every C# application and it is called by the common language runtime (CLR) when the program is started.</span></span>

> [!NOTE]
> <span data-ttu-id="f5e99-108">В этом разделе рассматриваются названные методы.</span><span class="sxs-lookup"><span data-stu-id="f5e99-108">This topic discusses named methods.</span></span> <span data-ttu-id="f5e99-109">Сведения об анонимных функциях см. в разделе [Анонимные функции](programming-guide/statements-expressions-operators/anonymous-functions.md).</span><span class="sxs-lookup"><span data-stu-id="f5e99-109">For information about anonymous functions, see [Anonymous Functions](programming-guide/statements-expressions-operators/anonymous-functions.md).</span></span>

<a name="signatures"></a>

## <a name="method-signatures"></a><span data-ttu-id="f5e99-110">Сигнатуры методов</span><span class="sxs-lookup"><span data-stu-id="f5e99-110">Method signatures</span></span>

<span data-ttu-id="f5e99-111">Методы объявляются в `class` или `struct`, для чего указывается следующее:</span><span class="sxs-lookup"><span data-stu-id="f5e99-111">Methods are declared in a `class` or `struct` by specifying:</span></span>

- <span data-ttu-id="f5e99-112">Уровень доступа (необязательно), например `public` или `private`.</span><span class="sxs-lookup"><span data-stu-id="f5e99-112">An optional access level, such as `public` or `private`.</span></span> <span data-ttu-id="f5e99-113">Значение по умолчанию — `private`.</span><span class="sxs-lookup"><span data-stu-id="f5e99-113">The default is `private`.</span></span>
- <span data-ttu-id="f5e99-114">Необязательные модификаторы, например `abstract` или `sealed`.</span><span class="sxs-lookup"><span data-stu-id="f5e99-114">Optional modifiers such as `abstract` or `sealed`.</span></span>
- <span data-ttu-id="f5e99-115">Возвращаемое значение или `void`, если у метода его нет.</span><span class="sxs-lookup"><span data-stu-id="f5e99-115">The return value, or `void` if the method has none.</span></span>
- <span data-ttu-id="f5e99-116">Имя метода.</span><span class="sxs-lookup"><span data-stu-id="f5e99-116">The method name.</span></span>
- <span data-ttu-id="f5e99-117">Любые параметры методов.</span><span class="sxs-lookup"><span data-stu-id="f5e99-117">Any method parameters.</span></span> <span data-ttu-id="f5e99-118">Параметры метода заключаются в скобки и разделяются запятыми.</span><span class="sxs-lookup"><span data-stu-id="f5e99-118">Method parameters are enclosed in parentheses and are separated by commas.</span></span> <span data-ttu-id="f5e99-119">Пустые скобки указывают, что параметры методу не требуются.</span><span class="sxs-lookup"><span data-stu-id="f5e99-119">Empty parentheses indicate that the method requires no parameters.</span></span>

<span data-ttu-id="f5e99-120">Вместе все эти части формируют сигнатуру метода.</span><span class="sxs-lookup"><span data-stu-id="f5e99-120">These parts together form the method signature.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f5e99-121">Тип возврата метода не является частью сигнатуры метода в целях перегрузки метода.</span><span class="sxs-lookup"><span data-stu-id="f5e99-121">A return type of a method is not part of the signature of the method for the purposes of method overloading.</span></span> <span data-ttu-id="f5e99-122">Однако он является частью сигнатуры метода при определении совместимости между делегатом и методом, который он указывает.</span><span class="sxs-lookup"><span data-stu-id="f5e99-122">However, it is part of the signature of the method when determining the compatibility between a delegate and the method that it points to.</span></span>

<span data-ttu-id="f5e99-123">В следующем примере определяется класс с именем `Motorcycle`, содержащий пять методов:</span><span class="sxs-lookup"><span data-stu-id="f5e99-123">The following example defines a class named `Motorcycle` that contains five methods:</span></span>

[!code-csharp[csSnippets.Methods#40](../../samples/snippets/csharp/concepts/methods/methods40.cs#40)]

<span data-ttu-id="f5e99-124">Обратите внимание на то, что класс `Motorcycle` включает перегруженный метод `Drive`.</span><span class="sxs-lookup"><span data-stu-id="f5e99-124">Note that the `Motorcycle` class includes an overloaded method, `Drive`.</span></span> <span data-ttu-id="f5e99-125">Оба метода называются одинаково, но различаются по типам параметров.</span><span class="sxs-lookup"><span data-stu-id="f5e99-125">Two methods have the same name, but must be differentiated by their parameter types.</span></span>

<a name="invocation"></a>

## <a name="method-invocation"></a><span data-ttu-id="f5e99-126">Вызов метода</span><span class="sxs-lookup"><span data-stu-id="f5e99-126">Method invocation</span></span>

<span data-ttu-id="f5e99-127">Можно использовать метод *instance* или *static*.</span><span class="sxs-lookup"><span data-stu-id="f5e99-127">Methods can be either *instance* or *static*.</span></span> <span data-ttu-id="f5e99-128">Для того чтобы вызвать метод instance, необходимо создать экземпляр объекта и вызвать для него метод; метод instance будет применен к этому экземпляру и его данным.</span><span class="sxs-lookup"><span data-stu-id="f5e99-128">Invoking an instance method requires that you instantiate an object and call the method on that object; an instance method operates on that instance and its data.</span></span> <span data-ttu-id="f5e99-129">Статический метод вызывается путем ссылки на имя типа, к которому относится метод; статические методы не работают с данными экземпляров.</span><span class="sxs-lookup"><span data-stu-id="f5e99-129">You invoke a static method by referencing the name of the type to which the method belongs; static methods do not operate on instance data.</span></span> <span data-ttu-id="f5e99-130">При попытке вызвать статический метод с помощью экземпляра объекта возникает ошибка компилятора.</span><span class="sxs-lookup"><span data-stu-id="f5e99-130">Attempting to call a static method through an object instance generates a compiler error.</span></span>

<span data-ttu-id="f5e99-131">Вызов метода аналогичен доступу к полю.</span><span class="sxs-lookup"><span data-stu-id="f5e99-131">Calling a method is like accessing a field.</span></span> <span data-ttu-id="f5e99-132">После имени объекта (при вызове метода экземпляра) или имени типа (при вызове метода `static`) добавьте точку, имя метода и круглые скобки.</span><span class="sxs-lookup"><span data-stu-id="f5e99-132">After the object name (if you are calling an instance method) or the type name (if you are calling a `static` method), add a period, the name of the method, and parentheses.</span></span> <span data-ttu-id="f5e99-133">Аргументы перечисляются в этих скобках и разделяются запятыми.</span><span class="sxs-lookup"><span data-stu-id="f5e99-133">Arguments are listed within the parentheses and are separated by commas.</span></span>

<span data-ttu-id="f5e99-134">Определение метода задает имена и типы всех необходимых параметров.</span><span class="sxs-lookup"><span data-stu-id="f5e99-134">The method definition specifies the names and types of any parameters that are required.</span></span> <span data-ttu-id="f5e99-135">Когда вызывающий код вызывает метод, он предоставляет конкретные значения, называемые аргументами, для каждого параметра.</span><span class="sxs-lookup"><span data-stu-id="f5e99-135">When a caller invokes the method, it provides concrete values, called arguments, for each parameter.</span></span> <span data-ttu-id="f5e99-136">Аргументы должны быть совместимы с типом параметра, но имя аргумента (если оно используется в вызывающем коде) может не совпадать с именем параметра, указанным в методе.</span><span class="sxs-lookup"><span data-stu-id="f5e99-136">The arguments must be compatible with the parameter type, but the argument name, if one is used in the calling code, does not have to be the same as the parameter named defined in the method.</span></span> <span data-ttu-id="f5e99-137">В следующем примере метод `Square` имеет один параметр типа `int` с именем *i*.</span><span class="sxs-lookup"><span data-stu-id="f5e99-137">In the following example, the `Square` method includes a single parameter of type `int` named *i*.</span></span> <span data-ttu-id="f5e99-138">Первый вызов метода передает методу `Square` переменную типа `int` с именем *num*; второй — числовую константу, а третий — выражение.</span><span class="sxs-lookup"><span data-stu-id="f5e99-138">The first method call passes the `Square` method a variable of type `int` named *num*; the second, a numeric constant; and the third, an expression.</span></span>

[!code-csharp[csSnippets.Methods#74](../../samples/snippets/csharp/concepts/methods/params74.cs#74)]

<span data-ttu-id="f5e99-139">В наиболее распространенной форме вызова методов используются позиционные аргументы; они передаются в том же порядке, что и параметры метода.</span><span class="sxs-lookup"><span data-stu-id="f5e99-139">The most common form of method invocation used positional arguments; it supplies arguments in the same order as method parameters.</span></span> <span data-ttu-id="f5e99-140">Таким образом, методы класса `Motorcycle` могут вызываться, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="f5e99-140">The methods of the `Motorcycle` class can therefore be called as in the following example.</span></span> <span data-ttu-id="f5e99-141">Например, вызов метода `Drive` включает два аргумента, которые соответствуют двум параметрам в синтаксисе метода.</span><span class="sxs-lookup"><span data-stu-id="f5e99-141">The call to the `Drive` method, for example, includes two arguments that correspond to the two parameters in the method's syntax.</span></span> <span data-ttu-id="f5e99-142">Первый становится значением параметра `miles`, а второй — значением параметра `speed`.</span><span class="sxs-lookup"><span data-stu-id="f5e99-142">The first becomes the value of the `miles` parameter, the second the value of the `speed` parameter.</span></span>

[!code-csharp[csSnippets.Methods#41](../../samples/snippets/csharp/concepts/methods/methods40.cs#41)]

<span data-ttu-id="f5e99-143">При вызове метода вместо позиционных аргументов можно также использовать *именованные аргументы*.</span><span class="sxs-lookup"><span data-stu-id="f5e99-143">You can also use *named arguments* instead of positional arguments when invoking a method.</span></span> <span data-ttu-id="f5e99-144">При использовании именованных аргументов необходимо указать имя параметра, двоеточие (":"), а затем аргумент.</span><span class="sxs-lookup"><span data-stu-id="f5e99-144">When using named arguments, you specify the parameter name followed by a colon (":") and the argument.</span></span> <span data-ttu-id="f5e99-145">Аргументы для метода могут отображаться в любом порядке, при условии, что все обязательные аргументы присутствуют.</span><span class="sxs-lookup"><span data-stu-id="f5e99-145">Arguments to the method can appear in any order, as long as all required arguments are present.</span></span> <span data-ttu-id="f5e99-146">В следующем примере для вызова метода `TestMotorcycle.Drive` используются именованные аргументы.</span><span class="sxs-lookup"><span data-stu-id="f5e99-146">The following example uses named arguments to invoke the `TestMotorcycle.Drive` method.</span></span> <span data-ttu-id="f5e99-147">В этом примере именованные аргументы передаются из списка параметров метода в обратном порядке.</span><span class="sxs-lookup"><span data-stu-id="f5e99-147">In this example, the named arguments are passed in the opposite order from the method's parameter list.</span></span>

[!code-csharp[csSnippets.Methods#45](../../samples/snippets/csharp/concepts/methods/named1.cs#45)]

<span data-ttu-id="f5e99-148">Метод можно вызывать, используя и позиционные, и именованные аргументы.</span><span class="sxs-lookup"><span data-stu-id="f5e99-148">You can invoke a method using both positional arguments and named arguments.</span></span> <span data-ttu-id="f5e99-149">Однако позиционные аргументы могут следовать за именованными аргументами, только если именованные аргументы находятся в правильных позициях.</span><span class="sxs-lookup"><span data-stu-id="f5e99-149">However, positional arguments can only follow named arguments when the named arguments are in the correct positions.</span></span> <span data-ttu-id="f5e99-150">В следующем примере метод `TestMotorcycle.Drive` из предыдущего примера вызывается с использованием одного позиционного и одного именованного аргумента.</span><span class="sxs-lookup"><span data-stu-id="f5e99-150">The following example invokes the `TestMotorcycle.Drive` method from the previous example using one positional argument and one named argument.</span></span>

[!code-csharp[csSnippets.Methods#46](../../samples/snippets/csharp/concepts/methods/named2.cs#46)]

<a name="inherited"></a>

## <a name="inherited-and-overridden-methods"></a><span data-ttu-id="f5e99-151">Унаследованные и переопределенные методы</span><span class="sxs-lookup"><span data-stu-id="f5e99-151">Inherited and overridden methods</span></span>

<span data-ttu-id="f5e99-152">Помимо членов, определенных в нем явно, тип наследует члены, определенные в его базовых классах.</span><span class="sxs-lookup"><span data-stu-id="f5e99-152">In addition to the members that are explicitly defined in a type, a type inherits members defined in its base classes.</span></span> <span data-ttu-id="f5e99-153">Так как все типы в системе управляемых типов напрямую или косвенно наследуются из класса <xref:System.Object>, все типы наследуют его члены, такие как <xref:System.Object.Equals(System.Object)>, <xref:System.Object.GetType> и <xref:System.Object.ToString>.</span><span class="sxs-lookup"><span data-stu-id="f5e99-153">Since all types in the managed type system inherit directly or indirectly from the <xref:System.Object> class, all types inherit its members, such as <xref:System.Object.Equals(System.Object)>, <xref:System.Object.GetType>, and <xref:System.Object.ToString>.</span></span> <span data-ttu-id="f5e99-154">В следующем примере определяется класс `Person`, который создает экземпляры двух объектов `Person` и вызывает метод `Person.Equals`, чтобы определить, равны ли эти объекты.</span><span class="sxs-lookup"><span data-stu-id="f5e99-154">The following example defines a `Person` class, instantiates two `Person` objects, and calls the `Person.Equals` method to determine whether the two objects are equal.</span></span> <span data-ttu-id="f5e99-155">При этом метод `Equals` в классе `Person` не определяется, он наследуется из <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="f5e99-155">The `Equals` method, however, is not defined in the `Person` class; it is inherited from <xref:System.Object>.</span></span>

[!code-csharp[csSnippets.Methods#104](../../samples/snippets/csharp/concepts/methods/inherited1.cs#104)]

<span data-ttu-id="f5e99-156">Типы могут переопределять унаследованные члены, используя ключевое слово `override` и обеспечивая реализацию переопределенного метода.</span><span class="sxs-lookup"><span data-stu-id="f5e99-156">Types can override inherited members by using the `override` keyword and providing an implementation for the overridden method.</span></span> <span data-ttu-id="f5e99-157">Сигнатура метода должна быть такой же, как у переопределенного метода.</span><span class="sxs-lookup"><span data-stu-id="f5e99-157">The method signature must be the same as that of the overridden method.</span></span> <span data-ttu-id="f5e99-158">Следующий пример аналогичен предыдущему за тем исключением, что переопределяет метод <xref:System.Object.Equals(System.Object)>.</span><span class="sxs-lookup"><span data-stu-id="f5e99-158">The following example is like the previous one, except that it overrides the <xref:System.Object.Equals(System.Object)> method.</span></span> <span data-ttu-id="f5e99-159">(Он также переопределяет метод <xref:System.Object.GetHashCode>, поскольку оба эти метода предназначены для получения согласованных результатов.)</span><span class="sxs-lookup"><span data-stu-id="f5e99-159">(It also overrides the <xref:System.Object.GetHashCode> method, since the two methods are intended to provide consistent results.)</span></span>

[!code-csharp[csSnippets.Methods#105](../../samples/snippets/csharp/concepts/methods/overridden1.cs#105)]

<a name="passing"></a>

## <a name="passing-parameters"></a><span data-ttu-id="f5e99-160">Передача параметров</span><span class="sxs-lookup"><span data-stu-id="f5e99-160">Passing parameters</span></span>

<span data-ttu-id="f5e99-161">Типы в C# делятся на *типы значений* и *ссылочные типы*.</span><span class="sxs-lookup"><span data-stu-id="f5e99-161">Types in C# are either *value types* or *reference types*.</span></span> <span data-ttu-id="f5e99-162">Список встроенных типов значений см. в разделе [Типы](./tour-of-csharp/types.md).</span><span class="sxs-lookup"><span data-stu-id="f5e99-162">For a list of built-in value types, see [Types](./tour-of-csharp/types.md).</span></span> <span data-ttu-id="f5e99-163">По умолчанию и типы значений, и ссылочные типы передаются в метод по значению.</span><span class="sxs-lookup"><span data-stu-id="f5e99-163">By default, both value types and reference types are passed to a method by value.</span></span>

<a name="byval"></a>

### <a name="passing-parameters-by-value"></a><span data-ttu-id="f5e99-164">Передача параметров по значению</span><span class="sxs-lookup"><span data-stu-id="f5e99-164">Passing parameters by value</span></span>

<span data-ttu-id="f5e99-165">При передаче типа значения в метод по значению вместо самого объекта передается его копия.</span><span class="sxs-lookup"><span data-stu-id="f5e99-165">When a value type is passed to a method by value, a copy of the object instead of the object itself is passed to the method.</span></span> <span data-ttu-id="f5e99-166">Это значит, что изменения объекта в вызываемом методе не отражаются на исходном объекте, когда управление возвращается вызывающему объекту.</span><span class="sxs-lookup"><span data-stu-id="f5e99-166">Therefore, changes to the object in the called method have no effect on the original object when control returns to the caller.</span></span>

<span data-ttu-id="f5e99-167">Код в следующем примере передает тип значения в метод по значению, а вызываемый метод пытается изменить значение типа значения.</span><span class="sxs-lookup"><span data-stu-id="f5e99-167">The following example passes a value type to a method by value, and the called method attempts to change the value type's value.</span></span> <span data-ttu-id="f5e99-168">Он определяет переменную типа `int`, который является типом значения, присваивает ему значение 20 и передает его в метод с именем `ModifyValue`, который изменяет значение переменной на 30.</span><span class="sxs-lookup"><span data-stu-id="f5e99-168">It defines a variable of type `int`, which is a value type, initializes its value to 20, and passes it to a method named `ModifyValue` that changes the variable's value to 30.</span></span> <span data-ttu-id="f5e99-169">Однако, когда метод возвращается, значение переменной остается неизменным.</span><span class="sxs-lookup"><span data-stu-id="f5e99-169">When the method returns, however, the variable's value remains unchanged.</span></span>

[!code-csharp[csSnippets.Methods#10](../../samples/snippets/csharp/concepts/methods/byvalue10.cs#10)]

<span data-ttu-id="f5e99-170">Если объект ссылочного типа передается в метод по значению, ссылка на этот объект передается по значению.</span><span class="sxs-lookup"><span data-stu-id="f5e99-170">When an object of a reference type is passed to a method by value, a reference to the object is passed by value.</span></span> <span data-ttu-id="f5e99-171">Это значит, что метод получает не сам объект, а аргумент, который указывает расположение объекта.</span><span class="sxs-lookup"><span data-stu-id="f5e99-171">That is, the method receives not the object itself, but an argument that indicates the location of the object.</span></span> <span data-ttu-id="f5e99-172">Если с помощью этой ссылки в член объекта вносится изменение, это изменение отражается в объекте, даже если управление возвращается вызывающему объекту.</span><span class="sxs-lookup"><span data-stu-id="f5e99-172">If you change a member of the object by using this reference, the change is reflected in the object when control returns to the calling method.</span></span> <span data-ttu-id="f5e99-173">При этом изменения в объекте, переданном в метод, не отражаются на исходном объекте, когда управление возвращается вызывающему объекту.</span><span class="sxs-lookup"><span data-stu-id="f5e99-173">However, replacing the object passed to the method has no effect on the original object when control returns to the caller.</span></span>

<span data-ttu-id="f5e99-174">В следующем примере определяется класс (ссылочного типа) с именем `SampleRefType`.</span><span class="sxs-lookup"><span data-stu-id="f5e99-174">The following example defines a class (which is a reference type) named `SampleRefType`.</span></span> <span data-ttu-id="f5e99-175">Он создает экземпляр объекта `SampleRefType`, задает в его поле `value` значение 44 и передает объект в метод `ModifyObject`.</span><span class="sxs-lookup"><span data-stu-id="f5e99-175">It instantiates a `SampleRefType` object, assigns 44 to its `value` field, and passes the object to the `ModifyObject` method.</span></span> <span data-ttu-id="f5e99-176">В этом примере, в сущности, происходит то же самое, что и в предыдущем, — аргумент передается в метод по значению.</span><span class="sxs-lookup"><span data-stu-id="f5e99-176">This example does essentially the same thing as the previous example -- it passes an argument by value to a method.</span></span> <span data-ttu-id="f5e99-177">Однако поскольку здесь используется ссылочный тип, результат будет другим.</span><span class="sxs-lookup"><span data-stu-id="f5e99-177">But because a reference type is used, the result is different.</span></span> <span data-ttu-id="f5e99-178">В данном случае в методе `ModifyObject` изменено поле `obj.value`, при этом поле `value` аргумента `rt` в методе `Main` также изменяется на 33, как видно из результатов в предыдущем примере.</span><span class="sxs-lookup"><span data-stu-id="f5e99-178">The modification that is made in `ModifyObject` to the `obj.value` field also changes the `value` field of the argument, `rt`, in the `Main` method to 33, as the output from the example shows.</span></span>

[!code-csharp[csSnippets.Methods#42](../../samples/snippets/csharp/concepts/methods/byvalue42.cs#42)]

<a name="byref"></a>

### <a name="passing-parameters-by-reference"></a><span data-ttu-id="f5e99-179">Передача параметров по ссылке</span><span class="sxs-lookup"><span data-stu-id="f5e99-179">Passing parameters by reference</span></span>

<span data-ttu-id="f5e99-180">Параметр передается по ссылке, когда нужно изменить значение аргумента в методе и сохранить это изменение после того, как управление вернется вызывающему методу.</span><span class="sxs-lookup"><span data-stu-id="f5e99-180">You pass a parameter by reference when you want to change the value of an argument in a method and want to reflect that change when control returns to the calling method.</span></span> <span data-ttu-id="f5e99-181">Для передачи параметра по ссылке используйте ключевое слово [`ref`](language-reference/keywords/ref.md) или [`out`](language-reference/keywords/out-parameter-modifier.md).</span><span class="sxs-lookup"><span data-stu-id="f5e99-181">To pass a parameter by reference, you use the [`ref`](language-reference/keywords/ref.md) or [`out`](language-reference/keywords/out-parameter-modifier.md) keyword.</span></span> <span data-ttu-id="f5e99-182">Можно также передать значение по ссылке, чтобы предотвратить копирование, и при этом запретить внесение изменений с помощью ключевого слова [`in`](language-reference/keywords/in-parameter-modifier.md).</span><span class="sxs-lookup"><span data-stu-id="f5e99-182">You can also pass a value by reference to avoid copying but still prevent modifications using the [`in`](language-reference/keywords/in-parameter-modifier.md) keyword.</span></span>

<span data-ttu-id="f5e99-183">Следующий пример идентичен предыдущему за тем исключением, что значение передается в метод `ModifyValue` по ссылке.</span><span class="sxs-lookup"><span data-stu-id="f5e99-183">The following example is identical to the previous one, except the value is passed by reference to the `ModifyValue` method.</span></span> <span data-ttu-id="f5e99-184">Если значение параметра в методе `ModifyValue` будет изменено, при возвращении управления вызывающему объекту это изменение не сохранится.</span><span class="sxs-lookup"><span data-stu-id="f5e99-184">When the value of the parameter is modified in the `ModifyValue` method, the change in value is reflected when control returns to the caller.</span></span>

[!code-csharp[csSnippets.Methods#106](../../samples/snippets/csharp/concepts/methods/byref106.cs#106)]

<span data-ttu-id="f5e99-185">Общий шаблон, в котором используются параметры по ссылке, включает замену значений переменных.</span><span class="sxs-lookup"><span data-stu-id="f5e99-185">A common pattern that uses by ref parameters involves swapping the values of variables.</span></span> <span data-ttu-id="f5e99-186">Когда две переменные передаются в метод по ссылке, он меняет их содержимое местами.</span><span class="sxs-lookup"><span data-stu-id="f5e99-186">You pass two variables to a method by reference, and the method swaps their contents.</span></span> <span data-ttu-id="f5e99-187">В следующем примере меняются местами целочисленные значения.</span><span class="sxs-lookup"><span data-stu-id="f5e99-187">The following example swaps integer values.</span></span>

[!code-csharp[csSnippets.Methods#106](../../samples/snippets/csharp/concepts/methods/swap107.cs#107)]

<span data-ttu-id="f5e99-188">Передача параметров ссылочного типа позволяет изменить значение самой ссылки, а не отдельных ее элементов или полей.</span><span class="sxs-lookup"><span data-stu-id="f5e99-188">Passing a reference-type parameter allows you to change the value of the reference itself, rather than the value of its individual elements or fields.</span></span>

<a name="paramarray"></a>

### <a name="parameter-arrays"></a><span data-ttu-id="f5e99-189">Массивы параметров</span><span class="sxs-lookup"><span data-stu-id="f5e99-189">Parameter arrays</span></span>

<span data-ttu-id="f5e99-190">В некоторых случаях требование об указании точного числа аргументов для метода является строгим.</span><span class="sxs-lookup"><span data-stu-id="f5e99-190">Sometimes, the requirement that you specify the exact number of arguments to your method is restrictive.</span></span> <span data-ttu-id="f5e99-191">Если параметр в массиве параметров указывается с помощью ключевого слова `params`, метод можно вызывать с переменным числом аргументов.</span><span class="sxs-lookup"><span data-stu-id="f5e99-191">By using the `params` keyword to indicate that a parameter is a parameter array, you allow your method to be called with a variable number of arguments.</span></span> <span data-ttu-id="f5e99-192">Параметр, помеченный ключевым словом `params`, должен быть типом массива и занимать последнюю позицию в списке параметров метода.</span><span class="sxs-lookup"><span data-stu-id="f5e99-192">The parameter tagged with the `params` keyword must be an array type, and it must be the last parameter in the method's parameter list.</span></span>

<span data-ttu-id="f5e99-193">После этого вызывающий объект можно вызвать одним из четырех способов:</span><span class="sxs-lookup"><span data-stu-id="f5e99-193">A caller can then invoke the method in either of four ways:</span></span>

- <span data-ttu-id="f5e99-194">передавая массив соответствующего типа, содержащий требуемое число элементов;</span><span class="sxs-lookup"><span data-stu-id="f5e99-194">By passing an array of the appropriate type that contains the desired number of elements.</span></span>
- <span data-ttu-id="f5e99-195">передавая в метод список отдельных аргументов соответствующего типа, разделенный запятыми;</span><span class="sxs-lookup"><span data-stu-id="f5e99-195">By passing a comma-separated list of individual arguments of the appropriate type to the method.</span></span>
- <span data-ttu-id="f5e99-196">Путем передачи `null`.</span><span class="sxs-lookup"><span data-stu-id="f5e99-196">By passing `null`.</span></span>
- <span data-ttu-id="f5e99-197">не передавая никакие аргументы в массив параметров.</span><span class="sxs-lookup"><span data-stu-id="f5e99-197">By not providing an argument to the parameter array.</span></span>

<span data-ttu-id="f5e99-198">В следующем примере определяется метод с именем `GetVowels`, возвращающий все гласные из массива параметров.</span><span class="sxs-lookup"><span data-stu-id="f5e99-198">The following example defines a method named `GetVowels` that returns all the vowels from a parameter array.</span></span> <span data-ttu-id="f5e99-199">Метод `Main` демонстрирует все четыре способа вызова метода.</span><span class="sxs-lookup"><span data-stu-id="f5e99-199">The `Main` method illustrates all four ways of invoking the method.</span></span> <span data-ttu-id="f5e99-200">От вызывающих объектов не требуются аргументы для параметров, которые включают модификатор `params`.</span><span class="sxs-lookup"><span data-stu-id="f5e99-200">Callers are not required to supply any arguments for parameters that include the `params` modifier.</span></span> <span data-ttu-id="f5e99-201">В этом случае параметр является пустым массивом.</span><span class="sxs-lookup"><span data-stu-id="f5e99-201">In that case, the parameter is an empty array.</span></span>

[!code-csharp[csSnippets.Methods#75](~/samples/snippets/csharp/concepts/methods/params75.cs#75)]

<a name="optional"></a>

## <a name="optional-parameters-and-arguments"></a><span data-ttu-id="f5e99-202">Необязательные параметры и аргументы</span><span class="sxs-lookup"><span data-stu-id="f5e99-202">Optional parameters and arguments</span></span>

<span data-ttu-id="f5e99-203">В определении метода может быть указано, являются его параметры обязательными или нет.</span><span class="sxs-lookup"><span data-stu-id="f5e99-203">A method definition can specify that its parameters are required or that they are optional.</span></span> <span data-ttu-id="f5e99-204">По умолчанию параметры обязательны.</span><span class="sxs-lookup"><span data-stu-id="f5e99-204">By default, parameters are required.</span></span> <span data-ttu-id="f5e99-205">Для определения необязательных параметров значения параметра по умолчанию включаются в определение метода.</span><span class="sxs-lookup"><span data-stu-id="f5e99-205">Optional parameters are specified by including the parameter's default value in the method definition.</span></span> <span data-ttu-id="f5e99-206">Если при вызове метода никакие аргументы для необязательного параметры не указываются, вместо них используется значение по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f5e99-206">When the method is called, if no argument is supplied for an optional parameter, the default value is used instead.</span></span>

<span data-ttu-id="f5e99-207">Значение параметра по умолчанию должно быть назначено одним из следующих видов выражений:</span><span class="sxs-lookup"><span data-stu-id="f5e99-207">The parameter's default value must be assigned by one of the following kinds of expressions:</span></span>

- <span data-ttu-id="f5e99-208">Константа, например, строковый литерал или число.</span><span class="sxs-lookup"><span data-stu-id="f5e99-208">A constant, such as a literal string or number.</span></span>
- <span data-ttu-id="f5e99-209">Выражение в форме `new ValType()`, где `ValType` — это тип значения.</span><span class="sxs-lookup"><span data-stu-id="f5e99-209">An expression of the form `new ValType()`, where `ValType` is a value type.</span></span> <span data-ttu-id="f5e99-210">Обратите внимание на то, что при этом вызывается не имеющий параметров неявный конструктор типа значения, который не является фактическим членом типа.</span><span class="sxs-lookup"><span data-stu-id="f5e99-210">Note that this invokes the value type's implicit parameterless constructor, which is not an actual member of the type.</span></span>
- <span data-ttu-id="f5e99-211">Выражение в форме `default(ValType)`, где `ValType` — это тип значения.</span><span class="sxs-lookup"><span data-stu-id="f5e99-211">An expression of the form `default(ValType)`, where `ValType` is a value type.</span></span>

<span data-ttu-id="f5e99-212">Если метод содержит как обязательные, так и необязательные параметры, необязательные параметры определяются в конце списка параметров после всех обязательных параметров.</span><span class="sxs-lookup"><span data-stu-id="f5e99-212">If a method includes both required and optional parameters, optional parameters are defined at the end of the parameter list, after all required parameters.</span></span>

<span data-ttu-id="f5e99-213">В следующем примере определяется метод `ExampleMethod`, который имеет один обязательный и два необязательных параметра.</span><span class="sxs-lookup"><span data-stu-id="f5e99-213">The following example defines a method, `ExampleMethod`, that has one required and two optional parameters.</span></span>

[!code-csharp[csSnippets.Methods#21](../../samples/snippets/csharp/concepts/methods/optional1.cs#21)]

<span data-ttu-id="f5e99-214">Если для вызова метода с несколькими необязательными аргументами используются позиционные аргументы, вызывающий объект должен предоставить аргумент для всех необязательных параметров, для которых предоставлен аргумент, от первого до последнего.</span><span class="sxs-lookup"><span data-stu-id="f5e99-214">If a method with multiple optional arguments is invoked using positional arguments, the caller must supply an argument for all optional parameters from the first one to the last one for which an argument is supplied.</span></span> <span data-ttu-id="f5e99-215">Например, если при использовании метода `ExampleMethod` вызывающий объект предоставляет аргумент для параметра `description`, он должен также предоставить его для параметра `optionalInt`.</span><span class="sxs-lookup"><span data-stu-id="f5e99-215">In the case of the  `ExampleMethod` method, for example, if the caller supplies an argument for the `description` parameter, it must also supply one for the `optionalInt` parameter.</span></span> <span data-ttu-id="f5e99-216">`opt.ExampleMethod(2, 2, "Addition of 2 and 2");` — допустимый вызов метода; `opt.ExampleMethod(2, , "Addition of 2 and 0");` вызывает ошибку компилятора "Аргумент отсутствует".</span><span class="sxs-lookup"><span data-stu-id="f5e99-216">`opt.ExampleMethod(2, 2, "Addition of 2 and 2");` is a valid method call; `opt.ExampleMethod(2, , "Addition of 2 and 0");` generates an "Argument missing" compiler error.</span></span>

<span data-ttu-id="f5e99-217">Если метод вызывается с помощью именованных аргументов или комбинации позиционных и именованных аргументов, вызывающий объект может опустить любые аргументы, следующие за последним позиционным аргументом в вызове метода.</span><span class="sxs-lookup"><span data-stu-id="f5e99-217">If a method is called using named arguments or a combination of positional and named arguments, the caller can omit any arguments that follow the last positional argument in the method call.</span></span>

<span data-ttu-id="f5e99-218">В следующем примере метод `ExampleMethod` вызывается трижды.</span><span class="sxs-lookup"><span data-stu-id="f5e99-218">The following example calls the `ExampleMethod` method three times.</span></span>  <span data-ttu-id="f5e99-219">В первых двух вызовах метода используются позиционные аргументы.</span><span class="sxs-lookup"><span data-stu-id="f5e99-219">The first two method calls use positional arguments.</span></span> <span data-ttu-id="f5e99-220">В первом пропускаются оба необязательных аргумента, а во втором — последний.</span><span class="sxs-lookup"><span data-stu-id="f5e99-220">The first omits both optional arguments, while the second omits the last argument.</span></span> <span data-ttu-id="f5e99-221">Третий вызов метода предоставляет позиционный аргумент для обязательного параметра, но использует именованный аргумент для передачи значения в параметр `description`, в то время как аргумент `optionalInt` опускается.</span><span class="sxs-lookup"><span data-stu-id="f5e99-221">The third method call supplies a positional argument for the required parameter but uses a named argument to supply a value to the `description` parameter while omitting the `optionalInt` argument.</span></span>

[!code-csharp[csSnippets.Methods#22](../../samples/snippets/csharp/concepts/methods/optional1.cs#22)]

<span data-ttu-id="f5e99-222">Использование необязательных параметров влияет на *разрешение перегрузки* или на способ, с помощью которого компилятор C# определяет, какая именно перегрузка должна вызываться при вызове метода, следующим образом:</span><span class="sxs-lookup"><span data-stu-id="f5e99-222">The use of optional parameters affects *overload resolution*, or the way in which the C# compiler determines which particular overload should be invoked by a method call, as follows:</span></span>

- <span data-ttu-id="f5e99-223">Метод, индексатор или конструктор является кандидатом на выполнение, если каждый из его параметров необязателен либо по имени или позиции соответствует одному и тому же аргументу в операторе вызова, и этот аргумент можно преобразовать в тип параметра.</span><span class="sxs-lookup"><span data-stu-id="f5e99-223">A method, indexer, or constructor is a candidate for execution if each of its parameters either is optional or corresponds, by name or by position, to a single argument in the calling statement, and that argument can be converted to the type of the parameter.</span></span>
- <span data-ttu-id="f5e99-224">Если найдено более одного кандидата, правила разрешения перегрузки для предпочтительных преобразований применяются к аргументам, указанным явно.</span><span class="sxs-lookup"><span data-stu-id="f5e99-224">If more than one candidate is found, overload resolution rules for preferred conversions are applied to the arguments that are explicitly specified.</span></span> <span data-ttu-id="f5e99-225">Опущенные аргументы для необязательных параметров игнорируются.</span><span class="sxs-lookup"><span data-stu-id="f5e99-225">Omitted arguments for optional parameters are ignored.</span></span>
- <span data-ttu-id="f5e99-226">Если два кандидата определяются как равно подходящие, предпочтение отдается кандидату без необязательных параметров, аргументы которых в вызове были опущены.</span><span class="sxs-lookup"><span data-stu-id="f5e99-226">If two candidates are judged to be equally good, preference goes to a candidate that does not have optional parameters for which arguments were omitted in the call.</span></span> <span data-ttu-id="f5e99-227">Это — последовательность определения приоритетов в разрешении перегрузки для кандидатов с меньшим числом параметров.</span><span class="sxs-lookup"><span data-stu-id="f5e99-227">This is a consequence of a general preference in overload resolution for candidates that have fewer parameters.</span></span>

<a name="return"></a>

## <a name="return-values"></a><span data-ttu-id="f5e99-228">Возвращаемые значения</span><span class="sxs-lookup"><span data-stu-id="f5e99-228">Return values</span></span>

<span data-ttu-id="f5e99-229">Методы могут возвращать значение вызывающему объекту.</span><span class="sxs-lookup"><span data-stu-id="f5e99-229">Methods can return a value to the caller.</span></span> <span data-ttu-id="f5e99-230">Если тип возврата, указываемый перед именем метода, не `void`, этот метод может возвращать значение с помощью ключевого слова `return`.</span><span class="sxs-lookup"><span data-stu-id="f5e99-230">If the return type (the type listed before the method name) is not `void`, the method can return the value by using the `return` keyword.</span></span> <span data-ttu-id="f5e99-231">Инструкция с ключевым словом `return`, за которым следует переменная, константа или выражение, соответствующие типу возврата, будут возвращать это значение объекту, вызвавшему метод.</span><span class="sxs-lookup"><span data-stu-id="f5e99-231">A statement with the `return` keyword followed by a variable, constant, or expression that matches the return type will return that value to the method caller.</span></span> <span data-ttu-id="f5e99-232">Методы с типом возврата, отличным от void, должны использовать ключевое слово `return` для возврата значения.</span><span class="sxs-lookup"><span data-stu-id="f5e99-232">Methods with a non-void return type are required to use the `return` keyword to return a value.</span></span> <span data-ttu-id="f5e99-233">Ключевое слове `return` также останавливает выполнение метода.</span><span class="sxs-lookup"><span data-stu-id="f5e99-233">The `return` keyword also stops the execution of the method.</span></span>

<span data-ttu-id="f5e99-234">Если тип возврата — `void`, инструкцию `return` без значения по-прежнему можно использовать для завершения выполнения метода.</span><span class="sxs-lookup"><span data-stu-id="f5e99-234">If the return type is `void`, a `return` statement without a value is still useful to stop the execution of the method.</span></span> <span data-ttu-id="f5e99-235">Без ключевого слова `return` этот метод будет останавливать выполнение при достижении конца блока кода.</span><span class="sxs-lookup"><span data-stu-id="f5e99-235">Without the `return` keyword, the method will stop executing when it reaches the end of the code block.</span></span>

<span data-ttu-id="f5e99-236">Например, в следующих двух методах ключевое слово `return` используется для возврата целочисленных значений.</span><span class="sxs-lookup"><span data-stu-id="f5e99-236">For example, these two methods use the `return` keyword to return integers:</span></span>

[!code-csharp[csSnippets.Methods#44](../../samples/snippets/csharp/concepts/methods/return44.cs#44)]

<span data-ttu-id="f5e99-237">Чтобы использовать значение, возвращаемое из метода, вызывающий метод может применять сам вызов метода везде, где будет достаточно значения того же типа.</span><span class="sxs-lookup"><span data-stu-id="f5e99-237">To use a value returned from a method, the calling method can use the method call itself anywhere a value of the same type would be sufficient.</span></span> <span data-ttu-id="f5e99-238">Можно также назначить возвращаемое значение переменной.</span><span class="sxs-lookup"><span data-stu-id="f5e99-238">You can also assign the return value to a variable.</span></span> <span data-ttu-id="f5e99-239">Например, следующие два примера кода достигают одной и той же цели.</span><span class="sxs-lookup"><span data-stu-id="f5e99-239">For example, the following two code examples accomplish the same goal:</span></span>

[!code-csharp[csSnippets.Methods#45](../../samples/snippets/csharp/concepts/methods/return44.cs#45)]

[!code-csharp[csSnippets.Methods#46](../../samples/snippets/csharp/concepts/methods/return44.cs#46)]

<span data-ttu-id="f5e99-240">Использование локальной переменной, в данном случае `result`, для сохранения значения является необязательным.</span><span class="sxs-lookup"><span data-stu-id="f5e99-240">Using a local variable, in this case, `result`, to store a value is optional.</span></span> <span data-ttu-id="f5e99-241">Это может улучшить читаемость кода или может оказаться необходимым, если нужно сохранить исходное значение аргумента для всей области метода.</span><span class="sxs-lookup"><span data-stu-id="f5e99-241">It may help the readability of the code, or it may be necessary if you need to store the original value of the argument for the entire scope of the method.</span></span>

<span data-ttu-id="f5e99-242">В некоторых случаях нужно, чтобы метод возвращал больше одного значения.</span><span class="sxs-lookup"><span data-stu-id="f5e99-242">Sometimes, you want your method to return more than a single value.</span></span> <span data-ttu-id="f5e99-243">Начиная с C# версии 7.0, это легко можно сделать с помощью *типов кортежей* и *литералов кортежей*.</span><span class="sxs-lookup"><span data-stu-id="f5e99-243">Starting with C# 7.0, you can do this easily by using *tuple types* and *tuple literals*.</span></span> <span data-ttu-id="f5e99-244">Тип кортежа определяет типы данных для элементов кортежа.</span><span class="sxs-lookup"><span data-stu-id="f5e99-244">The tuple type defines the data types of the tuple's elements.</span></span> <span data-ttu-id="f5e99-245">Литералы кортежей предоставляют фактические значения возвращаемого кортежа.</span><span class="sxs-lookup"><span data-stu-id="f5e99-245">Tuple literals provide the actual values of the returned tuple.</span></span> <span data-ttu-id="f5e99-246">В следующем примере `(string, string, string, int)` определяет тип кортежа, возвращаемый методом `GetPersonalInfo`.</span><span class="sxs-lookup"><span data-stu-id="f5e99-246">In the following example, `(string, string, string, int)` defines the tuple type that is returned by the `GetPersonalInfo` method.</span></span> <span data-ttu-id="f5e99-247">Выражение `(per.FirstName, per.MiddleName, per.LastName, per.Age)` представляет собой литерал кортежа; метод возвращает имя, отчество и фамилию, а также возраст объекта `PersonInfo`.</span><span class="sxs-lookup"><span data-stu-id="f5e99-247">The expression `(per.FirstName, per.MiddleName, per.LastName, per.Age)` is the tuple literal; the method returns the first, middle, and last name, along with the age, of a `PersonInfo` object.</span></span>

```csharp
public (string, string, string, int) GetPersonalInfo(string id)
{
    PersonInfo per = PersonInfo.RetrieveInfoById(id);
    return (per.FirstName, per.MiddleName, per.LastName, per.Age);
}
```

<span data-ttu-id="f5e99-248">После этого вызывающий объект может использовать возвращенный кортеж в коде следующего вида:</span><span class="sxs-lookup"><span data-stu-id="f5e99-248">The caller can then consume the returned tuple with code like the following:</span></span>

```csharp
var person = GetPersonalInfo("111111111")
Console.WriteLine($"{person.Item1} {person.Item3}: age = {person.Item4}");
```

<span data-ttu-id="f5e99-249">Имена могут также назначаться элементам кортежа в определении типа кортежа.</span><span class="sxs-lookup"><span data-stu-id="f5e99-249">Names can also be assigned to the tuple elements in the tuple type definition.</span></span> <span data-ttu-id="f5e99-250">В следующих примерах демонстрируется альтернативная версия метода `GetPersonalInfo`, в котором используются именованные элементы:</span><span class="sxs-lookup"><span data-stu-id="f5e99-250">The following example shows an alternate version of the `GetPersonalInfo` method that uses named elements:</span></span>

```csharp
public (string FName, string MName, string LName, int Age) GetPersonalInfo(string id)
{
    PersonInfo per = PersonInfo.RetrieveInfoById(id);
    return (per.FirstName, per.MiddleName, per.LastName, per.Age);
}
```

<span data-ttu-id="f5e99-251">После этого предыдущий вызов метода `GetPersonInfo` можно изменить следующим образом:</span><span class="sxs-lookup"><span data-stu-id="f5e99-251">The previous call to the `GetPersonInfo` method can then be modified as follows:</span></span>

```csharp
var person = GetPersonalInfo("111111111");
Console.WriteLine($"{person.FName} {person.LName}: age = {person.Age}");
```

<span data-ttu-id="f5e99-252">Если в качестве аргумента метод получает массив, а затем изменяет значение отдельных элементов, он может не возвращать массив, однако при желании вы можете это изменить для соблюдения правильного стиля или обеспечения эффективного потока передачи значений.</span><span class="sxs-lookup"><span data-stu-id="f5e99-252">If a method is passed an array as an argument and modifies the value of individual elements, it is not necessary for the method to return the array, although you may choose to do so for good style or functional flow of values.</span></span>  <span data-ttu-id="f5e99-253">Это связано с тем, что C# передает все ссылочные типы по значению, а значением ссылки на массив является указатель на массив.</span><span class="sxs-lookup"><span data-stu-id="f5e99-253">This is because C# passes all reference types by value, and the value of an array reference is the pointer to the array.</span></span> <span data-ttu-id="f5e99-254">В следующем примере изменения в содержимом массива `values`, сделанные в методе `DoubleValues`, может отслеживать любой код, имеющий ссылку на этот массив.</span><span class="sxs-lookup"><span data-stu-id="f5e99-254">In the following example, changes to the contents of the `values` array that are made in the `DoubleValues` method are observable by any code that has a reference to the array.</span></span>

[!code-csharp[csSnippets.Methods#101](../../samples/snippets/csharp/concepts/methods/returnarray1.cs#101)]

<a name="extension"></a>

## <a name="extension-methods"></a><span data-ttu-id="f5e99-255">Методы расширения</span><span class="sxs-lookup"><span data-stu-id="f5e99-255">Extension methods</span></span>

<span data-ttu-id="f5e99-256">Как правило, добавлять методы в существующий тип можно двумя способами:</span><span class="sxs-lookup"><span data-stu-id="f5e99-256">Ordinarily, there are two ways to add a method to an existing type:</span></span>

- <span data-ttu-id="f5e99-257">Изменение исходного кода для этого типа.</span><span class="sxs-lookup"><span data-stu-id="f5e99-257">Modify the source code for that type.</span></span> <span data-ttu-id="f5e99-258">Конечно, если вы не владеете исходным кодом этого типа, сделать это невозможно.</span><span class="sxs-lookup"><span data-stu-id="f5e99-258">You cannot do this, of course, if you do not own the type's source code.</span></span> <span data-ttu-id="f5e99-259">Если при этом в поддержку метода также добавляются поля закрытых данных, это изменение становится критическим.</span><span class="sxs-lookup"><span data-stu-id="f5e99-259">And this becomes a breaking change if you also add any private data fields to support the method.</span></span>
- <span data-ttu-id="f5e99-260">Определение нового метода в производном классе.</span><span class="sxs-lookup"><span data-stu-id="f5e99-260">Define the new method in a derived class.</span></span> <span data-ttu-id="f5e99-261">Нельзя добавить метод этим способом, используя наследование для других типов, таких как структуры и перечисления.</span><span class="sxs-lookup"><span data-stu-id="f5e99-261">A method cannot be added in this way using inheritance for other types, such as structures and enumerations.</span></span> <span data-ttu-id="f5e99-262">Кроме того, оно не позволяет "добавить" метод в запечатанный класс.</span><span class="sxs-lookup"><span data-stu-id="f5e99-262">Nor can it be used to "add" a method to a sealed class.</span></span>

<span data-ttu-id="f5e99-263">Методы расширения позволяют "добавить" метод в существующий тип, не меняя сам тип и не реализуя новый метод в наследуемом типе.</span><span class="sxs-lookup"><span data-stu-id="f5e99-263">Extension methods let you "add" a method to an existing type without modifying the type itself or implementing the new method in an inherited type.</span></span> <span data-ttu-id="f5e99-264">Кроме того, метод расширения может не входить в ту же сборку, в которую входит расширяемый им тип.</span><span class="sxs-lookup"><span data-stu-id="f5e99-264">The extension method also does not have to reside in the same assembly as the type it extends.</span></span> <span data-ttu-id="f5e99-265">Вызовите метод расширения, как будто он является определенным членом типа.</span><span class="sxs-lookup"><span data-stu-id="f5e99-265">You call an extension method as if it were a defined member of a type.</span></span>

<span data-ttu-id="f5e99-266">Дополнительные сведения см. в статье [Методы расширения](programming-guide/classes-and-structs/extension-methods.md).</span><span class="sxs-lookup"><span data-stu-id="f5e99-266">For more information, see [Extension Methods](programming-guide/classes-and-structs/extension-methods.md).</span></span>

<a name="async"></a>

## <a name="async-methods"></a><span data-ttu-id="f5e99-267">Асинхронные методы</span><span class="sxs-lookup"><span data-stu-id="f5e99-267">Async Methods</span></span>

<span data-ttu-id="f5e99-268">С помощью функции async можно вызывать асинхронные методы, не прибегая к использованию явных обратных вызовов или ручному разделению кода между несколькими методами или лямбда-выражениями.</span><span class="sxs-lookup"><span data-stu-id="f5e99-268">By using the async feature, you can invoke asynchronous methods without using explicit callbacks or manually splitting your code across multiple methods or lambda expressions.</span></span>

<span data-ttu-id="f5e99-269">Если пометить метод с помощью модификатора [async](language-reference/keywords/async.md) , можно использовать в этом методе инструкцию [await](language-reference/operators/await.md) .</span><span class="sxs-lookup"><span data-stu-id="f5e99-269">If you mark a method with the [async](language-reference/keywords/async.md) modifier, you can use the [await](language-reference/operators/await.md) operator in the method.</span></span> <span data-ttu-id="f5e99-270">Если ожидаемая задача не завершена, то достигнув выражения `await` в асинхронном методе, управление возвращается вызывающему объекту, а выполнение метода с ключевым словом `await` приостанавливается до завершения выполнения ожидаемой задачи.</span><span class="sxs-lookup"><span data-stu-id="f5e99-270">When control reaches an `await` expression in the async method, control returns to the caller if the awaited task is not completed, and progress in the method with the `await` keyword is suspended until the awaited task completes.</span></span> <span data-ttu-id="f5e99-271">После завершения задачи можно возобновить выполнение в методе.</span><span class="sxs-lookup"><span data-stu-id="f5e99-271">When the task is complete, execution can resume in the method.</span></span>

> [!NOTE]
> <span data-ttu-id="f5e99-272">Асинхронный метод возвращается в вызывающий объект, когда он встречает первый ожидаемый объект, выполнение которого еще не завершено, или когда выполнение асинхронного метода доходит до конца — в зависимости от того, что происходит раньше.</span><span class="sxs-lookup"><span data-stu-id="f5e99-272">An async method returns to the caller when either it encounters the first awaited object that's not yet complete or it gets to the end of the async method, whichever occurs first.</span></span>

<span data-ttu-id="f5e99-273">Асинхронный метод обычно имеет тип возвращаемого значения <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.Task>, <xref:System.Collections.Generic.IAsyncEnumerable%601> или `void`.</span><span class="sxs-lookup"><span data-stu-id="f5e99-273">An async method typically has a return type of <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.Task>, <xref:System.Collections.Generic.IAsyncEnumerable%601>or `void`.</span></span> <span data-ttu-id="f5e99-274">Тип возвращаемого значения `void` в основном используется для определения обработчиков событий, где требуется возвращать тип `void`.</span><span class="sxs-lookup"><span data-stu-id="f5e99-274">The `void` return type is used primarily to define event handlers, where a `void` return type is required.</span></span> <span data-ttu-id="f5e99-275">Асинхронный метод, который возвращает тип `void`, не может быть ожидающим. Вызывающий объект метода, возвращающего значение типа void, не может перехватывать исключения, которые выдает этот метод.</span><span class="sxs-lookup"><span data-stu-id="f5e99-275">An async method that returns `void` can't be awaited, and the caller of a void-returning method can't catch exceptions that the method throws.</span></span> <span data-ttu-id="f5e99-276">Начиная с C# 7.0 асинхронный метод может возвращать [любой тип вида задачи](./whats-new/csharp-7.md#generalized-async-return-types).</span><span class="sxs-lookup"><span data-stu-id="f5e99-276">Starting with C# 7.0, an async method can have [any task-like return type](./whats-new/csharp-7.md#generalized-async-return-types).</span></span>

<span data-ttu-id="f5e99-277">В следующем примере `DelayAsync` представляет собой асинхронный метод с оператором return, который возвращает целое число.</span><span class="sxs-lookup"><span data-stu-id="f5e99-277">In the following example, `DelayAsync` is an async method that has a return statement that returns an integer.</span></span> <span data-ttu-id="f5e99-278">Поскольку этот метод асинхронный, его объявление должно иметь тип возвращаемого значения `Task<int>`.</span><span class="sxs-lookup"><span data-stu-id="f5e99-278">Because it is an async method, its method declaration must have a return type of `Task<int>`.</span></span> <span data-ttu-id="f5e99-279">Поскольку тип возврата — `Task<int>`, вычисление выражения `await` в `DoSomethingAsync` создает целое число, как показывает следующий оператор: `int result = await delayTask`.</span><span class="sxs-lookup"><span data-stu-id="f5e99-279">Because the return type is `Task<int>`, the evaluation of the `await` expression in `DoSomethingAsync` produces an integer, as the following `int result = await delayTask` statement demonstrates.</span></span>

:::code language="csharp" source="programming-guide/classes-and-structs/snippets/classes-and-structs/methods/Program.cs":::

<span data-ttu-id="f5e99-280">Асинхронный метод не может объявлять параметры [in](language-reference/keywords/in-parameter-modifier.md), [ref](language-reference/keywords/ref.md) или [out](language-reference/keywords/out-parameter-modifier.md), но может вызывать методы, имеющие такие параметры.</span><span class="sxs-lookup"><span data-stu-id="f5e99-280">An async method can't declare any [in](language-reference/keywords/in-parameter-modifier.md), [ref](language-reference/keywords/ref.md), or [out](language-reference/keywords/out-parameter-modifier.md) parameters, but it can call methods that have such parameters.</span></span>

 <span data-ttu-id="f5e99-281">Дополнительные сведения об асинхронных методах см. в разделах [Асинхронное программирование с использованием ключевых слов async и await (C#)](async.md) и [Типы возвращаемых значений асинхронных операций](programming-guide/concepts/async/async-return-types.md).</span><span class="sxs-lookup"><span data-stu-id="f5e99-281">For more information about async methods, see [Asynchronous programming with async and await](async.md) and [Async return types](programming-guide/concepts/async/async-return-types.md).</span></span>

<a name="expr"></a>

## <a name="expression-bodied-members"></a><span data-ttu-id="f5e99-282">Элементы, воплощающие выражение</span><span class="sxs-lookup"><span data-stu-id="f5e99-282">Expression-bodied members</span></span>

<span data-ttu-id="f5e99-283">Часто используются определения методов, которые просто немедленно возвращаются с результатом выражения или которые имеют единственную инструкцию в тексте метода.</span><span class="sxs-lookup"><span data-stu-id="f5e99-283">It is common to have method definitions that simply return immediately with the result of an expression, or that have a single statement as the body of the method.</span></span>  <span data-ttu-id="f5e99-284">Для определения таких методов существует сокращенный синтаксис с использованием `=>`:</span><span class="sxs-lookup"><span data-stu-id="f5e99-284">There is a syntax shortcut for defining such methods using `=>`:</span></span>

```csharp
public Point Move(int dx, int dy) => new Point(x + dx, y + dy);
public void Print() => Console.WriteLine(First + " " + Last);
// Works with operators, properties, and indexers too.
public static Complex operator +(Complex a, Complex b) => a.Add(b);
public string Name => First + " " + Last;
public Customer this[long id] => store.LookupCustomer(id);
```

<span data-ttu-id="f5e99-285">Если метод возвращает `void` или является асинхронным, текст этого метода должен быть выражением оператора (как и при использовании лямбда-выражений).</span><span class="sxs-lookup"><span data-stu-id="f5e99-285">If the method returns `void` or is an async method, the body of the method must be a statement expression (same as with lambdas).</span></span>  <span data-ttu-id="f5e99-286">Свойства и индексаторы должны быть доступны только для чтения, и использовать ключевое слово метода доступа `get` не следует.</span><span class="sxs-lookup"><span data-stu-id="f5e99-286">For properties and indexers, they must be read-only, and you do not use the `get` accessor keyword.</span></span>

<a name="iterators"></a>

## <a name="iterators"></a><span data-ttu-id="f5e99-287">Iterators</span><span class="sxs-lookup"><span data-stu-id="f5e99-287">Iterators</span></span>

<span data-ttu-id="f5e99-288">Итератор выполняет настраиваемую итерацию по коллекции, например по списку или массиву.</span><span class="sxs-lookup"><span data-stu-id="f5e99-288">An iterator performs a custom iteration over a collection, such as a list or an array.</span></span> <span data-ttu-id="f5e99-289">Итератор использует инструкцию [yield return](language-reference/keywords/yield.md) для возврата всех элементов по одному.</span><span class="sxs-lookup"><span data-stu-id="f5e99-289">An iterator uses the [yield return](language-reference/keywords/yield.md) statement to return each element one at a time.</span></span> <span data-ttu-id="f5e99-290">По достижении оператора `yield return` текущее расположение запоминается, чтобы вызывающий объект мог запросить следующий элемент в последовательности.</span><span class="sxs-lookup"><span data-stu-id="f5e99-290">When a `yield return` statement is reached, the current location is remembered so that the caller can request the next element in the sequence.</span></span>

<span data-ttu-id="f5e99-291">Тип возврата итератора может быть <xref:System.Collections.IEnumerable>, <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.IEnumerator> или <xref:System.Collections.Generic.IEnumerator%601>.</span><span class="sxs-lookup"><span data-stu-id="f5e99-291">The return type of an iterator can be <xref:System.Collections.IEnumerable>, <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.IEnumerator>, or <xref:System.Collections.Generic.IEnumerator%601>.</span></span>

<span data-ttu-id="f5e99-292">Дополнительные сведения см. в разделе [Итераторы](programming-guide/concepts/iterators.md).</span><span class="sxs-lookup"><span data-stu-id="f5e99-292">For more information, see [Iterators](programming-guide/concepts/iterators.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="f5e99-293">См. также раздел</span><span class="sxs-lookup"><span data-stu-id="f5e99-293">See also</span></span>

- [<span data-ttu-id="f5e99-294">Модификаторы доступа</span><span class="sxs-lookup"><span data-stu-id="f5e99-294">Access Modifiers</span></span>](language-reference/keywords/access-modifiers.md)
- [<span data-ttu-id="f5e99-295">Статические классы и члены статических классов</span><span class="sxs-lookup"><span data-stu-id="f5e99-295">Static Classes and Static Class Members</span></span>](programming-guide/classes-and-structs/static-classes-and-static-class-members.md)
- [<span data-ttu-id="f5e99-296">Наследование</span><span class="sxs-lookup"><span data-stu-id="f5e99-296">Inheritance</span></span>](programming-guide/classes-and-structs/inheritance.md)
- [<span data-ttu-id="f5e99-297">Абстрактные и запечатанные классы и члены классов</span><span class="sxs-lookup"><span data-stu-id="f5e99-297">Abstract and Sealed Classes and Class Members</span></span>](programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md)
- [<span data-ttu-id="f5e99-298">params</span><span class="sxs-lookup"><span data-stu-id="f5e99-298">params</span></span>](language-reference/keywords/params.md)
- [<span data-ttu-id="f5e99-299">out</span><span class="sxs-lookup"><span data-stu-id="f5e99-299">out</span></span>](language-reference/keywords/out-parameter-modifier.md)
- [<span data-ttu-id="f5e99-300">ref</span><span class="sxs-lookup"><span data-stu-id="f5e99-300">ref</span></span>](language-reference/keywords/ref.md)
- [<span data-ttu-id="f5e99-301">in</span><span class="sxs-lookup"><span data-stu-id="f5e99-301">in</span></span>](language-reference/keywords/in-parameter-modifier.md)
- [<span data-ttu-id="f5e99-302">Передача параметров</span><span class="sxs-lookup"><span data-stu-id="f5e99-302">Passing Parameters</span></span>](programming-guide/classes-and-structs/passing-parameters.md)
