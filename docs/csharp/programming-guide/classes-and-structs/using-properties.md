---
title: Руководство по программированию на C#. Использование свойств
description: В этих примерах показано использование свойств в C#. Узнайте, как методы доступа get и set реализуют доступ на чтение и запись, и ознакомьтесь с использованием свойств.
ms.date: 07/20/2015
helpviewer_keywords:
- set accessor [C#]
- get accessor [C#]
- properties [C#], about properties
ms.assetid: f7f67b05-0983-4cdb-96af-1855d24c967c
ms.openlocfilehash: 16ff0f02db9640ad8cfe41fce9ce954cb75b4e08
ms.sourcegitcommit: e3cf8227573e13b8e1f4e3dc007404881cdafe47
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/11/2021
ms.locfileid: "103190337"
---
# <a name="using-properties-c-programming-guide"></a><span data-ttu-id="a3b77-104">Использование свойств (Руководство по программированию в C#)</span><span class="sxs-lookup"><span data-stu-id="a3b77-104">Using Properties (C# Programming Guide)</span></span>

<span data-ttu-id="a3b77-105">Свойства сочетают в себе возможности полей и методов.</span><span class="sxs-lookup"><span data-stu-id="a3b77-105">Properties combine aspects of both fields and methods.</span></span> <span data-ttu-id="a3b77-106">Пользователю объекта свойство представляется как поле, и для доступа к нему применяется тот же синтаксис.</span><span class="sxs-lookup"><span data-stu-id="a3b77-106">To the user of an object, a property appears to be a field, accessing the property requires the same syntax.</span></span> <span data-ttu-id="a3b77-107">При реализации класса свойство представляется в виде одного или двух блоков кода для методов доступа [get](../../language-reference/keywords/get.md) и (или) [set](../../language-reference/keywords/set.md).</span><span class="sxs-lookup"><span data-stu-id="a3b77-107">To the implementer of a class, a property is one or two code blocks, representing a [get](../../language-reference/keywords/get.md) accessor and/or a [set](../../language-reference/keywords/set.md) accessor.</span></span> <span data-ttu-id="a3b77-108">Блок кода для метода доступа `get` выполняется только при считывании свойства, а для метода `set` — при присвоении свойству нового значения.</span><span class="sxs-lookup"><span data-stu-id="a3b77-108">The code block for the `get` accessor is executed when the property is read; the code block for the `set` accessor is executed when the property is assigned a new value.</span></span> <span data-ttu-id="a3b77-109">Свойство без метода доступа `set` доступно только для чтения.</span><span class="sxs-lookup"><span data-stu-id="a3b77-109">A property without a `set` accessor is considered read-only.</span></span> <span data-ttu-id="a3b77-110">Свойство без метода доступа `get` доступно только для записи.</span><span class="sxs-lookup"><span data-stu-id="a3b77-110">A property without a `get` accessor is considered write-only.</span></span> <span data-ttu-id="a3b77-111">Свойство, для которого определены оба этих метода, доступно для чтения и записи.</span><span class="sxs-lookup"><span data-stu-id="a3b77-111">A property that has both accessors is read-write.</span></span> <span data-ttu-id="a3b77-112">В C# 9 и более поздних версий можно использовать метод доступа `init` вместо `set`, чтобы сделать свойство доступным только для чтения.</span><span class="sxs-lookup"><span data-stu-id="a3b77-112">In C# 9 and later, you can use an `init` accessor instead of a `set` accessor to make the property read-only.</span></span>

<span data-ttu-id="a3b77-113">В отличие от полей, свойства не классифицируются как переменные.</span><span class="sxs-lookup"><span data-stu-id="a3b77-113">Unlike fields, properties are not classified as variables.</span></span> <span data-ttu-id="a3b77-114">Соответственно, нельзя передать свойство в качестве параметра [ref](../../language-reference/keywords/ref.md) или [out](../../language-reference/keywords/out-parameter-modifier.md).</span><span class="sxs-lookup"><span data-stu-id="a3b77-114">Therefore, you cannot pass a property as a [ref](../../language-reference/keywords/ref.md) or [out](../../language-reference/keywords/out-parameter-modifier.md) parameter.</span></span>

<span data-ttu-id="a3b77-115">Свойства нашли широкое применение в программировании. Их можно использовать для проверки данных перед подтверждением изменения; для прозрачного предоставления доступа к данным класса, которые фактически извлекаются из других источников, например из базы данных; для выполнения действия при изменении данных (например, в этом случае может создаваться событие или изменяться значение других полей).</span><span class="sxs-lookup"><span data-stu-id="a3b77-115">Properties have many uses: they can validate data before allowing a change; they can transparently expose data on a class where that data is actually retrieved from some other source, such as a database; they can take an action when data is changed, such as raising an event, or changing the value of other fields.</span></span>

<span data-ttu-id="a3b77-116">При объявлении свойств в блоке класса указывается уровень доступа поля, затем тип и имя свойства, а после этого блок кода, в котором объявляются методы доступа `get` и (или) `set`.</span><span class="sxs-lookup"><span data-stu-id="a3b77-116">Properties are declared in the class block by specifying the access level of the field, followed by the type of the property, followed by the name of the property, and followed by a code block that declares a `get`-accessor and/or a `set` accessor.</span></span> <span data-ttu-id="a3b77-117">Пример:</span><span class="sxs-lookup"><span data-stu-id="a3b77-117">For example:</span></span>

[!code-csharp[csProgGuideProperties#7](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideProperties/CS/Properties.cs#7)]

<span data-ttu-id="a3b77-118">В этом примере `Month` объявляется как свойство, а метод доступа `set` обеспечивает установку значения `Month` в диапазоне от 1 до 12.</span><span class="sxs-lookup"><span data-stu-id="a3b77-118">In this example, `Month` is declared as a property so that the `set` accessor can make sure that the `Month` value is set between 1 and 12.</span></span> <span data-ttu-id="a3b77-119">Для отслеживания фактического значения свойство `Month` использует частное поле.</span><span class="sxs-lookup"><span data-stu-id="a3b77-119">The `Month` property uses a private field to track the actual value.</span></span> <span data-ttu-id="a3b77-120">Фактическое местоположение данных свойства часто называется "резервным хранилищем".</span><span class="sxs-lookup"><span data-stu-id="a3b77-120">The real location of a property's data is often referred to as the property's "backing store."</span></span> <span data-ttu-id="a3b77-121">Как правило, в качестве резервного хранилища свойства используют частные поля.</span><span class="sxs-lookup"><span data-stu-id="a3b77-121">It is common for properties to use private fields as a backing store.</span></span> <span data-ttu-id="a3b77-122">Поле помечается как частное для того, чтобы гарантировать возможность его изменения только посредством вызова свойства.</span><span class="sxs-lookup"><span data-stu-id="a3b77-122">The field is marked private in order to make sure that it can only be changed by calling the property.</span></span> <span data-ttu-id="a3b77-123">Дополнительные сведения об ограничениях открытого и закрытого доступа см. в разделе [Модификаторы доступа](./access-modifiers.md).</span><span class="sxs-lookup"><span data-stu-id="a3b77-123">For more information about public and private access restrictions, see [Access Modifiers](./access-modifiers.md).</span></span>

<span data-ttu-id="a3b77-124">Автоматически реализуемые свойства поддерживают упрощенный синтаксис для простых объявлений свойств.</span><span class="sxs-lookup"><span data-stu-id="a3b77-124">Auto-implemented properties provide simplified syntax for simple property declarations.</span></span> <span data-ttu-id="a3b77-125">Дополнительные сведения см. в разделе [Автоматически реализуемые свойства](auto-implemented-properties.md).</span><span class="sxs-lookup"><span data-stu-id="a3b77-125">For more information, see [Auto-Implemented Properties](auto-implemented-properties.md).</span></span>

## <a name="the-get-accessor"></a><span data-ttu-id="a3b77-126">Метод доступа get</span><span class="sxs-lookup"><span data-stu-id="a3b77-126">The get accessor</span></span>

<span data-ttu-id="a3b77-127">Тело метода доступа `get` похоже на тело метода.</span><span class="sxs-lookup"><span data-stu-id="a3b77-127">The body of the `get` accessor resembles that of a method.</span></span> <span data-ttu-id="a3b77-128">Оно должно возвращать значение заданного типа свойства.</span><span class="sxs-lookup"><span data-stu-id="a3b77-128">It must return a value of the property type.</span></span> <span data-ttu-id="a3b77-129">Выполнение метода доступа `get` эквивалентно считыванию значения поля.</span><span class="sxs-lookup"><span data-stu-id="a3b77-129">The execution of the `get` accessor is equivalent to reading the value of the field.</span></span> <span data-ttu-id="a3b77-130">Например, если включена оптимизация и метод доступа `get` возвращает частную переменную, вызов метода доступа `get` определяется компилятором как встроенный, что позволяет исключить затраты ресурсов на вызов метода.</span><span class="sxs-lookup"><span data-stu-id="a3b77-130">For example, when you are returning the private variable from the `get` accessor and optimizations are enabled, the call to the `get` accessor method is inlined by the compiler so there is no method-call overhead.</span></span> <span data-ttu-id="a3b77-131">Тем не менее виртуальный метод доступа `get` не может определяться как встроенный, поскольку во время компиляции компилятору не известно, как метод может быть фактически вызван во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="a3b77-131">However, a virtual `get` accessor method cannot be inlined because the compiler does not know at compile-time which method may actually be called at run time.</span></span> <span data-ttu-id="a3b77-132">Ниже показан метод доступа `get`, возвращающий значение частного поля `_name`:</span><span class="sxs-lookup"><span data-stu-id="a3b77-132">The following is a `get` accessor that returns the value of a private field `_name`:</span></span>

[!code-csharp[csProgGuideProperties#8](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideProperties/CS/Properties.cs#8)]

<span data-ttu-id="a3b77-133">При ссылке на свойство (кроме случаев, когда свойство является целью присваивания) вызывается метод доступа `get`, который считывает значение свойства.</span><span class="sxs-lookup"><span data-stu-id="a3b77-133">When you reference the property, except as the target of an assignment, the `get` accessor is invoked to read the value of the property.</span></span> <span data-ttu-id="a3b77-134">Пример:</span><span class="sxs-lookup"><span data-stu-id="a3b77-134">For example:</span></span>

[!code-csharp[csProgGuideProperties#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideProperties/CS/Properties.cs#9)]

<span data-ttu-id="a3b77-135">Метод доступа `get` должен завершаться инструкцией [return](../../language-reference/keywords/return.md) или [throw](../../language-reference/keywords/throw.md), при этом управление не может передаваться из тела метода доступа.</span><span class="sxs-lookup"><span data-stu-id="a3b77-135">The `get` accessor must end in a [return](../../language-reference/keywords/return.md) or [throw](../../language-reference/keywords/throw.md) statement, and control cannot flow off the accessor body.</span></span>

<span data-ttu-id="a3b77-136">Изменение состояния объекта с помощью метода доступа `get` считается ошибочным стилем программирования.</span><span class="sxs-lookup"><span data-stu-id="a3b77-136">It is a bad programming style to change the state of the object by using the `get` accessor.</span></span> <span data-ttu-id="a3b77-137">Например, побочным эффектом следующего метода доступа является изменение состояния объекта каждый раз при доступе к полю `_number`.</span><span class="sxs-lookup"><span data-stu-id="a3b77-137">For example, the following accessor produces the side effect of changing the state of the object every time that the `_number` field is accessed.</span></span>

[!code-csharp[csProgGuideProperties#10](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideProperties/CS/Properties.cs#10)]

<span data-ttu-id="a3b77-138">Метод доступа `get` можно использовать для возврата значения поля напрямую или после вычисления.</span><span class="sxs-lookup"><span data-stu-id="a3b77-138">The `get` accessor can be used to return the field value or to compute it and return it.</span></span> <span data-ttu-id="a3b77-139">Пример:</span><span class="sxs-lookup"><span data-stu-id="a3b77-139">For example:</span></span>

[!code-csharp[csProgGuideProperties#11](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideProperties/CS/Properties.cs#11)]

<span data-ttu-id="a3b77-140">Если в предыдущем фрагменте кода свойству `Name` не присвоено значение, будет возвращено значение `NA`.</span><span class="sxs-lookup"><span data-stu-id="a3b77-140">In the previous code segment, if you do not assign a value to the `Name` property, it will return the value `NA`.</span></span>

## <a name="the-set-accessor"></a><span data-ttu-id="a3b77-141">Метод доступа set</span><span class="sxs-lookup"><span data-stu-id="a3b77-141">The set accessor</span></span>

<span data-ttu-id="a3b77-142">Метод доступа `set` похож на метод с типом возвращаемого значения [void](../../language-reference/builtin-types/void.md).</span><span class="sxs-lookup"><span data-stu-id="a3b77-142">The `set` accessor resembles a method whose return type is [void](../../language-reference/builtin-types/void.md).</span></span> <span data-ttu-id="a3b77-143">В нем используется неявный параметр `value`, тип которого соответствует типу свойства.</span><span class="sxs-lookup"><span data-stu-id="a3b77-143">It uses an implicit parameter called `value`, whose type is the type of the property.</span></span> <span data-ttu-id="a3b77-144">В следующем примере метод доступа `set` добавляется к свойству `Name`:</span><span class="sxs-lookup"><span data-stu-id="a3b77-144">In the following example, a `set` accessor is added to the `Name` property:</span></span>

[!code-csharp[csProgGuideProperties#12](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideProperties/CS/Properties.cs#12)]

<span data-ttu-id="a3b77-145">При присвоении значения свойству вызывается метод доступа `set` с аргументом, содержащим новое значение.</span><span class="sxs-lookup"><span data-stu-id="a3b77-145">When you assign a value to the property, the `set` accessor is invoked by using an argument that provides the new value.</span></span> <span data-ttu-id="a3b77-146">Пример:</span><span class="sxs-lookup"><span data-stu-id="a3b77-146">For example:</span></span>

[!code-csharp[csProgGuideProperties#13](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideProperties/CS/Properties.cs#13)]

<span data-ttu-id="a3b77-147">Использование имени явного параметра (`value`) для объявления локальной переменной в методе доступа `set` является ошибкой.</span><span class="sxs-lookup"><span data-stu-id="a3b77-147">It is an error to use the implicit parameter name, `value`, for a local variable declaration in a `set` accessor.</span></span>

## <a name="the-init-accessor"></a><span data-ttu-id="a3b77-148">Метод доступа init</span><span class="sxs-lookup"><span data-stu-id="a3b77-148">The init accessor</span></span>

<span data-ttu-id="a3b77-149">Код для создания метода доступа `init` аналогичен коду для создания метода доступа `set`, за исключением того, что используется ключевое слово `init` вместо `set`.</span><span class="sxs-lookup"><span data-stu-id="a3b77-149">The code to create an `init` accessor is the same as the code to create a `set` accessor except that you use the `init` keyword instead of `set`.</span></span> <span data-ttu-id="a3b77-150">Различие заключается в том, что метод доступа `init` можно использовать только в конструкторе или с помощью [инициализатора объекта](object-and-collection-initializers.md).</span><span class="sxs-lookup"><span data-stu-id="a3b77-150">The difference is that the `init` accessor can only be used in the constructor or by using an [object-initializer](object-and-collection-initializers.md).</span></span>

## <a name="remarks"></a><span data-ttu-id="a3b77-151">Комментарии</span><span class="sxs-lookup"><span data-stu-id="a3b77-151">Remarks</span></span>

<span data-ttu-id="a3b77-152">Свойства могут быть помечены как `public`, `private`, `protected`, `internal`, `protected internal` или `private protected`.</span><span class="sxs-lookup"><span data-stu-id="a3b77-152">Properties can be marked as `public`, `private`, `protected`, `internal`, `protected internal`, or `private protected`.</span></span> <span data-ttu-id="a3b77-153">Эти модификаторы доступа определяют, каким образом пользователи класса смогут получать доступ к свойству.</span><span class="sxs-lookup"><span data-stu-id="a3b77-153">These access modifiers define how users of the class can access the property.</span></span> <span data-ttu-id="a3b77-154">Методы доступа `get` и `set` для одного свойства могут иметь разные модификаторы доступа.</span><span class="sxs-lookup"><span data-stu-id="a3b77-154">The `get` and `set` accessors for the same property may have different access modifiers.</span></span> <span data-ttu-id="a3b77-155">Например, метод доступа `get` может иметь модификатор `public`, разрешающий доступ из-за пределов типа только для чтения, а метод доступа `set` — модификатор `private` или `protected`.</span><span class="sxs-lookup"><span data-stu-id="a3b77-155">For example, the `get` may be `public` to allow read-only access from outside the type, and the `set` may be `private` or `protected`.</span></span> <span data-ttu-id="a3b77-156">Дополнительные сведения см. в статье [Модификаторы доступа](./access-modifiers.md).</span><span class="sxs-lookup"><span data-stu-id="a3b77-156">For more information, see [Access Modifiers](./access-modifiers.md).</span></span>

<span data-ttu-id="a3b77-157">Свойство может быть объявлено как статическое с помощью ключевого слова `static`.</span><span class="sxs-lookup"><span data-stu-id="a3b77-157">A property may be declared as a static property by using the `static` keyword.</span></span> <span data-ttu-id="a3b77-158">Это делает свойство доступным для вызывающих объектов в любое время, даже если экземпляр класса не существует.</span><span class="sxs-lookup"><span data-stu-id="a3b77-158">This makes the property available to callers at any time, even if no instance of the class exists.</span></span> <span data-ttu-id="a3b77-159">Дополнительные сведения см. в статье [Статические классы и члены статических классов](./static-classes-and-static-class-members.md).</span><span class="sxs-lookup"><span data-stu-id="a3b77-159">For more information, see [Static Classes and Static Class Members](./static-classes-and-static-class-members.md).</span></span>

<span data-ttu-id="a3b77-160">Свойство может быть помечено как виртуальное с помощью ключевого слова [virtual](../../language-reference/keywords/virtual.md).</span><span class="sxs-lookup"><span data-stu-id="a3b77-160">A property may be marked as a virtual property by using the [virtual](../../language-reference/keywords/virtual.md) keyword.</span></span> <span data-ttu-id="a3b77-161">Это позволяет производным классам переопределять поведение свойства с помощью ключевого слова [override](../../language-reference/keywords/override.md).</span><span class="sxs-lookup"><span data-stu-id="a3b77-161">This enables derived classes to override the property behavior by using the [override](../../language-reference/keywords/override.md) keyword.</span></span> <span data-ttu-id="a3b77-162">Дополнительные сведения об этих параметрах см. в разделе [Наследование](inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="a3b77-162">For more information about these options, see [Inheritance](inheritance.md).</span></span>

<span data-ttu-id="a3b77-163">Свойство, переопределяющее виртуальное свойство, также может быть запечатанным ([sealed](../../language-reference/keywords/sealed.md)). Это указывает, что для производных классов оно больше не является виртуальным.</span><span class="sxs-lookup"><span data-stu-id="a3b77-163">A property overriding a virtual property can also be [sealed](../../language-reference/keywords/sealed.md), specifying that for derived classes it is no longer virtual.</span></span> <span data-ttu-id="a3b77-164">Наконец, свойство можно объявить абстрактным ([abstract](../../language-reference/keywords/abstract.md)).</span><span class="sxs-lookup"><span data-stu-id="a3b77-164">Lastly, a property can be declared [abstract](../../language-reference/keywords/abstract.md).</span></span> <span data-ttu-id="a3b77-165">Это означает, что в классе не будет определена реализация такого свойства, и в производных классах должны использоваться собственные реализации.</span><span class="sxs-lookup"><span data-stu-id="a3b77-165">This means that there is no implementation in the class, and derived classes must write their own implementation.</span></span> <span data-ttu-id="a3b77-166">Дополнительные сведения об этих параметрах см. в разделе [Абстрактные и запечатанные классы и члены классов](abstract-and-sealed-classes-and-class-members.md).</span><span class="sxs-lookup"><span data-stu-id="a3b77-166">For more information about these options, see [Abstract and Sealed Classes and Class Members](abstract-and-sealed-classes-and-class-members.md).</span></span>
  
> [!NOTE]
> <span data-ttu-id="a3b77-167">Использование модификаторов [virtual](../../language-reference/keywords/virtual.md), [abstract](../../language-reference/keywords/abstract.md) или [override](../../language-reference/keywords/override.md) в методе доступа статического ([static](../../language-reference/keywords/static.md)) свойства является ошибкой.</span><span class="sxs-lookup"><span data-stu-id="a3b77-167">It is an error to use a [virtual](../../language-reference/keywords/virtual.md), [abstract](../../language-reference/keywords/abstract.md), or [override](../../language-reference/keywords/override.md) modifier on an accessor of a [static](../../language-reference/keywords/static.md) property.</span></span>

## <a name="examples"></a><span data-ttu-id="a3b77-168">Примеры</span><span class="sxs-lookup"><span data-stu-id="a3b77-168">Examples</span></span>

<span data-ttu-id="a3b77-169">В этом примере демонстрируются свойства экземпляра, а также статические и доступные только для чтения свойства.</span><span class="sxs-lookup"><span data-stu-id="a3b77-169">This example demonstrates instance, static, and read-only properties.</span></span> <span data-ttu-id="a3b77-170">Этот метод принимает введенное с клавиатуры имя сотрудника, увеличивает значение `NumberOfEmployees` на 1, после чего отображает имя и номер сотрудника.</span><span class="sxs-lookup"><span data-stu-id="a3b77-170">It accepts the name of the employee from the keyboard, increments `NumberOfEmployees` by 1, and displays the Employee name and number.</span></span>

[!code-csharp[csProgGuideProperties#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideProperties/CS/Properties.cs#2)]

## <a name="hidden-property-example"></a><span data-ttu-id="a3b77-171">Пример скрытого свойства</span><span class="sxs-lookup"><span data-stu-id="a3b77-171">Hidden property example</span></span>

<span data-ttu-id="a3b77-172">В этом примере демонстрируется доступ к свойству базового класса, которое скрыто в производном классе другим свойством с таким же именем:</span><span class="sxs-lookup"><span data-stu-id="a3b77-172">This example demonstrates how to access a property in a base class that is hidden by another property that has the same name in a derived class:</span></span>

[!code-csharp[csProgGuideProperties#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideProperties/CS/Properties.cs#3)]

<span data-ttu-id="a3b77-173">На что следует обратить внимание в предыдущем примере:</span><span class="sxs-lookup"><span data-stu-id="a3b77-173">The following are important points in the previous example:</span></span>

- <span data-ttu-id="a3b77-174">Свойство `Name` в производном классе скрывает свойство `Name` базового класса.</span><span class="sxs-lookup"><span data-stu-id="a3b77-174">The property `Name` in the derived class hides the property `Name` in the base class.</span></span> <span data-ttu-id="a3b77-175">В таком случае в объявлении свойства в производном классе используется модификатор `new`:</span><span class="sxs-lookup"><span data-stu-id="a3b77-175">In such a case, the `new` modifier is used in the declaration of the property in the derived class:</span></span>

     [!code-csharp[csProgGuideProperties#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideProperties/CS/Properties.cs#4)]  

- <span data-ttu-id="a3b77-176">Для доступа к скрытому свойству в базовом классе используется приведение `(Employee)`:</span><span class="sxs-lookup"><span data-stu-id="a3b77-176">The cast `(Employee)` is used to access the hidden property in the base class:</span></span>

     [!code-csharp[csProgGuideProperties#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideProperties/CS/Properties.cs#5)]

     <span data-ttu-id="a3b77-177">Дополнительные сведения о скрытии элементов см. в разделе [Модификатор new](../../language-reference/keywords/new-modifier.md).</span><span class="sxs-lookup"><span data-stu-id="a3b77-177">For more information about hiding members, see the [new Modifier](../../language-reference/keywords/new-modifier.md).</span></span>

## <a name="override-property-example"></a><span data-ttu-id="a3b77-178">Пример переопределения свойства</span><span class="sxs-lookup"><span data-stu-id="a3b77-178">Override property example</span></span>

<span data-ttu-id="a3b77-179">В этом примере два класса (`Cube` и `Square`) реализуют абстрактный класс `Shape` и переопределяют его абстрактное свойство `Area`.</span><span class="sxs-lookup"><span data-stu-id="a3b77-179">In this example, two classes, `Cube` and `Square`, implement an abstract class, `Shape`, and override its abstract `Area` property.</span></span> <span data-ttu-id="a3b77-180">Обратите внимание на использование модификатора [override](../../language-reference/keywords/override.md) в свойствах.</span><span class="sxs-lookup"><span data-stu-id="a3b77-180">Note the use of the [override](../../language-reference/keywords/override.md) modifier on the properties.</span></span> <span data-ttu-id="a3b77-181">Программа принимает введенную длину стороны, на основании которой рассчитывает площади квадрата и куба.</span><span class="sxs-lookup"><span data-stu-id="a3b77-181">The program accepts the side as an input and calculates the areas for the square and cube.</span></span> <span data-ttu-id="a3b77-182">Также принимается введенное значение площади, на основании которой рассчитываются длины сторон квадрата и куба.</span><span class="sxs-lookup"><span data-stu-id="a3b77-182">It also accepts the area as an input and calculates the corresponding side for the square and cube.</span></span>

[!code-csharp[csProgGuideProperties#6](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideProperties/CS/Properties.cs#6)]

## <a name="see-also"></a><span data-ttu-id="a3b77-183">См. также</span><span class="sxs-lookup"><span data-stu-id="a3b77-183">See also</span></span>

- [<span data-ttu-id="a3b77-184">Руководство по программированию на C#</span><span class="sxs-lookup"><span data-stu-id="a3b77-184">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="a3b77-185">Свойства</span><span class="sxs-lookup"><span data-stu-id="a3b77-185">Properties</span></span>](properties.md)
- [<span data-ttu-id="a3b77-186">Свойства интерфейса</span><span class="sxs-lookup"><span data-stu-id="a3b77-186">Interface Properties</span></span>](interface-properties.md)
- [<span data-ttu-id="a3b77-187">Автоматически реализуемые свойства</span><span class="sxs-lookup"><span data-stu-id="a3b77-187">Auto-Implemented Properties</span></span>](auto-implemented-properties.md)
