---
title: Классы, структуры и записи — руководство по программированию на C#
description: Описание использования классов, структур и записей в C#.
ms.date: 04/06/2021
helpviewer_keywords:
- structs [C#], about structs
- records [C#], about records
- classes [C#], overview
- C# language, structs
- C# language, records
- C# language, objects
- objects [C#]
- C# language, classes
ms.openlocfilehash: 69b62160699ef43343a89fe8bb3deaa2fb3523ba
ms.sourcegitcommit: 4b7f6b348c986556ef805cb6baacfd5b9ec18ed0
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/08/2021
ms.locfileid: "107075463"
---
# <a name="classes-structs-and-records-c-programming-guide"></a><span data-ttu-id="2f59e-103">Классы, структуры и записи (руководство по программированию на C#)</span><span class="sxs-lookup"><span data-stu-id="2f59e-103">Classes, structs, and records (C# programming guide)</span></span>

<span data-ttu-id="2f59e-104">Классы и структуры являются двумя основными конструкциями системы общих типов CTS, используемой на платформе .NET.</span><span class="sxs-lookup"><span data-stu-id="2f59e-104">Classes and structs are two of the basic constructs of the common type system in .NET.</span></span> <span data-ttu-id="2f59e-105">В C# 9 добавлены записи, которые представляют собой тип класса.</span><span class="sxs-lookup"><span data-stu-id="2f59e-105">C# 9 adds records, which are a kind of class.</span></span> <span data-ttu-id="2f59e-106">Оба они являются структурами данных, которые инкапсулируют набор данных и поведений в одной логической сущности.</span><span class="sxs-lookup"><span data-stu-id="2f59e-106">Each is essentially a data structure that encapsulates a set of data and behaviors that belong together as a logical unit.</span></span> <span data-ttu-id="2f59e-107">Данные и поведение являются *элементами* класса, структуры или записи. К ним относятся методы, свойства, события и другие элементы, которые описаны далее в этой статье.</span><span class="sxs-lookup"><span data-stu-id="2f59e-107">The data and behaviors are the *members* of the class, struct, or record, and they include its methods, properties, events, and so on, as listed later in this article.</span></span>

<span data-ttu-id="2f59e-108">Объявление класса, структуры или записи представляет собой своего рода чертеж, на основе которого создаются экземпляры или объекты во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="2f59e-108">A class, struct, or record declaration is like a blueprint that is used to create instances or objects at run time.</span></span> <span data-ttu-id="2f59e-109">Если вы определите класс, структуру или запись с именем `Person`, то `Person` здесь обозначает имя типа.</span><span class="sxs-lookup"><span data-stu-id="2f59e-109">If you define a class, struct, or record named `Person`, `Person` is the name of the type.</span></span> <span data-ttu-id="2f59e-110">Если вы объявите и инициализируете переменную `p` типа `Person`, принято говорить, что `p` является объектом (или экземпляром) `Person`.</span><span class="sxs-lookup"><span data-stu-id="2f59e-110">If you declare and initialize a variable `p` of type `Person`, `p` is said to be an object or instance of `Person`.</span></span> <span data-ttu-id="2f59e-111">Можно создать несколько экземпляров одного типа `Person`, и каждый экземпляр будет иметь разные значения свойств и полей.</span><span class="sxs-lookup"><span data-stu-id="2f59e-111">Multiple instances of the same `Person` type can be created, and each instance can have different values in its properties and fields.</span></span>  
  
<span data-ttu-id="2f59e-112">Класс или запись является ссылочным типом.</span><span class="sxs-lookup"><span data-stu-id="2f59e-112">A class or a record is a reference type.</span></span> <span data-ttu-id="2f59e-113">Когда вы создаете объект типа и назначаете его переменной, эта переменная содержит только ссылку на память объекта.</span><span class="sxs-lookup"><span data-stu-id="2f59e-113">When an object of the type is created, the variable to which the object is assigned holds only a reference to that memory.</span></span> <span data-ttu-id="2f59e-114">Если ссылка на объект сохраняется в новую переменную, эта переменная также ссылается на исходный объект.</span><span class="sxs-lookup"><span data-stu-id="2f59e-114">When the object reference is assigned to a new variable, the new variable refers to the original object.</span></span> <span data-ttu-id="2f59e-115">Изменения, внесенные через одну переменную, отражаются и в другой переменной, поскольку обе они ссылаются на одни и те же данные.</span><span class="sxs-lookup"><span data-stu-id="2f59e-115">Changes made through one variable are reflected in the other variable because they both refer to the same data.</span></span>
  
<span data-ttu-id="2f59e-116">Структура (struct) является типом значения.</span><span class="sxs-lookup"><span data-stu-id="2f59e-116">A struct is a value type.</span></span> <span data-ttu-id="2f59e-117">При создании структуры переменная, которой присвоена структура, содержит фактические данные этой структуры.</span><span class="sxs-lookup"><span data-stu-id="2f59e-117">When a struct is created, the variable to which the struct is assigned holds the struct's actual data.</span></span> <span data-ttu-id="2f59e-118">Если структура присваивается новой переменной, все данные копируются.</span><span class="sxs-lookup"><span data-stu-id="2f59e-118">When the struct is assigned to a new variable, it is copied.</span></span> <span data-ttu-id="2f59e-119">Таким образом, новая переменная и исходная переменная содержат две отдельные копии одинаковых данных.</span><span class="sxs-lookup"><span data-stu-id="2f59e-119">The new variable and the original variable therefore contain two separate copies of the same data.</span></span> <span data-ttu-id="2f59e-120">Изменения, внесенные в одну копию, не влияют на другую.</span><span class="sxs-lookup"><span data-stu-id="2f59e-120">Changes made to one copy do not affect the other copy.</span></span>  
  
<span data-ttu-id="2f59e-121">В общем случае классы используются для моделирования более сложного поведения или для таких данных, которые будут изменяться после создания объекта класса.</span><span class="sxs-lookup"><span data-stu-id="2f59e-121">In general, classes are used to model more complex behavior, or data that is intended to be modified after a class object is created.</span></span> <span data-ttu-id="2f59e-122">Структуры лучше подходят для небольших структур данных, информация в которых не должна изменяться после создания структуры.</span><span class="sxs-lookup"><span data-stu-id="2f59e-122">Structs are best suited for small data structures that contain primarily data that isn't intended to be modified after the struct is created.</span></span> <span data-ttu-id="2f59e-123">Типы записей предназначены для более крупных структур данных, информация в которых не должна изменяться после создания объекта.</span><span class="sxs-lookup"><span data-stu-id="2f59e-123">Record types are for larger data structures that contain primarily data that isn't intended to be modified after the object is created.</span></span>
  
## <a name="example"></a><span data-ttu-id="2f59e-124">Пример</span><span class="sxs-lookup"><span data-stu-id="2f59e-124">Example</span></span>

 <span data-ttu-id="2f59e-125">В следующем примере в пространстве имен `ProgrammingGuide` определен класс `CustomClass` с тремя членами: конструктор экземпляра, свойство с именем `Number` и метод с именем `Multiply`.</span><span class="sxs-lookup"><span data-stu-id="2f59e-125">In the following example, `CustomClass` in the `ProgrammingGuide` namespace has three members: an instance constructor, a property named `Number`, and a method named `Multiply`.</span></span> <span data-ttu-id="2f59e-126">Метод `Main` в классе `Program` создает экземпляр (объект) класса `CustomClass`. Обращение к методам и свойствам объекта осуществляется с использованием точечной нотации.</span><span class="sxs-lookup"><span data-stu-id="2f59e-126">The `Main` method in the `Program` class creates an instance (object) of `CustomClass`, and the object's method and property are accessed by using dot notation.</span></span>
  
 :::code language="csharp" source="../../../../samples/snippets/csharp/programming-guide/classes-and-structs/class1.cs" id="Snippet1":::  
  
## <a name="encapsulation"></a><span data-ttu-id="2f59e-127">Инкапсуляция</span><span class="sxs-lookup"><span data-stu-id="2f59e-127">Encapsulation</span></span>  

 <span data-ttu-id="2f59e-128">Концепцию *инкапсуляции* признают одним из основополагающих принципов объектно-ориентированного программирования.</span><span class="sxs-lookup"><span data-stu-id="2f59e-128">*Encapsulation* is sometimes referred to as the first pillar or principle of object-oriented programming.</span></span> <span data-ttu-id="2f59e-129">Принцип инкапсуляции заключается в том, что в классе или структуре можно указать уровень доступности для обращения к каждому из его членов из кода, расположенного вне этого класса или структуры.</span><span class="sxs-lookup"><span data-stu-id="2f59e-129">According to the principle of encapsulation, a class or struct can specify how accessible each of its members is to code outside of the class or struct.</span></span> <span data-ttu-id="2f59e-130">Вы можете скрыть методы и переменные, которые не предназначены для использования вне класса или сборки. Это позволяет снизить риск ошибок в коде и вредоносных действий.</span><span class="sxs-lookup"><span data-stu-id="2f59e-130">Methods and variables that are not intended to be used from outside of the class or assembly can be hidden to limit the potential for coding errors or malicious exploits.</span></span> <span data-ttu-id="2f59e-131">Дополнительные сведения см. в разделе [Объектно-ориентированное программирование](../../tutorials/intro-to-csharp/object-oriented-programming.md).</span><span class="sxs-lookup"><span data-stu-id="2f59e-131">For more information, see [Object-oriented programming](../../tutorials/intro-to-csharp/object-oriented-programming.md).</span></span>

## <a name="members"></a><span data-ttu-id="2f59e-132">Участники</span><span class="sxs-lookup"><span data-stu-id="2f59e-132">Members</span></span>

<span data-ttu-id="2f59e-133">Все методы, поля, константы, свойства и события должны объявляться внутри типа. Совокупно они называются *членами* типа.</span><span class="sxs-lookup"><span data-stu-id="2f59e-133">All methods, fields, constants, properties, and events must be declared within a type; these are called the *members* of the type.</span></span> <span data-ttu-id="2f59e-134">В C# не существует глобальных переменных или методов, как в некоторых других языках.</span><span class="sxs-lookup"><span data-stu-id="2f59e-134">In C#, there are no global variables or methods as there are in some other languages.</span></span> <span data-ttu-id="2f59e-135">Даже точка входа программы, то есть метод `Main`, должна быть объявлена внутри класса или структуры (для [инструкций верхнего уровня](../main-and-command-args/top-level-statements.md) — неявным образом).</span><span class="sxs-lookup"><span data-stu-id="2f59e-135">Even a program's entry point, the `Main` method, must be declared within a class or struct (implicitly in the case of [top-level statements](../main-and-command-args/top-level-statements.md)).</span></span>

<span data-ttu-id="2f59e-136">Ниже приведен полный список возможных элементов, которые можно объявить в классе, структуре или записи.</span><span class="sxs-lookup"><span data-stu-id="2f59e-136">The following list includes all the various kinds of members that may be declared in a class, struct, or record.</span></span>
  
- [<span data-ttu-id="2f59e-137">Поля</span><span class="sxs-lookup"><span data-stu-id="2f59e-137">Fields</span></span>](./fields.md)  
- [<span data-ttu-id="2f59e-138">Константы</span><span class="sxs-lookup"><span data-stu-id="2f59e-138">Constants</span></span>](./constants.md)
- [<span data-ttu-id="2f59e-139">Свойства</span><span class="sxs-lookup"><span data-stu-id="2f59e-139">Properties</span></span>](./properties.md)
- [<span data-ttu-id="2f59e-140">Методы</span><span class="sxs-lookup"><span data-stu-id="2f59e-140">Methods</span></span>](./methods.md)
- [<span data-ttu-id="2f59e-141">Конструкторы</span><span class="sxs-lookup"><span data-stu-id="2f59e-141">Constructors</span></span>](./constructors.md)
- [<span data-ttu-id="2f59e-142">События</span><span class="sxs-lookup"><span data-stu-id="2f59e-142">Events</span></span>](../events/index.md)
- [<span data-ttu-id="2f59e-143">Методы завершения</span><span class="sxs-lookup"><span data-stu-id="2f59e-143">Finalizers</span></span>](./destructors.md)
- [<span data-ttu-id="2f59e-144">Индексаторы</span><span class="sxs-lookup"><span data-stu-id="2f59e-144">Indexers</span></span>](../indexers/index.md)
- [<span data-ttu-id="2f59e-145">Инструкции</span><span class="sxs-lookup"><span data-stu-id="2f59e-145">Operators</span></span>](../../language-reference/operators/index.md)
- [<span data-ttu-id="2f59e-146">Вложенные типы</span><span class="sxs-lookup"><span data-stu-id="2f59e-146">Nested Types</span></span>](./nested-types.md)
  
## <a name="accessibility"></a><span data-ttu-id="2f59e-147">Специальные возможности</span><span class="sxs-lookup"><span data-stu-id="2f59e-147">Accessibility</span></span>  

 <span data-ttu-id="2f59e-148">Некоторые методы и свойства специально предназначены для того, чтобы их вызов или доступ к ним осуществлялся из *клиентского кода*, то есть из кода за пределами этого класса или структуры.</span><span class="sxs-lookup"><span data-stu-id="2f59e-148">Some methods and properties are meant to be called or accessed from code outside a class or struct, known as *client code*.</span></span> <span data-ttu-id="2f59e-149">Другие методы и свойства могут использоваться только в самом классе или структуре.</span><span class="sxs-lookup"><span data-stu-id="2f59e-149">Other methods and properties might be only for use in the class or struct itself.</span></span> <span data-ttu-id="2f59e-150">Важно ограничить доступность кода так, чтобы только нужные элементы клиентского кода получали к нему доступ.</span><span class="sxs-lookup"><span data-stu-id="2f59e-150">It is important to limit the accessibility of your code so that only the intended client code can reach it.</span></span> <span data-ttu-id="2f59e-151">Уровень доступности для типов и их элементов вы можете задать с помощью следующих модификаторов доступа.</span><span class="sxs-lookup"><span data-stu-id="2f59e-151">You specify how accessible your types and their members are to client code by using the following access modifiers:</span></span>

- [<span data-ttu-id="2f59e-152">public</span><span class="sxs-lookup"><span data-stu-id="2f59e-152">public</span></span>](../../language-reference/keywords/public.md)
- [<span data-ttu-id="2f59e-153">protected</span><span class="sxs-lookup"><span data-stu-id="2f59e-153">protected</span></span>](../../language-reference/keywords/protected.md)
- [<span data-ttu-id="2f59e-154">internal</span><span class="sxs-lookup"><span data-stu-id="2f59e-154">internal</span></span>](../../language-reference/keywords/internal.md)
- [<span data-ttu-id="2f59e-155">protected internal</span><span class="sxs-lookup"><span data-stu-id="2f59e-155">protected internal</span></span>](../../language-reference/keywords/protected-internal.md)
- [<span data-ttu-id="2f59e-156">private</span><span class="sxs-lookup"><span data-stu-id="2f59e-156">private</span></span>](../../language-reference/keywords/private.md)
- <span data-ttu-id="2f59e-157">[private protected](../../language-reference/keywords/private-protected.md).</span><span class="sxs-lookup"><span data-stu-id="2f59e-157">[private protected](../../language-reference/keywords/private-protected.md).</span></span>

<span data-ttu-id="2f59e-158">По умолчанию используется режим доступа `private`.</span><span class="sxs-lookup"><span data-stu-id="2f59e-158">The default accessibility is `private`.</span></span> <span data-ttu-id="2f59e-159">Дополнительные сведения см. в статье [Модификаторы доступа](./access-modifiers.md).</span><span class="sxs-lookup"><span data-stu-id="2f59e-159">For more information, see [Access Modifiers](./access-modifiers.md).</span></span>  
  
## <a name="inheritance"></a><span data-ttu-id="2f59e-160">Наследование</span><span class="sxs-lookup"><span data-stu-id="2f59e-160">Inheritance</span></span>  

<span data-ttu-id="2f59e-161">Классы (но не структуры) поддерживают наследование.</span><span class="sxs-lookup"><span data-stu-id="2f59e-161">Classes (but not structs) support the concept of inheritance.</span></span> <span data-ttu-id="2f59e-162">Класс, производный от другого класса (*базового класса*), автоматически включает все открытые, защищенные и внутренние члены базового класса за исключением конструкторов и методов завершения.</span><span class="sxs-lookup"><span data-stu-id="2f59e-162">A class that derives from another class (the *base class*) automatically contains all the public, protected, and internal members of the base class except its constructors and finalizers.</span></span> <span data-ttu-id="2f59e-163">Дополнительные сведения см. в статьях о [наследовании](./inheritance.md) и [полиморфизме](./polymorphism.md).</span><span class="sxs-lookup"><span data-stu-id="2f59e-163">For more information, see [Inheritance](./inheritance.md) and [Polymorphism](./polymorphism.md).</span></span>
  
<span data-ttu-id="2f59e-164">Классы могут быть объявлены как [абстрактные](../../language-reference/keywords/abstract.md). Это означает, что один или несколько их членов не имеют реализации.</span><span class="sxs-lookup"><span data-stu-id="2f59e-164">Classes may be declared as [abstract](../../language-reference/keywords/abstract.md), which means that one or more of their methods have no implementation.</span></span> <span data-ttu-id="2f59e-165">Из абстрактных классов нельзя напрямую создать экземпляры. Они выполняют роль базовых классов для других классов, которые предоставляют реализацию недостающих членов.</span><span class="sxs-lookup"><span data-stu-id="2f59e-165">Although abstract classes cannot be instantiated directly, they can serve as base classes for other classes that provide the missing implementation.</span></span> <span data-ttu-id="2f59e-166">Также классы можно объявить [запечатанными](../../language-reference/keywords/sealed.md), чтобы запретить наследование от них других классов.</span><span class="sxs-lookup"><span data-stu-id="2f59e-166">Classes can also be declared as [sealed](../../language-reference/keywords/sealed.md) to prevent other classes from inheriting from them.</span></span> <span data-ttu-id="2f59e-167">Дополнительные сведения см. в разделе [Абстрактные и запечатанные классы и члены классов](./abstract-and-sealed-classes-and-class-members.md).</span><span class="sxs-lookup"><span data-stu-id="2f59e-167">For more information, see [Abstract and sealed classes and class members](./abstract-and-sealed-classes-and-class-members.md).</span></span>
  
## <a name="interfaces"></a><span data-ttu-id="2f59e-168">Интерфейсы</span><span class="sxs-lookup"><span data-stu-id="2f59e-168">Interfaces</span></span>  

<span data-ttu-id="2f59e-169">Классы, структуры и записи могут наследовать несколько интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="2f59e-169">Classes, structs, and records can inherit multiple interfaces.</span></span> <span data-ttu-id="2f59e-170">Наследование интерфейса означает, что тип реализует все методы, определенные в этом интерфейсе.</span><span class="sxs-lookup"><span data-stu-id="2f59e-170">To inherit from an interface means that the type implements all the methods defined in the interface.</span></span> <span data-ttu-id="2f59e-171">Дополнительные сведения см. в статье [Интерфейсы](../interfaces/index.md).</span><span class="sxs-lookup"><span data-stu-id="2f59e-171">For more information, see [Interfaces](../interfaces/index.md).</span></span>  
  
## <a name="generic-types"></a><span data-ttu-id="2f59e-172">Универсальные типы</span><span class="sxs-lookup"><span data-stu-id="2f59e-172">Generic Types</span></span>  

 <span data-ttu-id="2f59e-173">Для класса, структуры или записи можно определить один параметр типа или несколько.</span><span class="sxs-lookup"><span data-stu-id="2f59e-173">Classes, structs, and records can be defined with one or more type parameters.</span></span> <span data-ttu-id="2f59e-174">Клиентский код назначает тип при создании экземпляра типа.</span><span class="sxs-lookup"><span data-stu-id="2f59e-174">Client code supplies the type when it creates an instance of the type.</span></span> <span data-ttu-id="2f59e-175">Например, класс <xref:System.Collections.Generic.List%601> в пространстве имен <xref:System.Collections.Generic> определен с помощью одного параметра типа.</span><span class="sxs-lookup"><span data-stu-id="2f59e-175">For example The <xref:System.Collections.Generic.List%601> class in the <xref:System.Collections.Generic> namespace is defined with one type parameter.</span></span> <span data-ttu-id="2f59e-176">Клиентский код создает экземпляр `List<string>` или `List<int>`, информируя о том, сущности какого типа будут храниться в этом списке.</span><span class="sxs-lookup"><span data-stu-id="2f59e-176">Client code creates an instance of a `List<string>` or `List<int>` to specify the type that the list will hold.</span></span> <span data-ttu-id="2f59e-177">Дополнительные сведения см. в статье [Универсальные шаблоны](../generics/index.md).</span><span class="sxs-lookup"><span data-stu-id="2f59e-177">For more information, see [Generics](../generics/index.md).</span></span>  
  
## <a name="static-types"></a><span data-ttu-id="2f59e-178">Статические типы</span><span class="sxs-lookup"><span data-stu-id="2f59e-178">Static Types</span></span>  

<span data-ttu-id="2f59e-179">Классы (но не структуры или записи) могут быть объявлены как [статические](../../language-reference/keywords/static.md).</span><span class="sxs-lookup"><span data-stu-id="2f59e-179">Classes (but not structs or records) can be declared as [static](../../language-reference/keywords/static.md).</span></span> <span data-ttu-id="2f59e-180">Статический класс может содержать только статические элементы. Для него нельзя создать экземпляр с помощью ключевого слова `new`.</span><span class="sxs-lookup"><span data-stu-id="2f59e-180">A static class can contain only static members and can't be instantiated with the `new` keyword.</span></span> <span data-ttu-id="2f59e-181">При запуске программы в память загружается одна копия такого класса. Доступ к его членам осуществляется через имя класса.</span><span class="sxs-lookup"><span data-stu-id="2f59e-181">One copy of the class is loaded into memory when the program loads, and its members are accessed through the class name.</span></span> <span data-ttu-id="2f59e-182">Классы, структуры и записи могут содержать статические элементы.</span><span class="sxs-lookup"><span data-stu-id="2f59e-182">Classes, structs, and records can contain static members.</span></span> <span data-ttu-id="2f59e-183">Дополнительные сведения см. в разделе [Статические классы и члены статических классов](./static-classes-and-static-class-members.md).</span><span class="sxs-lookup"><span data-stu-id="2f59e-183">For more information, see [Static classes and static class members](./static-classes-and-static-class-members.md).</span></span>
  
## <a name="nested-types"></a><span data-ttu-id="2f59e-184">Вложенные типы</span><span class="sxs-lookup"><span data-stu-id="2f59e-184">Nested Types</span></span>

<span data-ttu-id="2f59e-185">Класс, структура или запись могут быть вложены в другой класс, структуру или запись.</span><span class="sxs-lookup"><span data-stu-id="2f59e-185">A class, struct, or record can be nested within another class, struct, or record.</span></span> <span data-ttu-id="2f59e-186">Дополнительные сведения см. в разделе [Вложенные типы](./nested-types.md).</span><span class="sxs-lookup"><span data-stu-id="2f59e-186">For more information, see [Nested Types](./nested-types.md).</span></span>
  
## <a name="partial-types"></a><span data-ttu-id="2f59e-187">Разделяемые типы</span><span class="sxs-lookup"><span data-stu-id="2f59e-187">Partial Types</span></span>  

<span data-ttu-id="2f59e-188">Вы можете разделить определение класса, структуры или метода на несколько файлов с кодом.</span><span class="sxs-lookup"><span data-stu-id="2f59e-188">You can define part of a class, struct or method in one code file and another part in a separate code file.</span></span> <span data-ttu-id="2f59e-189">Дополнительные сведения см. в разделе [Разделяемые классы и методы](./partial-classes-and-methods.md).</span><span class="sxs-lookup"><span data-stu-id="2f59e-189">For more information, see [Partial Classes and methods](./partial-classes-and-methods.md).</span></span>
  
## <a name="object-initializers"></a><span data-ttu-id="2f59e-190">Инициализаторы объектов</span><span class="sxs-lookup"><span data-stu-id="2f59e-190">Object Initializers</span></span>  

<span data-ttu-id="2f59e-191">Вы можете создавать и инициализировать экземпляры класса или структуры, а также коллекции объектов, без явного вызова соответствующих конструкторов.</span><span class="sxs-lookup"><span data-stu-id="2f59e-191">You can instantiate and initialize class or struct objects, and collections of objects, without explicitly calling their constructor.</span></span> <span data-ttu-id="2f59e-192">Дополнительные сведения см. в разделе [Инициализаторы объектов и коллекций](./object-and-collection-initializers.md).</span><span class="sxs-lookup"><span data-stu-id="2f59e-192">For more information, see [Object and collection initializers](./object-and-collection-initializers.md).</span></span>  
  
## <a name="anonymous-types"></a><span data-ttu-id="2f59e-193">Анонимные типы</span><span class="sxs-lookup"><span data-stu-id="2f59e-193">Anonymous Types</span></span>  

<span data-ttu-id="2f59e-194">В некоторых ситуациях нет смысла или пользы создавать именованный класс, например при заполнении списка структурами данных, которые не будут сохраняться или передаваться другому методу. В таких случаях можно использовать анонимные типы.</span><span class="sxs-lookup"><span data-stu-id="2f59e-194">In situations where it is not convenient or necessary to create a named class, for example when you are populating a list with data structures that you do not have to persist or pass to another method, you use anonymous types.</span></span> <span data-ttu-id="2f59e-195">Дополнительные сведения см. в разделе [Анонимные типы](./anonymous-types.md).</span><span class="sxs-lookup"><span data-stu-id="2f59e-195">For more information, see [Anonymous types](./anonymous-types.md).</span></span>
  
## <a name="extension-methods"></a><span data-ttu-id="2f59e-196">Методы расширения</span><span class="sxs-lookup"><span data-stu-id="2f59e-196">Extension Methods</span></span>  

<span data-ttu-id="2f59e-197">Вы можете "расширить" класс, даже не создавая производного класса. Для этого можно создать отдельный тип и вызывать его методы так, как если бы они принадлежали исходному типу.</span><span class="sxs-lookup"><span data-stu-id="2f59e-197">You can "extend" a class without creating a derived class by creating a separate type whose methods can be called as if they belonged to the original type.</span></span> <span data-ttu-id="2f59e-198">Дополнительные сведения см. в разделе [Методы расширения](./extension-methods.md).</span><span class="sxs-lookup"><span data-stu-id="2f59e-198">For more information, see [Extension methods](./extension-methods.md).</span></span>
  
## <a name="implicitly-typed-local-variables"></a><span data-ttu-id="2f59e-199">Неявно типизированные локальные переменные</span><span class="sxs-lookup"><span data-stu-id="2f59e-199">Implicitly Typed Local Variables</span></span>  

<span data-ttu-id="2f59e-200">Внутри метода класса или структуры можно использовать неявное типизирование, чтобы компилятор самостоятельно определял тип переменной во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="2f59e-200">Within a class or struct method, you can use implicit typing to instruct the compiler to determine a variable's type at compile time.</span></span> <span data-ttu-id="2f59e-201">Дополнительные сведения см. в статье [Неявно типизированные локальные переменные (руководство по программированию на C#)](./implicitly-typed-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="2f59e-201">For more information, see [Implicitly Typed Local Variables](./implicitly-typed-local-variables.md).</span></span>

## <a name="records"></a><span data-ttu-id="2f59e-202">Записи</span><span class="sxs-lookup"><span data-stu-id="2f59e-202">Records</span></span>

<span data-ttu-id="2f59e-203">В C# 9 появился тип `record`, ссылочный тип, который можно создать вместо класса или структуры.</span><span class="sxs-lookup"><span data-stu-id="2f59e-203">C# 9 introduces the `record` type, a reference type that you can create instead of a class or a struct.</span></span> <span data-ttu-id="2f59e-204">Записи — это классы со встроенным поведением для инкапсуляции данных в неизменяемых типах.</span><span class="sxs-lookup"><span data-stu-id="2f59e-204">Records are classes with built-in behavior for encapsulating data in immutable types.</span></span> <span data-ttu-id="2f59e-205">Запись предоставляет следующие возможности:</span><span class="sxs-lookup"><span data-stu-id="2f59e-205">A record provides the following features:</span></span>

* <span data-ttu-id="2f59e-206">краткий синтаксис для создания ссылочного типа с неизменяемыми свойствами;</span><span class="sxs-lookup"><span data-stu-id="2f59e-206">Concise syntax for creating a reference type with immutable properties.</span></span>

* <span data-ttu-id="2f59e-207">равенство значений.</span><span class="sxs-lookup"><span data-stu-id="2f59e-207">Value equality.</span></span>

  <span data-ttu-id="2f59e-208">Две переменные типа записи равны, если определения типов записей идентичны и если для каждого поля значения в обеих записях равны.</span><span class="sxs-lookup"><span data-stu-id="2f59e-208">Two variables of a record type are equal if the record type definitions are identical, and if for every field, the values in both records are equal.</span></span> <span data-ttu-id="2f59e-209">Это отличается от классов, которые используют равенство ссылок: две переменные типа класса равны, если они ссылаются на один и тот же объект.</span><span class="sxs-lookup"><span data-stu-id="2f59e-209">This differs from classes, which use reference equality: two variables of a class type are equal if they refer to the same object.</span></span>

* <span data-ttu-id="2f59e-210">Краткий синтаксис для обратимого изменения.</span><span class="sxs-lookup"><span data-stu-id="2f59e-210">Concise syntax for nondestructive mutation.</span></span>

  <span data-ttu-id="2f59e-211">Выражение `with` позволяет создать новый экземпляр записи, который является копией существующего экземпляра, но в котором изменены значения указанных свойств.</span><span class="sxs-lookup"><span data-stu-id="2f59e-211">A `with` expression lets you create a new record instance that is a copy of an existing instance but with specified property values changed.</span></span>

* <span data-ttu-id="2f59e-212">Встроенное форматирование для отображения.</span><span class="sxs-lookup"><span data-stu-id="2f59e-212">Built-in formatting for display.</span></span>

  <span data-ttu-id="2f59e-213">Метод `ToString` выводит имя типа записи и имена и значения общих свойств.</span><span class="sxs-lookup"><span data-stu-id="2f59e-213">The `ToString` method prints out the record type name and the names and values of public properties.</span></span>

* <span data-ttu-id="2f59e-214">Поддержка иерархий наследования.</span><span class="sxs-lookup"><span data-stu-id="2f59e-214">Support for inheritance hierarchies.</span></span>

  <span data-ttu-id="2f59e-215">Наследование поддерживается, так как запись по сути является классом, а не структурой.</span><span class="sxs-lookup"><span data-stu-id="2f59e-215">Inheritance is supported because a record is a class under the covers, not a struct.</span></span>

<span data-ttu-id="2f59e-216">Дополнительные сведения см. в статье [Записи](../../language-reference/builtin-types/record.md).</span><span class="sxs-lookup"><span data-stu-id="2f59e-216">For more information, see [Records](../../language-reference/builtin-types/record.md).</span></span>

## <a name="c-language-specification"></a><span data-ttu-id="2f59e-217">Спецификация языка C#</span><span class="sxs-lookup"><span data-stu-id="2f59e-217">C# Language Specification</span></span>  

 [!INCLUDE[CSharplangspec](~/includes/csharplangspec-md.md)]  
  
## <a name="see-also"></a><span data-ttu-id="2f59e-218">См. также</span><span class="sxs-lookup"><span data-stu-id="2f59e-218">See also</span></span>

- [<span data-ttu-id="2f59e-219">Классы</span><span class="sxs-lookup"><span data-stu-id="2f59e-219">Classes</span></span>](./classes.md)
- [<span data-ttu-id="2f59e-220">Объекты</span><span class="sxs-lookup"><span data-stu-id="2f59e-220">Objects</span></span>](./objects.md)
- [<span data-ttu-id="2f59e-221">Типы структур</span><span class="sxs-lookup"><span data-stu-id="2f59e-221">Structure types</span></span>](../../language-reference/builtin-types/struct.md)
- [<span data-ttu-id="2f59e-222">Записи</span><span class="sxs-lookup"><span data-stu-id="2f59e-222">Records</span></span>](../../language-reference/builtin-types/record.md)  
- [<span data-ttu-id="2f59e-223">Руководство по программированию на C#</span><span class="sxs-lookup"><span data-stu-id="2f59e-223">C# Programming Guide</span></span>](../index.md)
