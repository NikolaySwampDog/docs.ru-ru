---
title: Классы, структуры и записи — руководство по программированию на C#
description: Описание использования классов, структур и записей в C#.
ms.date: 04/06/2021
helpviewer_keywords:
- structs [C#], about structs
- records [C#], about records
- classes [C#], overview
- C# language, structs
- C# language, records
- C# language, objects
- objects [C#]
- C# language, classes
ms.openlocfilehash: 69b62160699ef43343a89fe8bb3deaa2fb3523ba
ms.sourcegitcommit: 4b7f6b348c986556ef805cb6baacfd5b9ec18ed0
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/08/2021
ms.locfileid: "107075463"
---
# <a name="classes-structs-and-records-c-programming-guide"></a>Классы, структуры и записи (руководство по программированию на C#)

Классы и структуры являются двумя основными конструкциями системы общих типов CTS, используемой на платформе .NET. В C# 9 добавлены записи, которые представляют собой тип класса. Оба они являются структурами данных, которые инкапсулируют набор данных и поведений в одной логической сущности. Данные и поведение являются *элементами* класса, структуры или записи. К ним относятся методы, свойства, события и другие элементы, которые описаны далее в этой статье.

Объявление класса, структуры или записи представляет собой своего рода чертеж, на основе которого создаются экземпляры или объекты во время выполнения. Если вы определите класс, структуру или запись с именем `Person`, то `Person` здесь обозначает имя типа. Если вы объявите и инициализируете переменную `p` типа `Person`, принято говорить, что `p` является объектом (или экземпляром) `Person`. Можно создать несколько экземпляров одного типа `Person`, и каждый экземпляр будет иметь разные значения свойств и полей.  
  
Класс или запись является ссылочным типом. Когда вы создаете объект типа и назначаете его переменной, эта переменная содержит только ссылку на память объекта. Если ссылка на объект сохраняется в новую переменную, эта переменная также ссылается на исходный объект. Изменения, внесенные через одну переменную, отражаются и в другой переменной, поскольку обе они ссылаются на одни и те же данные.
  
Структура (struct) является типом значения. При создании структуры переменная, которой присвоена структура, содержит фактические данные этой структуры. Если структура присваивается новой переменной, все данные копируются. Таким образом, новая переменная и исходная переменная содержат две отдельные копии одинаковых данных. Изменения, внесенные в одну копию, не влияют на другую.  
  
В общем случае классы используются для моделирования более сложного поведения или для таких данных, которые будут изменяться после создания объекта класса. Структуры лучше подходят для небольших структур данных, информация в которых не должна изменяться после создания структуры. Типы записей предназначены для более крупных структур данных, информация в которых не должна изменяться после создания объекта.
  
## <a name="example"></a>Пример

 В следующем примере в пространстве имен `ProgrammingGuide` определен класс `CustomClass` с тремя членами: конструктор экземпляра, свойство с именем `Number` и метод с именем `Multiply`. Метод `Main` в классе `Program` создает экземпляр (объект) класса `CustomClass`. Обращение к методам и свойствам объекта осуществляется с использованием точечной нотации.
  
 :::code language="csharp" source="../../../../samples/snippets/csharp/programming-guide/classes-and-structs/class1.cs" id="Snippet1":::  
  
## <a name="encapsulation"></a>Инкапсуляция  

 Концепцию *инкапсуляции* признают одним из основополагающих принципов объектно-ориентированного программирования. Принцип инкапсуляции заключается в том, что в классе или структуре можно указать уровень доступности для обращения к каждому из его членов из кода, расположенного вне этого класса или структуры. Вы можете скрыть методы и переменные, которые не предназначены для использования вне класса или сборки. Это позволяет снизить риск ошибок в коде и вредоносных действий. Дополнительные сведения см. в разделе [Объектно-ориентированное программирование](../../tutorials/intro-to-csharp/object-oriented-programming.md).

## <a name="members"></a>Участники

Все методы, поля, константы, свойства и события должны объявляться внутри типа. Совокупно они называются *членами* типа. В C# не существует глобальных переменных или методов, как в некоторых других языках. Даже точка входа программы, то есть метод `Main`, должна быть объявлена внутри класса или структуры (для [инструкций верхнего уровня](../main-and-command-args/top-level-statements.md) — неявным образом).

Ниже приведен полный список возможных элементов, которые можно объявить в классе, структуре или записи.
  
- [Поля](./fields.md)  
- [Константы](./constants.md)
- [Свойства](./properties.md)
- [Методы](./methods.md)
- [Конструкторы](./constructors.md)
- [События](../events/index.md)
- [Методы завершения](./destructors.md)
- [Индексаторы](../indexers/index.md)
- [Инструкции](../../language-reference/operators/index.md)
- [Вложенные типы](./nested-types.md)
  
## <a name="accessibility"></a>Специальные возможности  

 Некоторые методы и свойства специально предназначены для того, чтобы их вызов или доступ к ним осуществлялся из *клиентского кода*, то есть из кода за пределами этого класса или структуры. Другие методы и свойства могут использоваться только в самом классе или структуре. Важно ограничить доступность кода так, чтобы только нужные элементы клиентского кода получали к нему доступ. Уровень доступности для типов и их элементов вы можете задать с помощью следующих модификаторов доступа.

- [public](../../language-reference/keywords/public.md)
- [protected](../../language-reference/keywords/protected.md)
- [internal](../../language-reference/keywords/internal.md)
- [protected internal](../../language-reference/keywords/protected-internal.md)
- [private](../../language-reference/keywords/private.md)
- [private protected](../../language-reference/keywords/private-protected.md).

По умолчанию используется режим доступа `private`. Дополнительные сведения см. в статье [Модификаторы доступа](./access-modifiers.md).  
  
## <a name="inheritance"></a>Наследование  

Классы (но не структуры) поддерживают наследование. Класс, производный от другого класса (*базового класса*), автоматически включает все открытые, защищенные и внутренние члены базового класса за исключением конструкторов и методов завершения. Дополнительные сведения см. в статьях о [наследовании](./inheritance.md) и [полиморфизме](./polymorphism.md).
  
Классы могут быть объявлены как [абстрактные](../../language-reference/keywords/abstract.md). Это означает, что один или несколько их членов не имеют реализации. Из абстрактных классов нельзя напрямую создать экземпляры. Они выполняют роль базовых классов для других классов, которые предоставляют реализацию недостающих членов. Также классы можно объявить [запечатанными](../../language-reference/keywords/sealed.md), чтобы запретить наследование от них других классов. Дополнительные сведения см. в разделе [Абстрактные и запечатанные классы и члены классов](./abstract-and-sealed-classes-and-class-members.md).
  
## <a name="interfaces"></a>Интерфейсы  

Классы, структуры и записи могут наследовать несколько интерфейсов. Наследование интерфейса означает, что тип реализует все методы, определенные в этом интерфейсе. Дополнительные сведения см. в статье [Интерфейсы](../interfaces/index.md).  
  
## <a name="generic-types"></a>Универсальные типы  

 Для класса, структуры или записи можно определить один параметр типа или несколько. Клиентский код назначает тип при создании экземпляра типа. Например, класс <xref:System.Collections.Generic.List%601> в пространстве имен <xref:System.Collections.Generic> определен с помощью одного параметра типа. Клиентский код создает экземпляр `List<string>` или `List<int>`, информируя о том, сущности какого типа будут храниться в этом списке. Дополнительные сведения см. в статье [Универсальные шаблоны](../generics/index.md).  
  
## <a name="static-types"></a>Статические типы  

Классы (но не структуры или записи) могут быть объявлены как [статические](../../language-reference/keywords/static.md). Статический класс может содержать только статические элементы. Для него нельзя создать экземпляр с помощью ключевого слова `new`. При запуске программы в память загружается одна копия такого класса. Доступ к его членам осуществляется через имя класса. Классы, структуры и записи могут содержать статические элементы. Дополнительные сведения см. в разделе [Статические классы и члены статических классов](./static-classes-and-static-class-members.md).
  
## <a name="nested-types"></a>Вложенные типы

Класс, структура или запись могут быть вложены в другой класс, структуру или запись. Дополнительные сведения см. в разделе [Вложенные типы](./nested-types.md).
  
## <a name="partial-types"></a>Разделяемые типы  

Вы можете разделить определение класса, структуры или метода на несколько файлов с кодом. Дополнительные сведения см. в разделе [Разделяемые классы и методы](./partial-classes-and-methods.md).
  
## <a name="object-initializers"></a>Инициализаторы объектов  

Вы можете создавать и инициализировать экземпляры класса или структуры, а также коллекции объектов, без явного вызова соответствующих конструкторов. Дополнительные сведения см. в разделе [Инициализаторы объектов и коллекций](./object-and-collection-initializers.md).  
  
## <a name="anonymous-types"></a>Анонимные типы  

В некоторых ситуациях нет смысла или пользы создавать именованный класс, например при заполнении списка структурами данных, которые не будут сохраняться или передаваться другому методу. В таких случаях можно использовать анонимные типы. Дополнительные сведения см. в разделе [Анонимные типы](./anonymous-types.md).
  
## <a name="extension-methods"></a>Методы расширения  

Вы можете "расширить" класс, даже не создавая производного класса. Для этого можно создать отдельный тип и вызывать его методы так, как если бы они принадлежали исходному типу. Дополнительные сведения см. в разделе [Методы расширения](./extension-methods.md).
  
## <a name="implicitly-typed-local-variables"></a>Неявно типизированные локальные переменные  

Внутри метода класса или структуры можно использовать неявное типизирование, чтобы компилятор самостоятельно определял тип переменной во время компиляции. Дополнительные сведения см. в статье [Неявно типизированные локальные переменные (руководство по программированию на C#)](./implicitly-typed-local-variables.md).

## <a name="records"></a>Записи

В C# 9 появился тип `record`, ссылочный тип, который можно создать вместо класса или структуры. Записи — это классы со встроенным поведением для инкапсуляции данных в неизменяемых типах. Запись предоставляет следующие возможности:

* краткий синтаксис для создания ссылочного типа с неизменяемыми свойствами;

* равенство значений.

  Две переменные типа записи равны, если определения типов записей идентичны и если для каждого поля значения в обеих записях равны. Это отличается от классов, которые используют равенство ссылок: две переменные типа класса равны, если они ссылаются на один и тот же объект.

* Краткий синтаксис для обратимого изменения.

  Выражение `with` позволяет создать новый экземпляр записи, который является копией существующего экземпляра, но в котором изменены значения указанных свойств.

* Встроенное форматирование для отображения.

  Метод `ToString` выводит имя типа записи и имена и значения общих свойств.

* Поддержка иерархий наследования.

  Наследование поддерживается, так как запись по сути является классом, а не структурой.

Дополнительные сведения см. в статье [Записи](../../language-reference/builtin-types/record.md).

## <a name="c-language-specification"></a>Спецификация языка C#  

 [!INCLUDE[CSharplangspec](~/includes/csharplangspec-md.md)]  
  
## <a name="see-also"></a>См. также

- [Классы](./classes.md)
- [Объекты](./objects.md)
- [Типы структур](../../language-reference/builtin-types/struct.md)
- [Записи](../../language-reference/builtin-types/record.md)  
- [Руководство по программированию на C#](../index.md)
