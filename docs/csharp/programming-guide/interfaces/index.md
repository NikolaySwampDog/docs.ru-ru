---
title: Руководство по программированию на C#. Интерфейсы
description: Интерфейс в C# содержит определения для группы связанных функциональных возможностей, которые должны реализовать неабстрактный класс или структура.
ms.date: 02/20/2020
helpviewer_keywords:
- interfaces [C#]
- C# language, interfaces
ms.assetid: 2feda177-ce11-432d-81b4-d50f5f35fd37
ms.openlocfilehash: df96ce4cc2348637b262b7380832dde1e2ee3afb
ms.sourcegitcommit: c7f0beaa2bd66ebca86362ca17d673f7e8256ca6
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/23/2021
ms.locfileid: "104876346"
---
# <a name="interfaces-c-programming-guide"></a>Интерфейсы (Руководство по программированию в C#)

Интерфейс содержит определения для группы связанных функциональных возможностей, которые может реализовать неабстрактный [класс](../../language-reference/keywords/class.md) или [структура](../../language-reference/builtin-types/struct.md). Интерфейс может определять методы `static`, которые должны иметь реализацию. Начиная с C# 8.0, интерфейс может определять реализацию по умолчанию для членов. Интерфейс не может объявлять данные экземпляра, такие как поля, автоматические реализуемые свойства или события, подобные свойствам.

С помощью интерфейсов можно, например, включить в класс поведение из нескольких источников. Эта возможность очень важна в C#, поскольку этот язык не поддерживает множественное наследование классов. Кроме того, необходимо использовать интерфейс, если требуется имитировать наследование для структур, поскольку они не могут фактически наследовать от другой структуры или класса.

Интерфейс определяется с помощью ключевого слова [interface](../../language-reference/keywords/interface.md), как показано в следующем примере.

[!code-csharp[Equatable](~/samples/snippets/csharp/objectoriented/interfaces.cs#Equatable)]

Имя интерфейса должно быть допустимым [именем идентификатора](../inside-a-program/identifier-names.md) C#. По соглашению имена интерфейсов начинаются с заглавной буквы `I`.

Любой объект (класс или структура), реализующий интерфейс <xref:System.IEquatable%601>, должен содержать определение для метода <xref:System.IEquatable%601.Equals%2A>, соответствующее сигнатуре, которую задает интерфейс. В результате вы можете быть уверены, что класс, реализующий `IEquatable<T>`, содержит метод `Equals`, с помощью которого экземпляр этого класса может определить, равен ли он другому экземпляру того же класса.

Определение `IEquatable<T>` не предоставляет реализацию для метода `Equals`. Класс или структура может реализовывать несколько интерфейсов, но класс может наследовать только от одного класса.

Дополнительные сведения об абстрактных классах см. в разделе [Абстрактные и запечатанные классы и члены классов](../classes-and-structs/abstract-and-sealed-classes-and-class-members.md).

Интерфейсы могут содержать методы экземпляра, свойства, события, индексаторы, а также любое сочетание этих четырех типов членов. Интерфейсы могут содержать статические конструкторы, поля, константы или операторы. Ссылки на примеры см. в разделе [Связанные разделы](./index.md#BKMK_RelatedSections). Интерфейс не может содержать поля экземпляров, конструкторы экземпляров или методы завершения. Члены интерфейса по умолчанию являются общедоступными, и вы можете явно указать модификаторы доступа, такие как `public`, `protected`, `internal`, `private`, `protected internal` или `private protected`. Элемент `private` должен иметь реализацию по умолчанию.

Для реализации члена интерфейса соответствующий член реализующего класса должен быть открытым и не статическим, а также иметь такое же имя и сигнатуру, что и член интерфейса.

Если класс (или структура) реализует интерфейс, этот класс (или структура) должен предоставлять реализацию для всех членов, которые этот интерфейс объявляет, но не предоставляет им реализацию по умолчанию. Однако если базовый класс реализует интерфейс, то любой класс, производный от базового класса, наследует эту реализацию.

В следующем примере показана реализация интерфейса <xref:System.IEquatable%601>. Реализующий класс `Car` должен предоставлять реализацию метода <xref:System.IEquatable%601.Equals%2A>.

[!code-csharp[ImplementEquatable](~/samples/snippets/csharp/objectoriented/interfaces.cs#ImplementEquatable)]

Свойства и индексаторы класса могут определять дополнительные методы доступа для свойства или индексатора, определенного в интерфейсе. Например, интерфейс может объявлять свойство, имеющее акцессор [get](../../language-reference/keywords/get.md). Класс, реализующий этот интерфейс, может объявлять это же свойство с обоими акцессорами (`get` и [set](../../language-reference/keywords/set.md)). Однако если свойство или индексатор использует явную реализацию, методы доступа должны совпадать. Дополнительные сведения о явной реализации см. в статьях [Явная реализация интерфейса](explicit-interface-implementation.md) и [Свойства интерфейса](../classes-and-structs/interface-properties.md).

Интерфейс может наследовать от одного или нескольких интерфейсов. Производный интерфейс наследует члены от своих базовых интерфейсов. Класс, реализующий производный интерфейс, должен реализовывать все члены в нем, включая все члены базовых интерфейсов производного интерфейса. Этот класс может быть неявно преобразован в производный интерфейс или любой из его базовых интерфейсов. Класс может включать интерфейс несколько раз через наследуемые базовые классы или через интерфейсы, которые наследуются другими интерфейсами. Однако класс может предоставить реализацию интерфейса только однократно и только если класс объявляет интерфейс как часть определения класса (`class ClassName : InterfaceName`). Если интерфейс наследуется, поскольку наследуется базовый класс, реализующий этот интерфейс, то базовый класс предоставляет реализацию членов этого интерфейса. Но производный класс может повторно реализовать любые члены виртуального интерфейса и не использовать наследованную реализацию. Когда интерфейсы объявляют реализацию метода по умолчанию, любой класс, реализующий данный интерфейс, наследует эту реализацию. Реализации, определенные в интерфейсах, являются виртуальными, и реализующий класс может переопределить эту реализацию.

Базовый класс также может реализовывать члены интерфейса с помощью виртуальных членов. В таком случае производный класс может изменять поведение интерфейса путем переопределения виртуальных членов. Дополнительные сведения о виртуальных членах см. в статье [Полиморфизм](../classes-and-structs/polymorphism.md).

## <a name="interfaces-summary"></a>Сводка по интерфейсам

Интерфейс имеет следующие свойства.

- Интерфейс обычно подобен абстрактному базовому классу, имеющему только абстрактные члены. Любой класс (или структура), реализующий интерфейс, должен реализовывать все его члены. При необходимости интерфейс может определять реализации по умолчанию для некоторых или для всех его членов. Дополнительные сведения см. в статье о [методах интерфейса по умолчанию](../../whats-new/tutorials/default-interface-methods-versions.md).
- Невозможно создать экземпляр интерфейса напрямую. Его члены реализуются любым классом (или структурой), реализующим интерфейс.
- Класс или структура может реализовывать несколько интерфейсов. Класс может наследовать базовому классу и также реализовывать один или несколько интерфейсов.

## <a name="related-sections"></a><a name="BKMK_RelatedSections"></a> Связанные разделы

- [Свойства интерфейса](../classes-and-structs/interface-properties.md)  
- [Индексаторы в интерфейсах](../indexers/indexers-in-interfaces.md)  
- [Практическое руководство. Реализация событий интерфейса](../events/how-to-implement-interface-events.md)
- [Классы и структуры](../classes-and-structs/index.md)  
- [Наследование](../classes-and-structs/inheritance.md)  
- [Интерфейсы](../../language-reference/keywords/interface.md)
- [Методы](../classes-and-structs/methods.md)  
- [Полиморфизм](../classes-and-structs/polymorphism.md)  
- [Абстрактные и запечатанные классы и члены классов](../classes-and-structs/abstract-and-sealed-classes-and-class-members.md)  
- [Свойства](../classes-and-structs/properties.md)  
- [События](../events/index.md)  
- [Индексаторы](../indexers/index.md)
  
## <a name="see-also"></a>См. также

- [Руководство по программированию на C#](../index.md)
- [Наследование](../classes-and-structs/inheritance.md)
- [Имена идентификаторов](../inside-a-program/identifier-names.md)
