---
title: Как определить равенство значений для класса или структуры. Руководство по программированию на C#
description: Узнайте, как определить равенство значений для класса или структуры. Изучите примеры кода и другие доступные ресурсы.
ms.date: 03/26/2021
helpviewer_keywords:
- overriding Equals method [C#]
- object equivalence [C#]
- Equals method [C#], overriding
- value equality [C#]
- equivalence [C#]
ms.assetid: 4084581e-b931-498b-9534-cf7ef5b68690
ms.openlocfilehash: fd8e1e14650a836178534b44dc332215c0d0586a
ms.sourcegitcommit: 109507b6c16704ed041efe9598c70cd3438a9fbc
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/31/2021
ms.locfileid: "106079457"
---
# <a name="how-to-define-value-equality-for-a-class-or-struct-c-programming-guide"></a>Как определить равенство значений для класса или структуры (руководство по программированию на C#)

[Записи](../classes-and-structs/records.md) автоматически реализуют равенство значений. Попробуйте определить `record` вместо `class`, когда ваш тип моделирует данные и должен реализовать равенство значений.

При определении класса или структуры необходимо решить, имеет ли смысл создавать пользовательское определение равенства значений (или эквивалентности) для этого типа. Обычно равенство значений реализуется, если объекты этого типа будут добавляться в коллекции или если они предназначены в первую очередь для хранения набора полей или свойств. В основу определения равенства значений можно положить сравнение всех полей и свойств в типе или только их части.

В любом случае, реализация как для классов, так и для структур, должна соответствовать следующим пяти принципам обеспечения эквивалентности (в следующих правилах предполагается, что `x`, `y` и `z` не равны NULL):  
  
1. Рефлексивное свойство: `x.Equals(x)` возвращает `true`.
  
2. Симметричное свойство: `x.Equals(y)` возвращает то же значение, что и `y.Equals(x)`.
  
3. Транзитивное свойство: если `(x.Equals(y) && y.Equals(z))` возвращает `true`, `x.Equals(z)` возвращает `true`.
  
4. Последовательные вызовы `x.Equals(y)` возвращают одно и то же значение до тех пор, пока не будут изменены объекты, на которые ссылаются x и y.  
  
5. Любое значение, отличающееся от NULL, не равно NULL. Поэтому `x.Equals(y)` вызывает исключение, если `x` имеет значение NULL. Это нарушает правила 1 или 2 в зависимости от аргумента для `Equals`.

Любая определяемая вами структура имеет заданную по умолчанию реализацию равенства значений, которая наследуется от переопределения <xref:System.ValueType?displayProperty=nameWithType> метода <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>. Эта реализация использует отражение для проверки всех полей и свойств в типе. Хотя эта реализация возвращает верный результат, она отличается невысокой скоростью по сравнению с пользовательской реализацией, которую можно написать специально для конкретного типа.  
  
Детали реализации равенства значений для классов и структур различаются. Однако для реализации равенства как для классов, так и для структур, необходимо выполнить одни и те же базовые действия.  
  
1. Переопределите [виртуальный](../../language-reference/keywords/virtual.md) метод <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>. В большинстве случаев пользовательская реализация `bool Equals( object obj )` должна вызывать относящийся к конкретному типу метод `Equals`, который является реализацией интерфейса <xref:System.IEquatable%601?displayProperty=nameWithType>. (См. шаг 2.)  
  
2. Реализуйте интерфейс <xref:System.IEquatable%601?displayProperty=nameWithType>, предоставив метод `Equals` для конкретного типа. Именно на этом этапе происходит фактическое сравнение значений. Например, функцию равенства можно определить путем сравнения только одного из двух полей в типе. Не создавайте исключения в `Equals`. Для классов, которые связаны наследованием, должно соблюдаться следующее.

   * этот метод должен проверять только те поля, которые объявлены в классе. Он должен вызывать метод `base.Equals` для проверки полей в базовом классе. (Не вызывайте `base.Equals`, если тип наследует напрямую от <xref:System.Object>, так как реализация <xref:System.Object> для <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> выполняет проверку равенства ссылок.)

   * Две переменные должны считаться равными, только если совпадают их типы времени выполнения. Также убедитесь, что реализация `IEquatable` метода `Equals` для типов времени выполнения используется, если типы времени выполнения и времени компиляции переменной отличаются. Одна из стратегий обеспечения правильного сравнения типов времени выполнения — реализация `IEquatable` только в классах `sealed`. Дополнительные сведения см. в [примере класса](#class-example) ниже в этой статье.
  
3. Необязательно, но рекомендуется: перегрузите операторы [==](../../language-reference/operators/equality-operators.md#equality-operator-) и [!=](../../language-reference/operators/equality-operators.md#inequality-operator-).  
  
4. Переопределите <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> таким образом, чтобы два объекта с равными значениями создавали одинаковый хэш-код.  
  
5. Необязательные: Для поддержки определений "больше" и "меньше" реализуйте для типа интерфейс <xref:System.IComparable%601>, а также перегрузите операторы [<=](../../language-reference/operators/comparison-operators.md#less-than-or-equal-operator-) и [>=](../../language-reference/operators/comparison-operators.md#greater-than-or-equal-operator-).  

> [!NOTE]
> Начиная с версии C# 9.0 можно использовать записи для получения семантики равенства значений без ненужного стандартного кода.

## <a name="class-example"></a>Пример класса

В следующем примере показана реализация равенства значений в классе (ссылочный тип).

:::code language="csharp" source="snippets/how-to-define-value-equality-for-a-type/ValueEqualityClass/Program.cs":::

В классах (ссылочных типах) реализация по умолчанию обоих методов <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> выполняет проверку равенства ссылок, а не значений. Когда разработчик переопределяет виртуальный метод, его задача заключается в том, чтобы реализовать семантику равенства значений.

К объектам класса можно применять операторы `==` и `!=`, даже если они не были перегружены в классе. Однако по умолчанию они служат для проверки равенства ссылок. При перегрузке в классе метода `Equals` необходимо перегрузить операторы `==` и `!=`, но это необязательно.

> [!IMPORTANT]
> Приведенный выше код может не поддерживать все сценарии наследования, как ожидается. Рассмотрим следующий код.
>
> ```csharp
> TwoDPoint p1 = new ThreeDPoint(1, 2, 3);
> TwoDPoint p2 = new ThreeDPoint(1, 2, 4);
> Console.WriteLine(p1.Equals(p2)); // output: True
> ```
>
> Этот код сообщает, что `p1` и `p2` равны несмотря на разницу в значениях `z`. Эта разница игнорируется, так как компилятор выбирает реализацию `TwoDPoint` для `IEquatable` на основе типа времени компиляции.
>
> Встроенный механизм обеспечения равенства значений типов `record` поддерживает такие сценарии. Если бы `TwoDPoint` и `ThreeDPoint` имели тип `record`, результатом `p1.Equals(p2)` было бы значение `False`. См. дополнительные сведения о [равенстве в иерархиях наследования типа `record`](../../language-reference/builtin-types/record.md#equality-in-inheritance-hierarchies).

## <a name="struct-example"></a>Пример структуры

В следующем примере показана реализация равенства значений в структуре (тип значения).

:::code language="csharp" source="snippets/how-to-define-value-equality-for-a-type/ValueEqualityStruct/Program.cs":::
  
Для структур реализация по умолчанию <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> (представляет собой переопределенную версию в <xref:System.ValueType?displayProperty=nameWithType>) выполняет проверку равенства значений посредством отражения, сравнивая значения каждого поля в типе. Когда разработчик переопределяет виртуальный метод `Equals` в структуре, его задача состоит в том, чтобы найти более эффективный способ проверки равенства значений и, если это возможно, реализовать сравнение только на основании части полей или свойств структуры.
  
Операторы [==](../../language-reference/operators/equality-operators.md#equality-operator-) и [!=](../../language-reference/operators/equality-operators.md#inequality-operator-) нельзя применять к структурам, если только они явным образом не перегружены для структуры.

## <a name="see-also"></a>См. также

- [Сравнения на равенство](equality-comparisons.md)
- [Руководство по программированию на C#](../index.md)
