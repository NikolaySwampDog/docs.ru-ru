---
title: История языка C# (руководство по C#)
description: На что был похож этот язык в ранних версиях и во что он превратился сейчас?
author: erikdietrich
ms.date: 04/08/2020
ms.openlocfilehash: 0c427563701bd3bff87178022feab19f4dcfc519
ms.sourcegitcommit: c7f0beaa2bd66ebca86362ca17d673f7e8256ca6
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/23/2021
ms.locfileid: "104877063"
---
# <a name="the-history-of-c"></a>История языка C\#

В этой статье содержится описание основных выпусков языка C#. Команда разработчиков C# продолжает добавлять новые функции. Сведения о состоянии функции для отдельных языков, включая функции, которые будут добавлены в предстоящие выпуски, см. [в репозитории dotnet/roslyn](https://github.com/dotnet/roslyn/blob/main/docs/Language%20Feature%20Status.md) на сайте GitHub.

> [!IMPORTANT]
> В некоторых возможностях используются типы и методы, которые в спецификации C# определены как *стандартная библиотека*. Платформа .NET предоставляет эти типы и методы в разных пакетах. например, обработка исключений. Каждая инструкция и выражение `throw` проверяется, чтобы убедиться, что вызываемый объект является производным от <xref:System.Exception>. Аналогичным образом каждая инструкция `catch` проверяется, чтобы убедиться, что перехваченный тип является производным от <xref:System.Exception>. В каждой версии могут добавляться новые требования. Чтобы использовать новейшие возможности языка в старой среде, может потребоваться установить определенные библиотеки. Эти зависимости описаны на странице для каждой конкретной версии. Дополнительные сведения о связи между языком и библиотекой, а также общие сведения о такой зависимости см. [здесь](relationships-between-language-and-library.md).

Для использования средств сборки C# требуется последний основной выпуск версии языка по умолчанию. Основные выпуски, описанные в других статьях этого раздела, могут чередоваться с дополнительными выпусками. Чтобы использовать новые возможности доработанного выпуска, [настройте версию языка компилятора](../language-reference/configure-language-version.md), выбрав необходимую. После C# 7.0 было три дополнительных выпуска:

- C# 7.3.
  - Версия C# 7.3 появилась в [Visual Studio 2017 версии 15.7](https://visualstudio.microsoft.com/vs/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link) и [пакете SDK для .NET Core 2.1](../../core/whats-new/dotnet-core-2-1.md).
- C# 7.2.
  - Версия C# 7.2 появилась в [Visual Studio 2017 версии 15.5](https://visualstudio.microsoft.com/vs/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link) и [пакете SDK для .NET Core 2.0](../../core/whats-new/dotnet-core-2-0.md).
- C# 7.1.
  - Версия C# 7.1 появилась в [Visual Studio 2017 версии 15.3](https://visualstudio.microsoft.com/vs/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link) и [пакете SDK для .NET Core 2.0](../../core/whats-new/dotnet-core-2-0.md).

## <a name="c-version-10"></a>C# версии 1.0

Если взглянуть на C# версии 1.0, выпущенный вместе с Visual Studio .NET 2002, станет очевидно его сходство с Java. В число [поставленных перед ECMA задач проектирования](https://feeldotneteasy.blogspot.com/2011/01/c-design-goals.html) входило создание "простого и современного объектно-ориентированного языка общего назначения".  В то время схожесть с Java означала достижение этих ранних целей проектирования.

Однако если взглянуть на C# 1.0 сейчас, вам может стать немного не по себе. В этой версии не было встроенных асинхронных возможностей и некоторых функций для универсальных шаблонов, к которым вы уже привыкли. Фактически, в ней вообще не было универсальных шаблонов.  А [LINQ](../linq/index.md)? Еще нет. Для добавления этих возможностей потребовалось несколько лет.

По современным меркам C# версии 1.0 не предоставлял практически никаких возможностей. Вам пришлось бы писать довольно подробный код. Однако надо же было с чего-то начинать. C# версии 1.0 был достойной альтернативой Java на платформе Windows.

Основные возможности C# 1.0 включали следующие компоненты:

- [Классы](../programming-guide/classes-and-structs/classes.md)
- [Структуры](../language-reference/builtin-types/struct.md)
- [Интерфейсы](../programming-guide/interfaces/index.md)
- [События](../events-overview.md)
- [Свойства](../properties.md)
- [Делегаты](../delegates-overview.md)
- [Операторы и выражения](../language-reference/operators/index.md)
- [Операторы](../programming-guide/statements-expressions-operators/statements.md)
- [Атрибуты](../programming-guide/concepts/attributes/index.md)

## <a name="c-version-12"></a>Версия для C# 1.2

Версия C# 1.2 входит в состав Visual Studio .NET 2003. Она содержит ряд небольших улучшений языка. Наиболее значительным изменением является то, что начиная с этой версии код, создаваемый в цикле `foreach`, вызывает <xref:System.IDisposable.Dispose%2A> в <xref:System.Collections.IEnumerator>, если <xref:System.Collections.IEnumerator> реализует <xref:System.IDisposable>.

## <a name="c-version-20"></a>C# версии 2.0

Вот теперь все становится гораздо интереснее. Давайте рассмотрим некоторые основные возможности языка C# 2.0, выпущенного в 2005 году вместе с Visual Studio 2005:

- [Универсальные шаблоны](../programming-guide/generics/index.md)
- [Разделяемые типы](../programming-guide/classes-and-structs/partial-classes-and-methods.md#partial-classes)
- [Анонимные методы](../language-reference/operators/delegate-operator.md)
- [Типы значений, допускающие значение NULL](../language-reference/builtin-types/nullable-value-types.md)
- [Итераторы](../programming-guide/concepts/iterators.md)
- [Ковариантность и контравариантность](../programming-guide/concepts/covariance-contravariance/index.md)

Другие возможности C# 2.0 расширяли существующие возможности:

- Отдельный доступ к методу получения и методу задания
- Преобразования групп методов (делегаты)
- Статические классы
- Выведение делегата

Хотя сначала C# и был универсальным объектно-ориентированным языком, в C# версии 2.0 все кардинально изменилось. Нащупав опору под ногами, команда уделила внимание решению серьезных проблем, с которыми сталкивались разработчики. И они подошли к делу с огоньком.

Благодаря универсальным шаблонам вы получаете типы и методы, которые могут работать с произвольным типом, при этом обеспечивая безопасность типа. В результате, например, наличие <xref:System.Collections.Generic.List%601> позволяет использовать `List<string>` или `List<int>` и совершать типобезопасные операции с этими строками или целыми числами, выполняя итерацию по ним. Использовать универсальные шаблоны удобнее, чем создавать тип `ListInt`, производный от `ArrayList`, или выполнять приведение из `Object` для каждой операции.

В C# версии 2.0 появились итераторы. Если кратко, итераторы позволяют изучать все элементы в `List` (или других перечислимых типов) с помощью цикла `foreach`. Наличие итераторов в качестве первоклассного компонента в языке значительно улучшило удобочитаемость языка и способность воспринимать код.

А еще C# продолжил играть в салки с Java. Для Java уже были выпущены версии, включающие универсальные шаблоны и итераторы. Но вскоре этому было суждено измениться, так как языки продолжили развиваться независимо.

## <a name="c-version-30"></a>C# версии 3.0

C# версии 3.0 был выпущен в конце 2007 года вместе с Visual Studio 2008, однако существенно набор возможностей языка пополнится только в .NET Framework версии 3.5. Эта версия ознаменовала кардинальное изменение развития C#. Она доказала, что C# действительно является достойным языком программирования. Давайте рассмотрим некоторые основные возможности в этой версии:

- [Автоматически реализуемые свойства](../programming-guide/classes-and-structs/auto-implemented-properties.md)
- [Анонимные типы](../programming-guide/classes-and-structs/anonymous-types.md)
- [Выражения запросов](../linq/query-expression-basics.md)
- [Лямбда-выражения](../language-reference/operators/lambda-expressions.md)
- [Деревья выражений](../expression-trees.md)
- [Методы расширения](../programming-guide/classes-and-structs/extension-methods.md)
- [Неявно типизированные локальные переменные](../language-reference/keywords/var.md)
- [Разделяемые методы](../language-reference/keywords/partial-method.md)
- [Инициализаторы объектов и коллекций](../programming-guide/classes-and-structs/object-and-collection-initializers.md)

Если оглянуться назад, становится ясно, что многие из этих возможностей не могли не появиться или появиться отдельно друг от друга. Все они образуют единый и стратегически значимый набор. Принято считать, что уникальным преимуществом C# было выражение запроса, которое также называется LINQ.

Немного углубившись, можно отметить деревья выражений, лямбда-выражения и анонимные типы как основу для создания LINQ. Однако в любом случае в C# 3.0 была представлена революционная концепция. Версия C# 3.0 начала закладывать фундамент для превращения C# в гибридный объектно-ориентированный/функциональный язык.

Среди прочего, теперь вы можете создавать декларативные запросы в стиле SQL для выполнения операций с коллекциями. Вместо создания цикла `for` для вычисления среднего значения из списка целых чисел теперь вам достаточно использовать `list.Average()`. Сочетание выражений запросов и методов расширения позволяет сделать работу со списком целых чисел гораздо интеллектуальнее.

Людям потребовалось некоторое время, чтобы принять эту концепцию и начать применять ее, но это у них получилось. А теперь, спустя несколько лет, код стал гораздо более кратким, простым и функциональным.

## <a name="c-version-40"></a>C# версии 4.0

Разработчикам версии C# 4.0, выпущенной вместе с Visual Studio 2010, пришлось приложить серьезные усилия, чтобы не отставать от новаторской версии 3.0. С появлением версии 3.0 язык C# смог выйти из тени Java и занять доминирующее положение. Он быстро становился утонченным и элегантным.

Следующая версия представила ряд интересных функций:

- [Динамическая привязка](../language-reference/builtin-types/reference-types.md)
- [Именованные/дополнительные аргументы](../programming-guide/classes-and-structs/named-and-optional-arguments.md)
- [Универсальная ковариантность и контравариантность](../../standard/generics/covariance-and-contravariance.md)
- [Внедренные типы взаимодействия](../../framework/interop/type-equivalence-and-embedded-interop-types.md)

Внедренные типы взаимодействия помогли сделать развертывание более удобным. Универсальная ковариантность и контравариантность расширяют возможности применения универсальных шаблонов, однако эти функции несколько академичны и высоко оценены авторами, создающими платформы и библиотеки. Именованные и дополнительные параметры позволяют избавиться от многих перегрузок методов и сделать работу более удобной. Однако ни одна из этих функций не является кардинальным изменением.

Значимым событием стало появление ключевого слова `dynamic`. Благодаря ключевому слову `dynamic` в C# версии 4.0 появилась возможность переопределять компилятор при типизации во время компиляции. Используя это ключевое слово, вы можете создавать конструкции, характерные для языков с динамической типизацией, таких как JavaScript. Вы можете создать `dynamic x = "a string"` и добавить туда шестерку, отложив решение о дальнейших действиях во времени выполнения.

Динамическое связывание подвержено ошибкам, однако открывает великолепные возможности внутри языка.

## <a name="c-version-50"></a>C# версии 5.0

Версия C# 5.0, выпущенная вместе с Visual Studio 2012, была крайне целенаправленной. Практически все нововведения в этой версии касались другой инновационной концепции: модели `async` и `await` для асинхронного программирования.  Ниже приведен список основных функций:

- [Асинхронные члены](../async.md)
- [Информационные атрибуты вызывающего объекта](../language-reference/attributes/caller-information.md)

### <a name="see-also"></a>См. также

- [Code Project. Информационные атрибуты вызывающего объекта в C# 5.0](https://www.codeproject.com/Tips/606379/Caller-Info-Attributes-in-Csharp)

Информационный атрибут вызывающего объекта позволяет легко получать сведения о контексте, в котором выполняется работа, не прибегая к массивному стандартному коду отражения. Он находит обширное применение в задачах диагностики и ведения журнала.

Однако настоящими звездами этого выпуска являются `async` и `await`. После появления этих функций в 2012 г. C# удалось снова взять быка за рога, первоклассным образом внедрив асинхронность в язык. Если вы когда-либо сталкивались с длительными операциями и реализацией переплетающихся обратных вызовов, эта возможность, скорее всего, вам понравится.

## <a name="c-version-60"></a>C# версии 6.0

Версии 3.0 и 5.0 добавили в объектно-ориентированный язык C# несколько впечатляющих возможностей. Версия 6.0, выпущенная вместе с Visual Studio 2015, отступает от подхода, ориентированного на реализацию уникальных возможностей. Здесь предоставляются менее масштабные функции, с которыми программирование на C# становится гораздо эффективнее. Вот некоторые из них:

- [Статические импорты](../language-reference/keywords/using-static.md)
- [Фильтры исключений](../language-reference/keywords/when.md)
- [Инициализаторы автосвойств](../properties.md)
- [Элементы, воплощающие выражение](../language-reference/operators/lambda-operator.md#expression-body-definition)
- [Null-распространитель](../language-reference/operators/member-access-operators.md#null-conditional-operators--and-)
- [Интерполяция строк](../language-reference/tokens/interpolated.md)
- [Оператор nameof](../language-reference/operators/nameof.md)

Другие новые возможности:

- Инициализаторы индекса
- Выражение Await в блоках Catch и Finally
- Значения по умолчанию для свойств метода получения

Каждая из этих функций интересна сама по себе. Но если взглянуть на них вместе, заметна интересная особенность. В этой версии C# избавился от стандартного текста, чтобы сделать код более сжатым и удобочитаемым. Поэтому эта версия, несомненно, привлечет сторонников простого и понятного кода.

Еще одно новшество, связанное с этой версией, не является функцией языка в обычном понимании. Состоялся выпуск [компилятора Roslyn в виде службы](https://github.com/dotnet/roslyn). Теперь компилятор C# написан на C#, и вы можете использовать его при программировании.

## <a name="c-version-70"></a>C# версии 7.0

C# версии 7.0 был выпущен вместе с Visual Studio 2017. В этой версии получили развитие некоторые функции из версии C# 6.0, однако компилятор в виде службы отсутствует. Ниже приведены некоторые из новых функций:

- [Переменные Out](./csharp-7.md#out-variables)
- [Кортежи и деконструкция](./csharp-7.md#tuples-and-discards)
- [Сопоставление шаблонов](./csharp-7.md#pattern-matching)
- [Локальные функции](./csharp-7.md#local-functions)
- [Расширенные элементы, воплощающие выражение](./csharp-7.md#more-expression-bodied-members)
- [Локальные переменные и возвращаемые значения Ref](./csharp-7.md#ref-locals-and-returns)

Другие возможности:

- [Операции удаления](./csharp-7.md#tuples-and-discards)
- [Двоичные литералы и цифровые разделители](./csharp-7.md#numeric-literal-syntax-improvements)
- [Выражения throw](./csharp-7.md#throw-expressions)

Все это предоставляет разработчиком множество новых возможностей и позволяет писать более понятный код. Важным аспектом является доработка объявления переменных путем использования ключевого слова `out` и поддержки нескольких возвращаемых значений благодаря кортежу.

Но при этом сфера применения C# продолжает расширяться. Теперь .NET Core подходит для любой операционной системы, а также уверенно движется в направлении облачных технологий и портативности.  Очевидно, что разработчики активно занимаются этими новыми возможностями наравне с добавлением новых функций.

## <a name="c-version-71"></a>C# версии 7.1

C# начали выпускать *доработанные выпуски* с C# 7.1. В этой версии добавлен элемент конфигурации [выбора версии языка](../language-reference/configure-language-version.md), три новых возможности языка и новое поведение компилятора.

Новые языковые функции в этом выпуске

- [Метод `async` `Main`](./csharp-7.md#async-main)
  - Точка входа для приложения может иметь модификатор `async`.
- [Литеральные выражения `default`](./csharp-7.md#default-literal-expressions)
  - Литеральные выражения по умолчанию можно использовать в выражениях значения по умолчанию, если можно вывести тип целевого объекта.
- [Выводимые имена элементов кортежа](./csharp-7.md#tuples-and-discards)
  - Имена элементов кортежа часто можно вывести из инициализации кортежа.
- [Сопоставление шаблонов в параметрах универсального типа](./csharp-7.md#pattern-matching)
  - Выражения сопоставления шаблонов можно использовать с переменными, тип которых является параметром универсального типа.

Наконец, у компилятора есть два параметра `-refout` и `-refonly`, которые управляют [созданием базовой сборки](./csharp-7.md#reference-assembly-generation).

## <a name="c-version-72"></a>C# версии 7.2

В C# 7.2 добавлено несколько небольших языковых функций:

- [Методы написания безопасного и эффективного кода](./csharp-7.md#enabling-more-efficient-safe-code)
  - Ряд улучшений синтаксиса, обеспечивающих работу с типами значений с использованием семантики ссылок.
- [Неконечные именованные аргументы](./csharp-7.md#non-trailing-named-arguments)
  - После именованных аргументов могут следовать позиционные аргументы.
- [Начальные символы подчеркивания в числовых литералах](./csharp-7.md#numeric-literal-syntax-improvements)
  - Перед любыми печатными знаками в числовых литералах теперь могут использоваться начальные знаки подчеркивания.
- [Модификатор доступа `private protected`](./csharp-7.md#private-protected-access-modifier)
  - Модификатор доступа `private protected` разрешает доступ для производных классов в одной сборке.
- [Условные выражения`ref`](./csharp-7.md#conditional-ref-expressions)
  - Результат условного выражения `?:` теперь может быть ссылкой.

## <a name="c-version-73"></a>C# версии 7.3

Новые возможности в выпуске C# 7.3 можно разделить на две основные группы. Одна из них — набор функций для повышения эффективности безопасного кода до уровня небезопасного кода. Вторая — постепенные улучшения существующих функций. Кроме того, в этом выпуске добавлены новые параметры компилятора.

В ту группу, которая отвечает за повышение производительности безопасного кода, входят следующие новые возможности:

- [доступ к полям фиксированной ширины без закрепления;](csharp-7.md#indexing-fixed-fields-does-not-require-pinning)
- [возможность переназначать локальные переменные `ref`;](csharp-7.md#enabling-more-efficient-safe-code)
- [возможность использовать инициализаторы для массивов `stackalloc`;](csharp-7.md#stackalloc-arrays-support-initializers)
- [возможность использовать инструкции `fixed` с любым типом, который поддерживает шаблон;](csharp-7.md#more-types-support-the-fixed-statement)
- [возможность использовать дополнительные универсальные ограничения.](csharp-7.md#enhanced-generic-constraints)

Для существующих функций предоставлены следующие улучшения:

- возможность проверить `==` и `!=` с типами кортежа;
- больше мест для использование переменных выражений;
- возможность подключить атрибуты к резервному полю автоматически реализуемых свойств;
- улучшенное разрешение методов, аргументы которых отличаются модификатором `in`;
- стало меньше неоднозначных вариантов при разрешении перегрузок.

Новые параметры компилятора:

- `-publicsign` позволяет включить подписывание сборок как программного обеспечения с открытым кодом;
- `-pathmap` позволяет предоставить сопоставление для исходных каталогов.

## <a name="c-version-80"></a>C# версии 8.0

C# 8.0 — это первый основной выпуск C#, специально предназначенный для .NET Core. Некоторые функции основаны на новых возможностях среды CLR, другие — на типах библиотек, добавленных только в .NET Core. В C# 8.0 добавлены следующие функции и улучшения языка C#:

- [Члены только для чтения](./csharp-8.md#readonly-members)
- [Методы интерфейса по умолчанию](./csharp-8.md#default-interface-methods)
- [Улучшения сопоставления шаблонов](./csharp-8.md#more-patterns-in-more-places):
  - [выражения switch](./csharp-8.md#switch-expressions);
  - [шаблоны свойств](./csharp-8.md#property-patterns);
  - [шаблоны кортежей](./csharp-8.md#tuple-patterns);
  - [позиционные шаблоны](./csharp-8.md#positional-patterns).
- [Объявления using](./csharp-8.md#using-declarations).
- [Статические локальные функции](./csharp-8.md#static-local-functions).
- [Удаляемые ссылочные структуры](./csharp-8.md#disposable-ref-structs).
- [Ссылочные типы, допускающие значение NULL](../language-reference/builtin-types/nullable-reference-types.md)
- [Асинхронные потоки](./csharp-8.md#asynchronous-streams).
- [Индексы и диапазоны](./csharp-8.md#indices-and-ranges).
- [Присваивание объединения со значением NULL](./csharp-8.md#null-coalescing-assignment)
- [Неуправляемые сконструированные типы](./csharp-8.md#unmanaged-constructed-types)
- [Выражение stackalloc во вложенных выражениях](./csharp-8.md#stackalloc-in-nested-expressions)
- [Улучшение интерполированных строк verbatim](./csharp-8.md#enhancement-of-interpolated-verbatim-strings)

Для членов интерфейса по умолчанию требуются улучшения среды CLR. Эти функции были добавлены в среду CLR для .NET Core 3.0. Для диапазонов и индексов, а также для асинхронных потоков требуются новые типы в библиотеках .NET Core 3.0. Ссылочные типы, допускающие значение NULL, реализованные в компиляторе, гораздо удобнее использовать, когда библиотеки снабжаются заметками для предоставления семантической информации о состоянии NULL аргументов и возвращаемых значений. Эти заметки сейчас добавляются в библиотеки .NET Core.

_Статья_ [_изначально опубликована в блоге NDepend_](https://blog.ndepend.com/c-versions-look-language-history/) _, с разрешения Эрика Дитриха (Erik Dietrich) и Патрика Смачиа (Patrick Smacchia)._
