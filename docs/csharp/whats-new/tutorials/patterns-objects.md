---
title: Использование шаблонов в объектах — учебник по C#
description: В этом учебнике описаны методы использования сопоставления шаблонов в элементах класса для создания лучших моделей поведения объектов
ms.date: 11/05/2020
ms.openlocfilehash: 072f6f57696504c2d691473e3a43c1cda53f227f
ms.sourcegitcommit: c7f0beaa2bd66ebca86362ca17d673f7e8256ca6
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/23/2021
ms.locfileid: "104878973"
---
# <a name="use-pattern-matching-to-build-your-class-behavior-for-better-code"></a>Использование сопоставления шаблонов для создания поведения класса и улучшения кода

Функции сопоставления шаблонов в C# предоставляют синтаксис для выражения алгоритмов. Эти методы можно использовать для реализации поведения в классах. Объектно-ориентированную архитектуру класса можно объединить с реализацией, ориентированной на данные, чтобы обеспечить лаконичный код при моделировании реальных объектов.

Из этого руководства вы узнаете, как выполнять следующие задачи:

> [!div class="checklist"]
>
> - Выражать объектно-ориентированные классы с помощью шаблонов данных.
> - Внедрять эти шаблоны, используя функции сопоставления шаблонов на C#.
> - Использовать диагностику компилятора для проверки реализации.

## <a name="prerequisites"></a>Предварительные требования

Вам нужно настроить свой компьютер для выполнения .NET 5, включая компилятор C# 9.0. Компилятор C# 9.0 доступен в [Visual Studio 2019 версии 16.8 (предварительная версия)](https://visualstudio.microsoft.com/vs/preview/) или в [пакете SDK .NET 5.0 (предварительная версия)](https://dotnet.microsoft.com/download/dotnet/5.0).

## <a name="build-a-simulation-of-a-canal-lock"></a>Создание симуляции шлюза канала

В этом руководстве вы создадите класс C#, который симулирует [шлюз канала](https://en.wikipedia.org/wiki/Lock_(water_navigation)). Шлюз — это устройство, которое поднимает и опускает судна, которые перемещаются между двумя водными пространствами на разных уровнях. Шлюз включает двое ворот и механизм для изменения уровня воды.

При эксплуатации в обычных условиях судно входит в одни из ворот, при этом уровень воды в шлюзе соответствует уровню воды на стороне входа судна. Когда судно находится в шлюзовой камере, уровень воды изменяется, чтобы соответствовать уровню воды камеры, из которой судно будет выходить. Как только уровень воды соответствует уровню воды камеры выхода, в камере выхода открываются ворота. Меры безопасности настроены таким образом, чтобы оператор не мог создать опасную ситуацию в шлюзе. Уровень воды изменяется только при закрытых воротах. Можно открыть только одни ворота. Чтобы открыть ворота, внутренний уровень воды в шлюзе должен соответствовать уровню воды на выходе.

Для моделирования такого поведения можно создать класс C#. Класс `CanalLock` будет поддерживать команды для открытия или закрытия обоих ворот. А также иметь разные команды для увеличения или уменьшения уровня воды. Класс также должен поддерживать свойства для чтения текущего состояния ворот и уровня воды. Ваши методы будут реализовать меры безопасности.

## <a name="define-a-class"></a>Определение класса

Вам нужно будет создать консольное приложение для тестирования класса `CanalLock`. Создайте новый консольный проект для .NET 5 с помощью Visual Studio или интерфейса командной строки .NET. Затем добавьте новый класс и назовите его `CanalLock`. Теперь создайте общедоступный API, однако не реализуйте методы:

:::code language="csharp" source="snippets/pattern-objects/InterimSteps.cs" ID="APIDesign":::

Приведенный выше код инициализирует объект таким образом, чтобы и те и другие ворота были закрыты, а уровень воды оставался низким. Далее напишите следующий код проверки в методе `Main`, который поможет вам создать первую реализацию класса:

:::code language="csharp" source="snippets/pattern-objects/Program.cs" ID="HappyTests":::

Затем добавьте первую реализацию каждого метода в класс `CanalLock`. Следующий код реализует методы класса, не влияя на правила безопасности. Испытания на безопасность будут добавлены позже:

:::code language="csharp" source="snippets/pattern-objects/InterimSteps.cs" ID="FirstImplementation":::

Тесты, которые вы написали, прошли успешно. Вы реализовали основы. Теперь напишите тест для условия независимого отказа. По окончании предыдущих тестов одни и другие ворота закрыты, а уровень воды — низкий. Добавьте тест для открытия верхних ворот:

:::code language="csharp" source="snippets/pattern-objects/Program.cs" ID="HighGateSafetyTest":::

Тест завершается сбоем, поскольку ворота открываются. Для первой реализации внесите исправления, используя следующий код:

:::code language="csharp" source="snippets/pattern-objects/InterimSteps.cs" ID="SecondImplementation":::

Тесты успешно пройдены. При добавлении дополнительных тестов вы добавляете дополнительные `if` предложений и проверяете различные свойства. При добавлении дополнительных условий со временем методы становятся слишком сложными.

## <a name="implement-the-commands-with-patterns"></a>Реализация команд с помощью шаблонов

Лучшим решением станет использование *шаблонов*, чтобы определить, находится ли объект в допустимом состоянии для выполнения команды. Вы можете выразить разрешение на выполнение команды в качестве функции с тремя переменными: состояние ворот, уровень воды и новый параметр.

| Новый параметр | Состояние ворот | Уровень воды | Результат             |
| ----------- | ---------- | ----------- | ------------------ |
| Закрыто      | Закрыто     | Высокий        | Закрыто             |
| Закрыто      | Закрыто     | Низкий         | Закрыто             |
| Закрыто      | Открыть       | Высокий        | Открыть               |
| ~~Закрыто~~  | ~~Открыть~~   | ~~Низкая~~     | ~~Закрыто~~         |
| Открыть        | Закрыто     | Высокий        | Открыть               |
| Открыть        | Закрыто     | Низкий         | Закрыто (ошибка)     |
| Открыть        | Открыть       | Высокий        | Открыть               |
| ~~Открыть~~    | ~~Открыть~~   | ~~Низкая~~     | ~~Закрыто (ошибка)~~ |

Текст четвертой и последней строки в таблице зачеркнут, поскольку они недопустимы. Добавленный код должен гарантировать, что верхние ворота никогда не откроются при низком уровне воды.  Эти состояния можно запрограммировать как одиночное выражение switch (помните, что `false` означает "Закрыто"):

:::code language="csharp" source="snippets/pattern-objects/InterimSteps.cs" ID="ThirdImplementation":::

Попробуйте эту версию. Тесты пройдены, проверка кода. В полной таблице показаны возможные комбинации входных и выходных значений. Это означает, что вы и другие разработчики можете взглянуть на таблицу и проверить охват всех возможных входных данных. И даже проще — вам в этом может помочь компилятор. После добавления предыдущего кода можно увидеть, что компилятор выдает предупреждение: *CS8524* указывает, что выражение switch не охватывает все возможные входные данные. Причиной предупреждения является то, что некоторые входные данные имеют тип `enum`. Компилятор интерпретирует "все возможные входные данные" как все входные данные из базового типа, обычно это — `int`. Это выражение `switch` проверяет только значения, указанные в `enum`. Для устранения предупреждения можно добавить шаблон пустой переменной catch-all для последней ветви выражения. Это условие создает исключение, поскольку указывает на недопустимые входные данные:

```csharp
_  => throw new InvalidOperationException("Invalid internal state"),
```

Предыдущая ветвь switch должна быть последней в выражении `switch`, так как она соответствует всем входным данным. Поэкспериментируйте, изменяя порядок. Это вызывает ошибку компилятора *CS8510* — недопустимый код в шаблоне.  Естественная структура выражений switch позволяет компилятору создавать ошибки и предупреждения для потенциальных ошибок. Компилятор "безопасная сеть" упрощает создание чистого кода с меньшим количеством итераций, а также позволяет объединять ветви переключения с подстановочными знаками. Компилятор выдаст ошибки, если комбинация приведет к недопустимым ветвям, а также к предупреждениям при удалении необходимой ветви.

Первое изменение состоит в том, чтобы объединить все ветви, в которых командой является закрытие ворот; оно всегда разрешено. Добавьте следующий код в виде первой ветви в выражении switch.

```csharp
(false, _, _) => false,
```

После добавления предыдущей ветви вы получите четыре ошибки компилятора, по одной на каждую из ветвей в команде `false`. Эти ветви уже охвачены недавно добавленной ветвью. И вы можете безопасно удалить эти четыре строки. Вы пытались заменить эти условия новой ветвью переключения.

Теперь можно упростить четыре ветви для команды открытия ворот. Ворота можно открыть в обоих случаях, если уровень воды высок. (В первом случае они уже открыты.) Для первого случая, при котором уровень воды низкий, должно появиться исключение, а для другого — нет. Если шлюз уже находится в недопустимом состоянии, для появления такого же исключения необходимы безопасные условия. Эти ветви можно упростить таким образом:

```csharp
(true, _, WaterLevel.High) => true,
(true, false, WaterLevel.Low) => throw new InvalidOperationException("Cannot open high gate when the water is low"),
_ => throw new InvalidOperationException("Invalid internal state"),
```

Запустите тесты еще раз, они должны пройти успешно. Финальная версия метода `SetHighGate` выглядит вот так:

:::code language="csharp" source="snippets/pattern-objects/CanalLock.cs" ID="FinalImplementaton":::

## <a name="implement-patterns-yourself"></a>Самостоятельное внедрение шаблонов

Теперь, когда вы знакомы с методикой, заполните методы `SetLowGate` и `SetWaterLevel` самостоятельно.  Начните с добавления следующего кода для проверки недопустимых операций для этих методов:

:::code language="csharp" source="snippets/pattern-objects/Program.cs" ID="FinalTestCode":::

Запустите приложение еще раз. Видно, что новые тесты завершаются ошибкой, а шлюз переходит в недопустимое состояние. Попробуйте реализовать оставшиеся методы самостоятельно. Метод для нижних ворот должен быть идентичен методу для верхних ворот. Метод для изменения уровня воды имеет другие проверки, однако должен иметь ту же структуру. Вы можете использовать тот же процесс для метода, который задает уровень воды. Начните со всех четырех входных данных: состояние обоих ворот, текущий уровень воды и необходимый новый уровень воды. Выражение switch должно начинаться с:

```csharp
CanalLockWaterLevel = (newLevel, CanalLockWaterLevel, LowWaterGateOpen, HighWaterGateOpen) switch
{
    // elided
};
```

Вы получите 16 ветвей переключения, которые нужно заполнить данными. Проверьте и упростите их.

Получилось ли у вас что-то наподобие этого?

:::code language="csharp" source="snippets/pattern-objects/CanalLock.cs" ID="FinalExercise":::

Тесты должны успешно завершиться, а шлюз — работать безопасно.

## <a name="summary"></a>Итоги

Из этого руководства вы узнали, как использовать сопоставление шаблонов для проверки внутреннего состояния объекта, прежде чем изменять состояние. Вы можете проверять сочетания свойств. После создания таблиц для любого из этих переходов необходимо протестировать код, а затем упростить его для более удобного чтения и сопровождения. Эти изначальные рефакторинги могут рекомендовать другие рефакторинги, которые проверяют внутреннее состояние или управляют другими изменениями API. В этом учебнике были объединены классы и объекты с более ориентированным на данные подходом, в котором для реализации этих классов используются шаблоны.
