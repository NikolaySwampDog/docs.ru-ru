---
title: Безопасное обновление интерфейсов с помощью методов интерфейса по умолчанию в C#
description: В этом подробном учебнике рассматривается, как можно добавить новые возможности существующих определений интерфейса без нарушения работы классов и структур, которые реализуют этот интерфейс.
ms.date: 05/06/2019
ms.technlogy: csharp-advanced-concepts
ms.custom: mvc
ms.openlocfilehash: 43af25cee765ba18543b0c7bfe0069542a90e0e5
ms.sourcegitcommit: c7f0beaa2bd66ebca86362ca17d673f7e8256ca6
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/23/2021
ms.locfileid: "104878943"
---
# <a name="tutorial-update-interfaces-with-default-interface-methods-in-c-80"></a>Учебник. Обновление интерфейсов с помощью методов интерфейса по умолчанию в C# 8.0

Начиная с C# 8.0 в .NET Core 3.0 можно определить реализацию при объявлении члена интерфейса. Наиболее распространенным сценарием является безопасное добавление членов в интерфейс, который уже выпущен и используется многочисленными клиентами.

В этом руководстве вы узнаете, как:

> [!div class="checklist"]
>
> * Безопасно расширять интерфейсы, добавляя методы с реализациями.
> * Создавать параметризованные реализации, которые обеспечивают большую гибкость.
> * Позволить разработчику реализовать более конкретную реализацию в виде переопределения.

## <a name="prerequisites"></a>Предварительные требования

Вам нужно настроить свой компьютер для выполнения .NET Core, включая компилятор C# 8.0. Компилятор C# 8.0 доступен, начиная с [версии 16.3 Visual Studio 2019](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019), или [в пакете SDK .NET Core 3.0](https://dotnet.microsoft.com/download).

## <a name="scenario-overview"></a>Обзор сценария

Этот учебник начинается с первой версии библиотеки связи с клиентом. Начальное приложение можно получить в нашем репозитории [примеров на сайте GitHub](https://github.com/dotnet/samples/tree/main/csharp/tutorials/default-interface-members-versions/starter/customer-relationship). Компания, которая создала эту библиотеку, рассчитывала, что клиенты с существующими приложениями будут ее внедрять. Она определила минимальный интерфейс для реализации библиотеки пользователями. Вот определение интерфейса для клиента:

[!code-csharp[InitialCustomerInterface](~/samples/snippets/csharp/tutorials/default-interface-members-versions/starter/customer-relationship/ICustomer.cs?name=SnippetICustomerVersion1)]

Компания определила второй интерфейс, представляющий заказ:

[!code-csharp[InitialOrderInterface](~/samples/snippets/csharp/tutorials/default-interface-members-versions/starter/customer-relationship/IOrder.cs?name=SnippetIorderVersion1)]

На основе этих интерфейсов команда может собрать библиотеку для удобства работы клиентов своих пользователей. Их целью было более полно взаимодействовать с существующими клиентами и повысить уровень связи с новыми.

Пришло время перейти к библиотеке для следующего выпуска. Одна из востребованных возможностей — добавление скидки за лояльность для клиентов, размещающих большое количество заказов. Это новая скидка лояльности применяется каждый раз, когда клиент делает заказ. Специальная скидка является свойством каждого клиента. Каждая реализация `ICustomer` может задавать разные правила для скидки лояльности.

Наиболее удобный способ добавления этой функции — расширить `ICustomer` методом для применения любых скидок лояльности. Это предложение по разработке вызвало проблемы среди опытных разработчиков. "Интерфейсы являются неизменяемыми после выпуска! Это критическое изменение!" В C# 8.0 добавлены *реализации интерфейсов по умолчанию* для обновления интерфейсов. Авторы библиотеки могут добавлять новые элементы интерфейса и реализации по умолчанию для этих элементов.

Реализации интерфейса по умолчанию позволяют разработчикам обновить интерфейс, по-прежнему позволяя другим разработчикам переопределять эту реализацию. Пользователи библиотеки могут принимать реализацию по умолчанию в качестве некритического изменения. Если их бизнес-правила не совпадают, их можно переопределить.

## <a name="upgrade-with-default-interface-methods"></a>Обновление с методами интерфейса по умолчанию

Команда пришла к выводу относительно реализации по умолчанию: скидки за лояльность для клиентов.

Обновление должно давать возможность задать два свойства: количество заказов, необходимое, чтобы иметь право на скидку, а также процент скидки. В результате мы получаем идеальный сценарий для применения методов интерфейса по умолчанию. Можно добавить метод в интерфейс `ICustomer` и предоставить наиболее вероятную реализацию. Все существующие и любые новые реализации могут использовать реализацию по умолчанию или предоставить свои собственные.

Сначала добавьте в интерфейс новый метод, включая тело метода:

[!code-csharp[InitialOrderInterface](~/samples/snippets/csharp/tutorials/default-interface-members-versions/finished/customer-relationship/ICustomer.cs?name=SnippetLoyaltyDiscountVersionOne)]

Автор библиотеки написал первый тест для проверки реализации:

[!code-csharp[TestDefaultImplementation](~/samples/snippets/csharp/tutorials/default-interface-members-versions/finished/customer-relationship/Program.cs?name=SnippetTestDefaultImplementation)]

Обратите внимание на следующую часть теста:

[!code-csharp[TestDefaultImplementation](~/samples/snippets/csharp/tutorials/default-interface-members-versions/finished/customer-relationship/Program.cs?name=SnippetHighlightCast)]

Приведение `SampleCustomer` к `ICustomer` необходимо. Классу `SampleCustomer` не требуется предоставлять реализацию для `ComputeLoyaltyDiscount`; она предоставляется интерфейсом `ICustomer`. Тем не менее класс `SampleCustomer` не наследует члены от своих интерфейсов. Это правило не изменилось. Чтобы вызвать любой метод, который был объявлен и реализован в интерфейсе, переменная должна иметь тип интерфейса (`ICustomer` в этом примере).

## <a name="provide-parameterization"></a>Задайте параметризацию

Это хорошее начало. Однако реализация по умолчанию слишком строга. Другие пользователи этой системы могут выбрать различные пороговые значения для числа покупок, разную длительность членства или другой процент скидки. Удобство работы обновления можно повысить для нескольких клиентов сразу, предоставляя возможность установить эти параметры. Давайте добавим статический метод, который задает эти три параметра, контролируя реализацию по умолчанию:

[!code-csharp[VersionTwoImplementation](~/samples/snippets/csharp/tutorials/default-interface-members-versions/finished/customer-relationship/ICustomer.cs?name=SnippetLoyaltyDiscountVersionTwo)]

В этом небольшом фрагменте кода показано много новых языковых возможностей. Интерфейсы теперь могут содержать статические члены, включая поля и методы. Также включены разные модификаторы доступа. Дополнительные поля являются закрытыми, новый метод является открытым. Все эти модификаторы разрешены для членов интерфейса.

Приложениям, использующим общую формулу для вычисления скидок лояльности с разными параметрами, не нужно создавать собственные реализации; достаточно задать аргументы с помощью статического метода. Например, следующий код задает "повышение уровня клиента", в рамках которого награждается любой клиент более чем с месячным сроком членства:

[!code-csharp[SetLoyaltyThresholds](~/samples/snippets/csharp/tutorials/default-interface-members-versions/finished/customer-relationship/Program.cs?name=SnippetSetLoyaltyThresholds)]

## <a name="extend-the-default-implementation"></a>Расширение реализации по умолчанию

Код, который вы добавили на данный момент, предоставляет удобную реализацию для сценариев, где нужны что-то наподобие реализации по умолчанию или несвязанный набор правил. Чтобы дополнить код, давайте проведем рефакторинг, чтобы учесть сценарии, где пользователям нужно расширить реализацию по умолчанию.

Предположим, стартап хочет привлечь новых клиентов. Они предоставляют скидку в 50 % на первый заказ нового клиента. В противном случае существующие клиенты получают стандартные скидки. Автору библиотеки необходимо перенести реализацию по умолчанию в метод `protected static`, чтобы любой класс, реализующий этот интерфейс, мог повторно использовать код в своей реализации. По умолчанию реализация члена интерфейса также вызывает этот общий метод:

[!code-csharp[VersionTwoImplementation](~/samples/snippets/csharp/tutorials/default-interface-members-versions/finished/customer-relationship/ICustomer.cs?name=SnippetFinalVersion)]

В реализации класса, реализующего этот интерфейс, переопределение может вызывать статический вспомогательный метод и расширить эту логику для предоставления скидки новым клиентам:

[!code-csharp[VersionTwoImplementation](~/samples/snippets/csharp/tutorials/default-interface-members-versions/finished/customer-relationship/SampleCustomer.cs?name=SnippetOverrideAndExtend)]

Весь готовый код доступен в [репозитории примеров на GitHub](https://github.com/dotnet/samples/tree/main/csharp/tutorials/default-interface-members-versions/finished/customer-relationship). Начальное приложение можно получить в нашем репозитории [примеров на сайте GitHub](https://github.com/dotnet/samples/tree/main/csharp/tutorials/default-interface-members-versions/starter/customer-relationship).

Эти новые функции означают, что интерфейсы могут обновляться безопасно при наличии разумной реализации по умолчанию для этих новых элементов. Тщательно проектируйте интерфейсы для выражения единой функциональной идеи, которую могут реализовывать несколько классов. Это упрощает обновление этих определений интерфейса при обнаружении новых требований для этой же функциональности.
