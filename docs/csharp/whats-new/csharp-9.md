---
title: Новые возможности в C# 9.0. Руководство по языку C#
description: Обзор новых функций, доступных в C# 9.0.
ms.date: 09/04/2020
ms.openlocfilehash: 49170b123f612c06f22b70e44b29ad7be5f382ea
ms.sourcegitcommit: c7f0beaa2bd66ebca86362ca17d673f7e8256ca6
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/23/2021
ms.locfileid: "104876049"
---
# <a name="whats-new-in-c-90"></a><span data-ttu-id="f3d36-103">Новые возможности C# 9.0</span><span class="sxs-lookup"><span data-stu-id="f3d36-103">What's new in C# 9.0</span></span>

<span data-ttu-id="f3d36-104">В C# 9.0 добавлены следующие функции и улучшения языка C#.</span><span class="sxs-lookup"><span data-stu-id="f3d36-104">C# 9.0 adds the following features and enhancements to the C# language:</span></span>

- [<span data-ttu-id="f3d36-105">Записи</span><span class="sxs-lookup"><span data-stu-id="f3d36-105">Records</span></span>](#record-types)
- [<span data-ttu-id="f3d36-106">Методы задания только инициализации</span><span class="sxs-lookup"><span data-stu-id="f3d36-106">Init only setters</span></span>](#init-only-setters)
- [<span data-ttu-id="f3d36-107">Инструкции верхнего уровня</span><span class="sxs-lookup"><span data-stu-id="f3d36-107">Top-level statements</span></span>](#top-level-statements)
- [<span data-ttu-id="f3d36-108">Улучшения сопоставления шаблонов</span><span class="sxs-lookup"><span data-stu-id="f3d36-108">Pattern matching enhancements</span></span>](#pattern-matching-enhancements)
- <span data-ttu-id="f3d36-109">Целые числа собственного размера</span><span class="sxs-lookup"><span data-stu-id="f3d36-109">Native sized integers</span></span>
- <span data-ttu-id="f3d36-110">Указатели функций</span><span class="sxs-lookup"><span data-stu-id="f3d36-110">Function pointers</span></span>
- <span data-ttu-id="f3d36-111">Отмена создания флага localsinit</span><span class="sxs-lookup"><span data-stu-id="f3d36-111">Suppress emitting localsinit flag</span></span>
- <span data-ttu-id="f3d36-112">Новые выражения целевого типа</span><span class="sxs-lookup"><span data-stu-id="f3d36-112">Target-typed new expressions</span></span>
- <span data-ttu-id="f3d36-113">Статические анонимные функции</span><span class="sxs-lookup"><span data-stu-id="f3d36-113">static anonymous functions</span></span>
- <span data-ttu-id="f3d36-114">Условное выражение с целевым типом</span><span class="sxs-lookup"><span data-stu-id="f3d36-114">Target-typed conditional expressions</span></span>
- <span data-ttu-id="f3d36-115">Ковариантные возвращаемые типы</span><span class="sxs-lookup"><span data-stu-id="f3d36-115">Covariant return types</span></span>
- <span data-ttu-id="f3d36-116">Поддержка расширения `GetEnumerator` для циклов `foreach`</span><span class="sxs-lookup"><span data-stu-id="f3d36-116">Extension `GetEnumerator` support for `foreach` loops</span></span>
- <span data-ttu-id="f3d36-117">Параметры удаления лямбда-выражения</span><span class="sxs-lookup"><span data-stu-id="f3d36-117">Lambda discard parameters</span></span>
- <span data-ttu-id="f3d36-118">Атрибуты локальных функций</span><span class="sxs-lookup"><span data-stu-id="f3d36-118">Attributes on local functions</span></span>
- <span data-ttu-id="f3d36-119">Инициализаторы модулей</span><span class="sxs-lookup"><span data-stu-id="f3d36-119">Module initializers</span></span>
- <span data-ttu-id="f3d36-120">Новые функции для разделяемых методов</span><span class="sxs-lookup"><span data-stu-id="f3d36-120">New features for partial methods</span></span>

<span data-ttu-id="f3d36-121">C# 9.0 поддерживается в **.NET 5**.</span><span class="sxs-lookup"><span data-stu-id="f3d36-121">C# 9.0 is supported on **.NET 5**.</span></span> <span data-ttu-id="f3d36-122">Дополнительные сведения см. в статье [Управление версиями языка C#](../language-reference/configure-language-version.md).</span><span class="sxs-lookup"><span data-stu-id="f3d36-122">For more information, see [C# language versioning](../language-reference/configure-language-version.md).</span></span>

<span data-ttu-id="f3d36-123">Вы можете скачать последний пакет SDK для .NET на странице [скачиваемых файлов .NET](https://dotnet.microsoft.com/download).</span><span class="sxs-lookup"><span data-stu-id="f3d36-123">You can download the latest .NET SDK from the [.NET downloads page](https://dotnet.microsoft.com/download).</span></span>

## <a name="record-types"></a><span data-ttu-id="f3d36-124">Типы записей</span><span class="sxs-lookup"><span data-stu-id="f3d36-124">Record types</span></span>

<span data-ttu-id="f3d36-125">В C# 9.0 появились ***типы записей***, которые представляют собой ссылочный тип, предоставляющий синтезированные методы для обеспечения семантики значений для равенства.</span><span class="sxs-lookup"><span data-stu-id="f3d36-125">C# 9.0 introduces ***record types***, which are a reference type that provides synthesized methods to provide value semantics for equality.</span></span> <span data-ttu-id="f3d36-126">По умолчанию записи являются неизменяемыми.</span><span class="sxs-lookup"><span data-stu-id="f3d36-126">Records are immutable by default.</span></span>

<span data-ttu-id="f3d36-127">Типы записей упрощают создание неизменяемых ссылочных типов в .NET.</span><span class="sxs-lookup"><span data-stu-id="f3d36-127">Record types make it easy to create immutable reference types in .NET.</span></span> <span data-ttu-id="f3d36-128">Исторически типы .NET в основном классифицируются как ссылочные типы (включая классы и анонимные типы) и типы значений (включая структуры и кортежи).</span><span class="sxs-lookup"><span data-stu-id="f3d36-128">Historically, .NET types are largely classified as reference types (including classes and anonymous types) and value types (including structs and tuples).</span></span> <span data-ttu-id="f3d36-129">Хотя рекомендуется использовать неизменяемые типы значений, изменяемые типы значений часто не приводят к ошибке.</span><span class="sxs-lookup"><span data-stu-id="f3d36-129">While immutable value types are recommended, mutable value types don’t often introduce errors.</span></span> <span data-ttu-id="f3d36-130">Переменные типа значения содержат значения, поэтому, когда типы значений передаются в методы, изменения вносятся в копию исходных данных.</span><span class="sxs-lookup"><span data-stu-id="f3d36-130">Value type variables hold the values so changes are made to a copy of the original data when value types are passed to methods.</span></span>

<span data-ttu-id="f3d36-131">Также существует множество преимуществ для неизменяемых ссылочных типов.</span><span class="sxs-lookup"><span data-stu-id="f3d36-131">There are many advantages to immutable reference types as well.</span></span> <span data-ttu-id="f3d36-132">Эти преимущества более выражены в параллельных программах с общими данными.</span><span class="sxs-lookup"><span data-stu-id="f3d36-132">These advantages are more pronounced in concurrent programs with shared data.</span></span> <span data-ttu-id="f3d36-133">К сожалению, C# вынуждает писать некоторый дополнительный код для создания неизменяемых ссылочных типов.</span><span class="sxs-lookup"><span data-stu-id="f3d36-133">Unfortunately, C# forced you to write quite a bit of extra code to create immutable reference types.</span></span> <span data-ttu-id="f3d36-134">Записи предоставляют объявление типа для неизменяемого ссылочного типа, использующего семантику значения для равенства.</span><span class="sxs-lookup"><span data-stu-id="f3d36-134">Records provide a type declaration for an immutable reference type that uses value semantics for equality.</span></span> <span data-ttu-id="f3d36-135">Синтезированные методы для проверки на равенство и хэш-кодов считают две записи равными, если равны их свойства.</span><span class="sxs-lookup"><span data-stu-id="f3d36-135">The synthesized methods for equality and hash codes consider two records equal if their properties are all equal.</span></span> <span data-ttu-id="f3d36-136">Рассмотрим следующее определение.</span><span class="sxs-lookup"><span data-stu-id="f3d36-136">Consider this definition:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="RecordDefinition":::

<span data-ttu-id="f3d36-137">Определение записи создает тип `Person`, который содержит два свойства только для чтения: `FirstName` и `LastName`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-137">The record definition creates a `Person` type that contains two readonly properties: `FirstName` and `LastName`.</span></span> <span data-ttu-id="f3d36-138">`Person` является ссылочным типом.</span><span class="sxs-lookup"><span data-stu-id="f3d36-138">The `Person` type is a reference type.</span></span> <span data-ttu-id="f3d36-139">Если взглянуть на IL, это будет класс.</span><span class="sxs-lookup"><span data-stu-id="f3d36-139">If you looked at the IL, it’s a class.</span></span> <span data-ttu-id="f3d36-140">Он является неизменяемым в том смысле, что ни одно из свойств нельзя изменить после создания.</span><span class="sxs-lookup"><span data-stu-id="f3d36-140">It’s immutable in that none of the properties can be modified once it's been created.</span></span> <span data-ttu-id="f3d36-141">При определении типа записи компилятор синтезирует несколько других методов.</span><span class="sxs-lookup"><span data-stu-id="f3d36-141">When you define a record type, the compiler synthesizes several other methods for you:</span></span>

- <span data-ttu-id="f3d36-142">Методы для определения равенства на основе значений</span><span class="sxs-lookup"><span data-stu-id="f3d36-142">Methods for value-based equality comparisons</span></span>
- <span data-ttu-id="f3d36-143">Переопределение для <xref:System.Object.GetHashCode></span><span class="sxs-lookup"><span data-stu-id="f3d36-143">Override for <xref:System.Object.GetHashCode></span></span>
- <span data-ttu-id="f3d36-144">Копирование и клонирование членов</span><span class="sxs-lookup"><span data-stu-id="f3d36-144">Copy and Clone members</span></span>
- <span data-ttu-id="f3d36-145">`PrintMembers` и <xref:System.Object.ToString></span><span class="sxs-lookup"><span data-stu-id="f3d36-145">`PrintMembers` and <xref:System.Object.ToString></span></span>

<span data-ttu-id="f3d36-146">Записи поддерживают наследование.</span><span class="sxs-lookup"><span data-stu-id="f3d36-146">Records support inheritance.</span></span> <span data-ttu-id="f3d36-147">Новую запись, производную от `Person`, можно объявить следующим образом.</span><span class="sxs-lookup"><span data-stu-id="f3d36-147">You can declare a new record derived from `Person` as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="InheritedRecord":::

<span data-ttu-id="f3d36-148">Можно также запечатывать записи, чтобы предотвратить дальнейшее наследование.</span><span class="sxs-lookup"><span data-stu-id="f3d36-148">You can also seal records to prevent further derivation:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="SealedRecord":::

<span data-ttu-id="f3d36-149">Компилятор синтезирует разные версии приведенных выше методов.</span><span class="sxs-lookup"><span data-stu-id="f3d36-149">The compiler synthesizes different versions of the methods above.</span></span> <span data-ttu-id="f3d36-150">Сигнатуры методов зависят от того, является ли тип записи запечатанным и является ли прямой базовый класс объектом.</span><span class="sxs-lookup"><span data-stu-id="f3d36-150">The method signatures depend on if the record type is sealed and if the direct base class is object.</span></span> <span data-ttu-id="f3d36-151">Записи должны иметь следующие возможности.</span><span class="sxs-lookup"><span data-stu-id="f3d36-151">Records should have the following capabilities:</span></span>

- <span data-ttu-id="f3d36-152">Проверка равенства основана на значении и включает проверку соответствия типов.</span><span class="sxs-lookup"><span data-stu-id="f3d36-152">Equality is value-based, and includes a check that the types match.</span></span> <span data-ttu-id="f3d36-153">Например, `Student` не может быть равно `Person`, даже если две записи имеют одно и то же имя.</span><span class="sxs-lookup"><span data-stu-id="f3d36-153">For example, a `Student` can't be equal to a `Person`, even if the two records share the same name.</span></span>
- <span data-ttu-id="f3d36-154">Записи имеют единообразное строковое представление, создаваемое автоматически.</span><span class="sxs-lookup"><span data-stu-id="f3d36-154">Records have a consistent string representation generated for you.</span></span>
- <span data-ttu-id="f3d36-155">Записи поддерживают создание копий.</span><span class="sxs-lookup"><span data-stu-id="f3d36-155">Records support copy construction.</span></span> <span data-ttu-id="f3d36-156">Правильная конструкция копирования должна включать иерархии наследования и свойства, добавленные разработчиками.</span><span class="sxs-lookup"><span data-stu-id="f3d36-156">Correct copy construction must include inheritance hierarchies, and properties added by developers.</span></span>
- <span data-ttu-id="f3d36-157">Записи можно копировать с изменениями.</span><span class="sxs-lookup"><span data-stu-id="f3d36-157">Records can be copied with modification.</span></span> <span data-ttu-id="f3d36-158">Операции копирования и изменения поддерживают неразрушающие мутации.</span><span class="sxs-lookup"><span data-stu-id="f3d36-158">These copy and modify operations supports non-destructive mutation.</span></span>

<span data-ttu-id="f3d36-159">Помимо знакомых перегрузок `Equals`, `operator ==` и `operator !=`, компилятор синтезировал новое свойство `EqualityContract`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-159">In addition to the familiar `Equals` overloads, `operator ==`, and `operator !=`, the compiler synthesizes a new `EqualityContract` property.</span></span> <span data-ttu-id="f3d36-160">Это свойство возвращает объект `Type`, соответствующий типу записи.</span><span class="sxs-lookup"><span data-stu-id="f3d36-160">The property returns a `Type` object that matches the type of the record.</span></span> <span data-ttu-id="f3d36-161">Если базовый тип равен `object`, свойство будет являться `virtual`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-161">If the base type is `object`, the property is `virtual`.</span></span> <span data-ttu-id="f3d36-162">Если базовый тип является другим типом записи, свойство будет являться `override`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-162">If the base type is another record type, the property is an `override`.</span></span> <span data-ttu-id="f3d36-163">Если тип записи равен `sealed`, свойство будет являться `sealed`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-163">If the record type is `sealed`, the property is `sealed`.</span></span> <span data-ttu-id="f3d36-164">Синтезированный метод `GetHashCode` использует `GetHashCode` из всех свойств и полей, объявленных в базовом типе и типе записи.</span><span class="sxs-lookup"><span data-stu-id="f3d36-164">The synthesized `GetHashCode` uses the `GetHashCode` from all properties and fields declared in the base type and the record type.</span></span> <span data-ttu-id="f3d36-165">Эти синтезированные методы применяют равенство на основе значений во всей иерархии наследования.</span><span class="sxs-lookup"><span data-stu-id="f3d36-165">These synthesized methods enforce value-based equality throughout an inheritance hierarchy.</span></span> <span data-ttu-id="f3d36-166">Это означает, что `Student` никогда не будет считаться равным `Person` с тем же именем.</span><span class="sxs-lookup"><span data-stu-id="f3d36-166">That means a `Student` will never be considered equal to a `Person` with the same name.</span></span> <span data-ttu-id="f3d36-167">Типы двух записей должны совпадать, а все свойства, общие для типов записей, равны.</span><span class="sxs-lookup"><span data-stu-id="f3d36-167">The types of the two records must match as well as all properties shared among the record types being equal.</span></span>

<span data-ttu-id="f3d36-168">Записи также имеют синтезированный конструктор и метод "clone" для создания копий.</span><span class="sxs-lookup"><span data-stu-id="f3d36-168">Records also have a synthesized constructor and a "clone" method for creating copies.</span></span> <span data-ttu-id="f3d36-169">Синтезированный конструктор имеет один параметр типа записи.</span><span class="sxs-lookup"><span data-stu-id="f3d36-169">The synthesized constructor has a single parameter of the record type.</span></span> <span data-ttu-id="f3d36-170">Он создает новую запись с теми же значениями всех свойств записи.</span><span class="sxs-lookup"><span data-stu-id="f3d36-170">It produces a new record with the same values for all properties of the record.</span></span> <span data-ttu-id="f3d36-171">Этот конструктор является закрытым, если запись запечатана, в противном случае он является защищенным.</span><span class="sxs-lookup"><span data-stu-id="f3d36-171">This constructor is private if the record is sealed, otherwise it's protected.</span></span> <span data-ttu-id="f3d36-172">Синтезированный метод "clone" поддерживает конструкцию копирования для иерархий записей.</span><span class="sxs-lookup"><span data-stu-id="f3d36-172">The synthesized "clone" method supports copy construction for record hierarchies.</span></span> <span data-ttu-id="f3d36-173">Термин "clone" взят в кавычки, поскольку фактическое имя создается компилятором.</span><span class="sxs-lookup"><span data-stu-id="f3d36-173">The term "clone" is in quotes because the actual name is compiler generated.</span></span> <span data-ttu-id="f3d36-174">Нельзя создать метод с именем `Clone` в типе записи.</span><span class="sxs-lookup"><span data-stu-id="f3d36-174">You can't create a method named `Clone` in a record type.</span></span> <span data-ttu-id="f3d36-175">Синтезированный метод "clone" возвращает тип копируемой записи с помощью виртуальной диспетчеризации.</span><span class="sxs-lookup"><span data-stu-id="f3d36-175">The synthesized "clone" method returns the type of record being copied using virtual dispatch.</span></span> <span data-ttu-id="f3d36-176">Компилятор добавляет различные модификаторы для метода "clone" в зависимости от модификаторов доступа в `record`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-176">The compiler adds different modifiers for the "clone" method depending on the access modifiers on the `record`:</span></span>

- <span data-ttu-id="f3d36-177">Если тип записи является `abstract`, метод "clone" также является `abstract`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-177">If the record type is `abstract`, the "clone" method is also `abstract`.</span></span> <span data-ttu-id="f3d36-178">Если базовый тип не является `object`, метод также является `override`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-178">If the base type isn't `object`, the method is also `override`.</span></span>
- <span data-ttu-id="f3d36-179">Для типов записей, которые не являются `abstract`, если базовый тип является `object`</span><span class="sxs-lookup"><span data-stu-id="f3d36-179">For record types that aren't `abstract` when the base type is `object`:</span></span>
  - <span data-ttu-id="f3d36-180">Если запись является `sealed`, в метод "clone" не добавляются дополнительные модификаторы (то есть он не `virtual`).</span><span class="sxs-lookup"><span data-stu-id="f3d36-180">If the record is `sealed`, no additional modifiers are added to the "clone" method (meaning it is not `virtual`).</span></span>
  - <span data-ttu-id="f3d36-181">Если запись не является `sealed`, метод "clone" является `virtual`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-181">If the record isn't `sealed`, the "clone" method is `virtual`.</span></span>
- <span data-ttu-id="f3d36-182">Для типов записей, которые не являются `abstract`, если базовый тип не является `object`</span><span class="sxs-lookup"><span data-stu-id="f3d36-182">For record types that aren't `abstract` when the base type is not `object`:</span></span>
  - <span data-ttu-id="f3d36-183">Если запись является `sealed`, метод "clone" также является `sealed`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-183">If the record is `sealed`, the "clone" method is also `sealed`.</span></span>
  - <span data-ttu-id="f3d36-184">Если запись не является `sealed`, метод "clone" является `override`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-184">If the record isn't `sealed`, the "clone" method is `override`.</span></span>

<span data-ttu-id="f3d36-185">В результате всех этих правил сравнение на равенство реализуется единообразно в любой иерархии типов записей.</span><span class="sxs-lookup"><span data-stu-id="f3d36-185">The result of all these rules is the equality is implemented consistently across any hierarchy of record types.</span></span> <span data-ttu-id="f3d36-186">Две записи равны друг другу, если их свойства равны и их типы совпадают, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="f3d36-186">Two records are equal to each other if their properties are equal and their types are the same, as shown in the following example:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="RecordsEquality":::

<span data-ttu-id="f3d36-187">Компилятор синтезировал два метода, поддерживающих вывод на печать: переопределение <xref:System.Object.ToString> и `PrintMembers`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-187">The compiler synthesizes two methods that support printed output: a <xref:System.Object.ToString> override, and `PrintMembers`.</span></span> <span data-ttu-id="f3d36-188">`PrintMembers` принимает в качестве аргумента <xref:System.Text.StringBuilder?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f3d36-188">The `PrintMembers` takes a <xref:System.Text.StringBuilder?displayProperty=nameWithType> as its argument.</span></span> <span data-ttu-id="f3d36-189">Он добавляет разделенный запятыми список имен свойств и значений всех свойств в типе записи.</span><span class="sxs-lookup"><span data-stu-id="f3d36-189">It appends a comma-separated list of property names and values for all properties in the record type.</span></span> <span data-ttu-id="f3d36-190">`PrintMembers` вызывает базовую реализацию для всех записей, полученных из других записей.</span><span class="sxs-lookup"><span data-stu-id="f3d36-190">`PrintMembers` calls the base implementation for any records derived from other records.</span></span> <span data-ttu-id="f3d36-191">Переопределение <xref:System.Object.ToString> возвращает строку, полученную `PrintMembers`, окруженную символами `{` и `}`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-191">The <xref:System.Object.ToString> override returns the string produced by `PrintMembers`, surrounded by `{` and `}`.</span></span> <span data-ttu-id="f3d36-192">Например, метод <xref:System.Object.ToString> для `Student` возвращает `string`, как показано в следующем коде.</span><span class="sxs-lookup"><span data-stu-id="f3d36-192">For example, the <xref:System.Object.ToString> method for `Student` returns a `string` like the following code:</span></span>

```csharp
"Student { LastName = Wagner, FirstName = Bill, Level = 11 }"
```

<span data-ttu-id="f3d36-193">В приведенных ранее примерах для объявления свойств использовался традиционный синтаксис.</span><span class="sxs-lookup"><span data-stu-id="f3d36-193">The examples shown so far use traditional syntax to declare properties.</span></span> <span data-ttu-id="f3d36-194">Существует более краткая форма, называемая ***позиционной записью***.</span><span class="sxs-lookup"><span data-stu-id="f3d36-194">There's a more concise form called ***positional records***.</span></span>  <span data-ttu-id="f3d36-195">Ниже приведены три типа записей, определенные ранее в виде позиционной записи.</span><span class="sxs-lookup"><span data-stu-id="f3d36-195">Here are the three record types defined earlier as positional records:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="PositionalRecords":::

<span data-ttu-id="f3d36-196">Эти объявления обеспечивают ту же функциональность, что и в предыдущем варианте (с несколькими дополнительными функциями, описанными в следующем разделе).</span><span class="sxs-lookup"><span data-stu-id="f3d36-196">These declarations create the same functionality as the earlier version (with a couple extra features covered in the following section).</span></span> <span data-ttu-id="f3d36-197">Эти объявления заканчиваются точкой с запятой вместо квадратных скобок, так как эти записи не добавляют дополнительные методы.</span><span class="sxs-lookup"><span data-stu-id="f3d36-197">These declarations end with a semicolon instead of brackets because these records don't add additional methods.</span></span> <span data-ttu-id="f3d36-198">Можно добавить тело и включить в него дополнительные методы.</span><span class="sxs-lookup"><span data-stu-id="f3d36-198">You can add a body, and include any additional methods as well:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="RecordsWithMethods":::

<span data-ttu-id="f3d36-199">Для позиционных записей компилятор создает метод `Deconstruct`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-199">The compiler produces a `Deconstruct` method for positional records.</span></span> <span data-ttu-id="f3d36-200">Метод `Deconstruct` имеет параметры, соответствующие именам всех общедоступных свойств в типе записи.</span><span class="sxs-lookup"><span data-stu-id="f3d36-200">The `Deconstruct` method has parameters that match the names of all public properties in the record type.</span></span> <span data-ttu-id="f3d36-201">Метод `Deconstruct` можно использовать для деконструирования записи в свойства ее компонентов.</span><span class="sxs-lookup"><span data-stu-id="f3d36-201">The `Deconstruct` method can be used to deconstruct the record into its component properties:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="DeconstructRecord":::

<span data-ttu-id="f3d36-202">Наконец, записи поддерживают [выражения `with`](../language-reference/operators/with-expression.md).</span><span class="sxs-lookup"><span data-stu-id="f3d36-202">Finally, records support [`with` expressions](../language-reference/operators/with-expression.md).</span></span> <span data-ttu-id="f3d36-203">***Выражение `with`** _ указывает компилятору создать копию записи, но _с* указанными измененными свойствами.</span><span class="sxs-lookup"><span data-stu-id="f3d36-203">A ***`with` expression** _ instructs the compiler to create a copy of a record, but _with* specified properties modified:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="Wither":::

<span data-ttu-id="f3d36-204">В приведенной выше строке создается новая запись `Person`, в которой свойство `LastName` копируется из `person`, а свойство `FirstName` равно `"Paul"`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-204">The previous line creates a new `Person` record where the `LastName` property is a copy of `person`, and the `FirstName` is `"Paul"`.</span></span> <span data-ttu-id="f3d36-205">В выражениях `with` можно задать любое количество свойств.</span><span class="sxs-lookup"><span data-stu-id="f3d36-205">You can set any number of properties in a `with` expression.</span></span> <span data-ttu-id="f3d36-206">Можно также использовать выражения `with` для создания точной копии.</span><span class="sxs-lookup"><span data-stu-id="f3d36-206">You can also use `with` expressions to create an exact copy.</span></span> <span data-ttu-id="f3d36-207">Укажите пустой набор свойств для изменения:</span><span class="sxs-lookup"><span data-stu-id="f3d36-207">You specify the empty set for the properties to modify:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="WithCopy":::

<span data-ttu-id="f3d36-208">Вы можете написать любые синтезируемые члены, за исключением метода "clone".</span><span class="sxs-lookup"><span data-stu-id="f3d36-208">Any of the synthesized members except the "clone" method may be written by you.</span></span> <span data-ttu-id="f3d36-209">Если тип записи имеет метод, совпадающий с сигнатурой какого-либо синтезируемого метода, компилятор будет его синтезировать.</span><span class="sxs-lookup"><span data-stu-id="f3d36-209">If a record type has a method that matches the signature of any synthesized method, the compiler doesn't synthesize that method.</span></span> <span data-ttu-id="f3d36-210">Например, в предыдущем примере записи `Dog` содержится написанный вручную метод <xref:System.String.ToString>.</span><span class="sxs-lookup"><span data-stu-id="f3d36-210">The earlier `Dog` record example contains a hand coded <xref:System.String.ToString> method as an example.</span></span>

<span data-ttu-id="f3d36-211">Дополнительные сведения о типах записей см. в этом учебнике по [исследованию записей](../whats-new/tutorials/records.md).</span><span class="sxs-lookup"><span data-stu-id="f3d36-211">Learn more about record types in this [exploration of records](../whats-new/tutorials/records.md) tutorial.</span></span>

## <a name="init-only-setters"></a><span data-ttu-id="f3d36-212">Методы задания только инициализации</span><span class="sxs-lookup"><span data-stu-id="f3d36-212">Init only setters</span></span>

<span data-ttu-id="f3d36-213">***Методы задания только для инициализации*** обеспечивают единообразный синтаксис для инициализации членов объекта.</span><span class="sxs-lookup"><span data-stu-id="f3d36-213">***Init only setters*** provide consistent syntax to initialize members of an object.</span></span> <span data-ttu-id="f3d36-214">Инициализаторы свойств позволяют ясно понять, какое значение задает то или иное свойство.</span><span class="sxs-lookup"><span data-stu-id="f3d36-214">Property initializers make it clear which value is setting which property.</span></span> <span data-ttu-id="f3d36-215">Недостаток заключается в том, что эти свойства должны быть устанавливаемыми.</span><span class="sxs-lookup"><span data-stu-id="f3d36-215">The downside is that those properties must be settable.</span></span> <span data-ttu-id="f3d36-216">Начиная с C# 9.0, для свойств и индексаторов можно создавать методы доступа `init`, а не методы доступа `set`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-216">Starting with C# 9.0, you can create `init` accessors instead of `set` accessors for properties and indexers.</span></span> <span data-ttu-id="f3d36-217">Вызывающие объекты могут использовать синтаксис инициализатора свойств для установки этих значений в выражениях создания, но после завершения конструирования эти свойства будут доступны только для чтения.</span><span class="sxs-lookup"><span data-stu-id="f3d36-217">Callers can use property initializer syntax to set these values in creation expressions, but those properties are readonly once construction has completed.</span></span> <span data-ttu-id="f3d36-218">Методы задания только для инициализации предоставляют окно для изменения состояния.</span><span class="sxs-lookup"><span data-stu-id="f3d36-218">Init only setters provide a window to change state.</span></span> <span data-ttu-id="f3d36-219">Это окно закрывается, когда завершается этап конструирования.</span><span class="sxs-lookup"><span data-stu-id="f3d36-219">That window closes when the construction phase ends.</span></span> <span data-ttu-id="f3d36-220">Этап конструирования фактически завершается после всех инициализаций, включая инициализаторы свойств и выражения with.</span><span class="sxs-lookup"><span data-stu-id="f3d36-220">The construction phase effectively ends after all initialization, including property initializers and with-expressions have completed.</span></span>

<span data-ttu-id="f3d36-221">Можно объявить методы задания только для инициализации (`init`) в любом написанном вами типе.</span><span class="sxs-lookup"><span data-stu-id="f3d36-221">You can declare `init` only setters in any type you write.</span></span> <span data-ttu-id="f3d36-222">Ниже приведен пример определения структуры наблюдения за погодой.</span><span class="sxs-lookup"><span data-stu-id="f3d36-222">For example, the following struct defines a weather observation structure:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="DeclareWeatherObservation":::

<span data-ttu-id="f3d36-223">Вызывающие объекты могут использовать синтаксис инициализатора свойств для установки значений, сохраняя при этом неизменность.</span><span class="sxs-lookup"><span data-stu-id="f3d36-223">Callers can use property initializer syntax to set the values, while still preserving the immutability:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="UseWeatherObservation":::

<span data-ttu-id="f3d36-224">Однако изменение наблюдения после инициализации является ошибкой из-за присвоения свойству только для инициализации значения вне инициализации.</span><span class="sxs-lookup"><span data-stu-id="f3d36-224">But, changing an observation after initialization is an error by assigning to an init-only property outside of initialization:</span></span>

```csharp
// Error! CS8852.
now.TemperatureInCelsius = 18;
```

<span data-ttu-id="f3d36-225">Методы задания только для инициализации могут быть полезны для задания свойств базового класса из производных классов.</span><span class="sxs-lookup"><span data-stu-id="f3d36-225">Init only setters can be useful to set base class properties from derived classes.</span></span> <span data-ttu-id="f3d36-226">Они также могут устанавливать производные свойства через вспомогательные методы в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="f3d36-226">They can also set derived properties through helpers in a base class.</span></span> <span data-ttu-id="f3d36-227">В позиционных записях свойства объявляются с помощью методов задания только для инициализации.</span><span class="sxs-lookup"><span data-stu-id="f3d36-227">Positional records declare properties using init only setters.</span></span> <span data-ttu-id="f3d36-228">Эти методы задания используются в выражениях with.</span><span class="sxs-lookup"><span data-stu-id="f3d36-228">Those setters are used in with-expressions.</span></span> <span data-ttu-id="f3d36-229">Методы задания только для инициализации можно объявить для любых `class` или `struct`, которые вы определяете.</span><span class="sxs-lookup"><span data-stu-id="f3d36-229">You can declare init only setters for any `class` or `struct` you define.</span></span>

## <a name="top-level-statements"></a><span data-ttu-id="f3d36-230">Инструкции верхнего уровня</span><span class="sxs-lookup"><span data-stu-id="f3d36-230">Top-level statements</span></span>

<span data-ttu-id="f3d36-231">***Инструкции верхнего уровня*** избавляют от ненужных формальностей во многих приложениях.</span><span class="sxs-lookup"><span data-stu-id="f3d36-231">***Top-level statements*** remove unnecessary ceremony from many applications.</span></span> <span data-ttu-id="f3d36-232">Рассмотрим каноническую программу Hello World!.</span><span class="sxs-lookup"><span data-stu-id="f3d36-232">Consider the canonical "Hello World!"</span></span> <span data-ttu-id="f3d36-233">.</span><span class="sxs-lookup"><span data-stu-id="f3d36-233">program:</span></span>

```csharp
using System;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

<span data-ttu-id="f3d36-234">Только одна строка кода что-то делает.</span><span class="sxs-lookup"><span data-stu-id="f3d36-234">There’s only one line of code that does anything.</span></span> <span data-ttu-id="f3d36-235">С помощью инструкций верхнего уровня можно заменить весь этот шаблон инструкцией `using` и одной строкой, которая делает всю работу.</span><span class="sxs-lookup"><span data-stu-id="f3d36-235">With top-level statements, you can replace all that boilerplate with the `using` statement and the single line that does the work:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/Program.cs" ID="TopLevelStatements":::

<span data-ttu-id="f3d36-236">Если требуется однострочная программа, можно удалить директиву `using` и использовать полное имя типа.</span><span class="sxs-lookup"><span data-stu-id="f3d36-236">If you wanted a one-line program, you could remove the `using` directive and use the fully qualified type name:</span></span>

```csharp
System.Console.WriteLine("Hello World!");
```

<span data-ttu-id="f3d36-237">Только один файл в приложении может использовать инструкции верхнего уровня.</span><span class="sxs-lookup"><span data-stu-id="f3d36-237">Only one file in your application may use top-level statements.</span></span> <span data-ttu-id="f3d36-238">Если компилятор обнаруживает операторы верхнего уровня в нескольких исходных файлах, это приводит к ошибке.</span><span class="sxs-lookup"><span data-stu-id="f3d36-238">If the compiler finds top-level statements in multiple source files, it’s an error.</span></span> <span data-ttu-id="f3d36-239">Ошибка также возникает, если объединить операторы верхнего уровня с объявленным методом точки входа программы (как правило, это метод `Main`).</span><span class="sxs-lookup"><span data-stu-id="f3d36-239">It’s also an error if you combine top-level statements with a declared program entry point method, typically a `Main` method.</span></span> <span data-ttu-id="f3d36-240">В определенном смысле можно сказать, что один файл содержит инструкции, которые обычно находятся в методе `Main` класса `Program`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-240">In a sense, you can think that one file contains the statements that would normally be in the `Main` method of a `Program` class.</span></span>  

<span data-ttu-id="f3d36-241">Одним из наиболее распространенных применений этой функции является создание обучающих материалов.</span><span class="sxs-lookup"><span data-stu-id="f3d36-241">One of the most common uses for this feature is creating teaching materials.</span></span> <span data-ttu-id="f3d36-242">Начинающие разработчики C# могут написать каноническую программу Hello World!</span><span class="sxs-lookup"><span data-stu-id="f3d36-242">Beginner C# developers can write the canonical “Hello World!”</span></span> <span data-ttu-id="f3d36-243">в одной-двух строках кода.</span><span class="sxs-lookup"><span data-stu-id="f3d36-243">in one or two lines of code.</span></span> <span data-ttu-id="f3d36-244">Никакие дополнительные формальности не требуются.</span><span class="sxs-lookup"><span data-stu-id="f3d36-244">None of the extra ceremony is needed.</span></span> <span data-ttu-id="f3d36-245">Но и опытные разработчики также найдут много применений для этой функции.</span><span class="sxs-lookup"><span data-stu-id="f3d36-245">However, seasoned developers will find many uses for this feature as well.</span></span> <span data-ttu-id="f3d36-246">Инструкции верхнего уровня позволяют экспериментировать в стиле написания сценариев, аналогично записным книжкам Jupyter.</span><span class="sxs-lookup"><span data-stu-id="f3d36-246">Top-level statements enable a script-like experience for experimentation similar to what Jupyter notebooks provide.</span></span> <span data-ttu-id="f3d36-247">Инструкции верхнего уровня отлично подходят для небольших консольных и служебных программ.</span><span class="sxs-lookup"><span data-stu-id="f3d36-247">Top-level statements are great for small console programs and utilities.</span></span> <span data-ttu-id="f3d36-248">Функции Azure являются идеальным примером использования операторов верхнего уровня.</span><span class="sxs-lookup"><span data-stu-id="f3d36-248">Azure Functions are an ideal use case for top-level statements.</span></span>

<span data-ttu-id="f3d36-249">Что важнее всего, инструкции верхнего уровня не ограничивают область применения или сложность приложения.</span><span class="sxs-lookup"><span data-stu-id="f3d36-249">Most importantly, top-level statements don't limit your application’s scope or complexity.</span></span> <span data-ttu-id="f3d36-250">Эти инструкции могут обращаться к любому классу .NET и использовать его.</span><span class="sxs-lookup"><span data-stu-id="f3d36-250">Those statements can access or use any .NET class.</span></span> <span data-ttu-id="f3d36-251">Они также не ограничивают использование аргументов командной строки и возвращаемых значений.</span><span class="sxs-lookup"><span data-stu-id="f3d36-251">They also don’t limit your use of command-line arguments or return values.</span></span> <span data-ttu-id="f3d36-252">Инструкции верхнего уровня могут обращаться к массиву строк с именем args.</span><span class="sxs-lookup"><span data-stu-id="f3d36-252">Top-level statements can access an array of strings named args.</span></span> <span data-ttu-id="f3d36-253">Если инструкции верхнего уровня возвращают целочисленное значение, это значение преобразуется в целочисленный код возврата из синтезированного метода `Main`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-253">If the top-level statements return an integer value, that value becomes the integer return code from a synthesized `Main` method.</span></span> <span data-ttu-id="f3d36-254">Инструкции верхнего уровня могут содержать асинхронные выражения.</span><span class="sxs-lookup"><span data-stu-id="f3d36-254">The top-level statements may contain async expressions.</span></span> <span data-ttu-id="f3d36-255">В этом случае синтезированная точка входа возвращает `Task` или `Task<int>`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-255">In that case, the synthesized entry point returns a `Task`, or `Task<int>`.</span></span>

## <a name="pattern-matching-enhancements"></a><span data-ttu-id="f3d36-256">Улучшения сопоставления шаблонов</span><span class="sxs-lookup"><span data-stu-id="f3d36-256">Pattern matching enhancements</span></span>

<span data-ttu-id="f3d36-257">C# 9 включает новые улучшения сопоставления шаблонов.</span><span class="sxs-lookup"><span data-stu-id="f3d36-257">C# 9 includes new pattern matching improvements:</span></span>

- <span data-ttu-id="f3d36-258">***Шаблоны типов*** проверяют соответствие переменной определенному типу.</span><span class="sxs-lookup"><span data-stu-id="f3d36-258">***Type patterns*** match a variable is a type</span></span>
- <span data-ttu-id="f3d36-259">***Шаблоны в круглых скобках*** усиливают или подчеркивают приоритет сочетаний шаблонов.</span><span class="sxs-lookup"><span data-stu-id="f3d36-259">***Parenthesized patterns*** enforce or emphasize the precedence of pattern combinations</span></span>
- <span data-ttu-id="f3d36-260">***В шаблонах конъюнкций `and`*** требуется соответствие обоих шаблонов.</span><span class="sxs-lookup"><span data-stu-id="f3d36-260">***Conjunctive `and` patterns*** require both patterns to match</span></span>
- <span data-ttu-id="f3d36-261">***В шаблонах дизъюнкций `or`*** требуется соответствие хотя бы одного из шаблонов.</span><span class="sxs-lookup"><span data-stu-id="f3d36-261">***Disjunctive `or` patterns*** require either pattern to match</span></span>
- <span data-ttu-id="f3d36-262">***В шаблонах с отрицанием `not`*** требуется несоответствие шаблона.</span><span class="sxs-lookup"><span data-stu-id="f3d36-262">***Negated `not` patterns*** require that a pattern doesn’t match</span></span>
- <span data-ttu-id="f3d36-263">***В шаблонах сравнения*** требуется, чтобы входные данные были меньше, больше, меньше или равны, больше или равны данной константе.</span><span class="sxs-lookup"><span data-stu-id="f3d36-263">***Relational patterns*** require the input be less than, greater than, less than or equal, or greater than or equal to a given constant.</span></span>

<span data-ttu-id="f3d36-264">Эти шаблоны обогащают синтаксис шаблонов.</span><span class="sxs-lookup"><span data-stu-id="f3d36-264">These patterns enrich the syntax for patterns.</span></span> <span data-ttu-id="f3d36-265">Рассмотрим следующие примеры.</span><span class="sxs-lookup"><span data-stu-id="f3d36-265">Consider these examples:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterPattern":::

<span data-ttu-id="f3d36-266">Либо с помощью дополнительных скобок можно ясно указать, что `and` имеет более высокий приоритет, чем `or`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-266">Alternatively, with optional parentheses to make it clear that `and` has higher precedence than `or`:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterOrSeparatorPattern":::

<span data-ttu-id="f3d36-267">Одним из наиболее распространенных применений нового синтаксиса является проверка значения на null.</span><span class="sxs-lookup"><span data-stu-id="f3d36-267">One of the most common uses is a new syntax for a null check:</span></span>

```csharp
if (e is not null)
{
    // ...
}
```

<span data-ttu-id="f3d36-268">Любой из этих шаблонов можно использовать в любом контексте, где разрешены шаблоны: выражения с шаблоном `is`, выражения `switch`, вложенные шаблоны и шаблоны метки `case` оператора `switch`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-268">Any of these patterns can be used in any context where patterns are allowed: `is` pattern expressions, `switch` expressions, nested patterns, and the pattern of a `switch` statement’s `case` label.</span></span>

## <a name="performance-and-interop"></a><span data-ttu-id="f3d36-269">Производительность и взаимодействие</span><span class="sxs-lookup"><span data-stu-id="f3d36-269">Performance and interop</span></span>

<span data-ttu-id="f3d36-270">Три новых функции улучшают поддержку собственного взаимодействия и низкоуровневых библиотек, требующих высокой производительности: целые числа собственного размера, указатели функций и пропуск флага `localsinit`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-270">Three new features improve support for native interop and low-level libraries that require high performance: native sized integers, function pointers, and omitting the `localsinit` flag.</span></span>

<span data-ttu-id="f3d36-271">Целые числа собственного размера `nint` и `nuint` являются целочисленными типами.</span><span class="sxs-lookup"><span data-stu-id="f3d36-271">Native sized integers, `nint` and `nuint`, are integer types.</span></span> <span data-ttu-id="f3d36-272">Они выражаются базовыми типами <xref:System.IntPtr?displayProperty=nameWithType> и <xref:System.UIntPtr?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f3d36-272">They're expressed by the underlying types <xref:System.IntPtr?displayProperty=nameWithType> and <xref:System.UIntPtr?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f3d36-273">Компилятор предоставляет дополнительные преобразования и операции для этих типов в качестве собственных целых чисел.</span><span class="sxs-lookup"><span data-stu-id="f3d36-273">The compiler surfaces additional conversions and operations for these types as native ints.</span></span> <span data-ttu-id="f3d36-274">Целые числа собственного размера определяют свойства для `MaxValue` или `MinValue`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-274">Native sized integers define properties for `MaxValue` or `MinValue`.</span></span> <span data-ttu-id="f3d36-275">Такие значения не могут быть выражены как константы времени компиляции, так как они зависят от собственного размера целого числа на целевом компьютере.</span><span class="sxs-lookup"><span data-stu-id="f3d36-275">These values can't be expressed as compile time constants because they depend on the native size of an integer on the target machine.</span></span> <span data-ttu-id="f3d36-276">Во время выполнения эти значения доступны только для чтения.</span><span class="sxs-lookup"><span data-stu-id="f3d36-276">Those values are readonly at runtime.</span></span> <span data-ttu-id="f3d36-277">Для `nint` можно использовать значения констант в диапазоне [`int.MinValue` ..</span><span class="sxs-lookup"><span data-stu-id="f3d36-277">You can use constant values for `nint` in the range [`int.MinValue` ..</span></span> <span data-ttu-id="f3d36-278">`int.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="f3d36-278">`int.MaxValue`].</span></span> <span data-ttu-id="f3d36-279">Для `nuint` можно использовать значения констант в диапазоне [`uint.MinValue` ..</span><span class="sxs-lookup"><span data-stu-id="f3d36-279">You can use constant values for `nuint` in the range [`uint.MinValue` ..</span></span> <span data-ttu-id="f3d36-280">`uint.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="f3d36-280">`uint.MaxValue`].</span></span> <span data-ttu-id="f3d36-281">Компилятор выполняет сворачивание константы для всех унарных и бинарных операторов, используя типы <xref:System.Int32?displayProperty=nameWithType> и <xref:System.UInt32?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f3d36-281">The compiler performs constant folding for all unary and binary operators using the <xref:System.Int32?displayProperty=nameWithType> and <xref:System.UInt32?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="f3d36-282">Если результат не помещается в 32 бит, операция выполняется во время выполнения и не считается константой.</span><span class="sxs-lookup"><span data-stu-id="f3d36-282">If the result doesn't fit in 32 bits, the operation is executed at runtime and isn't considered a constant.</span></span> <span data-ttu-id="f3d36-283">Целые числа собственного размера могут повысить производительность в сценариях с большим количеством целочисленных вычислений, в которых необходимо обеспечить максимально высокую производительность.</span><span class="sxs-lookup"><span data-stu-id="f3d36-283">Native sized integers can increase performance in scenarios where integer math is used extensively and needs to have the fastest performance possible.</span></span>

<span data-ttu-id="f3d36-284">Указатели функций предоставляют простой синтаксис для доступа к кодам операций IL `ldftn` и `calli`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-284">Function pointers provide an easy syntax to access the IL opcodes `ldftn` and `calli`.</span></span> <span data-ttu-id="f3d36-285">Указатели функций можно объявлять с помощью нового синтаксиса `delegate*`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-285">You can declare function pointers using new `delegate*` syntax.</span></span> <span data-ttu-id="f3d36-286">Тип `delegate*` — это тип указателя.</span><span class="sxs-lookup"><span data-stu-id="f3d36-286">A `delegate*` type is a pointer type.</span></span> <span data-ttu-id="f3d36-287">При вызове типа `delegate*` используется `calli`, в отличие от делегата, который использует `callvirt` в методе `Invoke()`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-287">Invoking the `delegate*` type uses `calli`, in contrast to a delegate that uses `callvirt` on the `Invoke()` method.</span></span> <span data-ttu-id="f3d36-288">Синтаксически вызовы являются идентичными.</span><span class="sxs-lookup"><span data-stu-id="f3d36-288">Syntactically, the invocations are identical.</span></span> <span data-ttu-id="f3d36-289">При вызове указателя функции используется соглашение о вызовах `managed`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-289">Function pointer invocation uses the `managed` calling convention.</span></span> <span data-ttu-id="f3d36-290">Если требуется объявить о соглашении о вызовах `unmanaged`, добавьте ключевое слово `unmanaged` после синтаксиса `delegate*`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-290">You add the `unmanaged` keyword after the `delegate*` syntax to declare that you want the `unmanaged` calling convention.</span></span> <span data-ttu-id="f3d36-291">Другие соглашения о вызовах можно указать с помощью атрибутов в объявлении `delegate*`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-291">Other calling conventions can be specified using attributes on the `delegate*` declaration.</span></span>

<span data-ttu-id="f3d36-292">Наконец, можно добавить атрибут <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType>, чтобы компилятор не создавал флаг `localsinit`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-292">Finally, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> to instruct the compiler not to emit the `localsinit` flag.</span></span> <span data-ttu-id="f3d36-293">Этот флаг указывает среде CLR на нулевую инициализацию всех локальных переменных.</span><span class="sxs-lookup"><span data-stu-id="f3d36-293">This flag instructs the CLR to zero-initialize all local variables.</span></span> <span data-ttu-id="f3d36-294">Флаг `localsinit` используется в C# по умолчанию, начиная с версии 1.0.</span><span class="sxs-lookup"><span data-stu-id="f3d36-294">The `localsinit` flag has been the default behavior for C# since 1.0.</span></span> <span data-ttu-id="f3d36-295">Однако при использовании дополнительной нулевой инициализации в некоторых сценариях может снизиться производительность.</span><span class="sxs-lookup"><span data-stu-id="f3d36-295">However, the extra zero-initialization may have measurable performance impact in some scenarios.</span></span> <span data-ttu-id="f3d36-296">В частности, при использовании `stackalloc`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-296">In particular, when you use `stackalloc`.</span></span> <span data-ttu-id="f3d36-297">В таких случаях можно добавить атрибут <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f3d36-297">In those cases, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute>.</span></span> <span data-ttu-id="f3d36-298">Его можно добавить в один метод или свойство, в `class`, `struct`, `interface` или даже в модуль.</span><span class="sxs-lookup"><span data-stu-id="f3d36-298">You may add it to a single method or property, or to a `class`, `struct`, `interface`, or even a module.</span></span> <span data-ttu-id="f3d36-299">Этот атрибут не влияет на методы `abstract`. Он влияет на код, созданный для реализации.</span><span class="sxs-lookup"><span data-stu-id="f3d36-299">This attribute doesn't affect `abstract` methods; it affects the code generated for the implementation.</span></span>

<span data-ttu-id="f3d36-300">Эти функции могут повысить производительность в некоторых сценариях.</span><span class="sxs-lookup"><span data-stu-id="f3d36-300">These features can improve performance in some scenarios.</span></span> <span data-ttu-id="f3d36-301">Их следует использовать только после тщательного тестирования как до, так и после внедрения.</span><span class="sxs-lookup"><span data-stu-id="f3d36-301">They should be used only after careful benchmarking both before and after adoption.</span></span> <span data-ttu-id="f3d36-302">Код, включающий целые числа собственного размера, нужно тестировать на нескольких целевых платформах с различными размерами целых чисел.</span><span class="sxs-lookup"><span data-stu-id="f3d36-302">Code involving native sized integers must be tested on multiple target platforms with different integer sizes.</span></span> <span data-ttu-id="f3d36-303">Другие функции требуют небезопасный код.</span><span class="sxs-lookup"><span data-stu-id="f3d36-303">The other features require unsafe code.</span></span>

## <a name="fit-and-finish-features"></a><span data-ttu-id="f3d36-304">Функции подбора и завершения</span><span class="sxs-lookup"><span data-stu-id="f3d36-304">Fit and finish features</span></span>

<span data-ttu-id="f3d36-305">Многие другие функции позволяют более эффективно писать код.</span><span class="sxs-lookup"><span data-stu-id="f3d36-305">Many of the other features help you write code more efficiently.</span></span> <span data-ttu-id="f3d36-306">В C# 9.0 можно опустить тип в [выражении `new`](../language-reference/operators/new-operator.md), если тип созданного объекта уже известен.</span><span class="sxs-lookup"><span data-stu-id="f3d36-306">In C# 9.0, you can omit the type in a [`new` expression](../language-reference/operators/new-operator.md) when the created object's type is already known.</span></span> <span data-ttu-id="f3d36-307">Наиболее часто это используется в объявлениях полей.</span><span class="sxs-lookup"><span data-stu-id="f3d36-307">The most common use is in field declarations:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="WeatherStationField":::

<span data-ttu-id="f3d36-308">`new` с целевым типом можно также использовать, если необходимо создать объект для передачи его в качестве аргумента в метод.</span><span class="sxs-lookup"><span data-stu-id="f3d36-308">Target-typed `new` can also be used when you need to create a new object to pass as an argument to a method.</span></span> <span data-ttu-id="f3d36-309">Рассмотрим метод `ForecastFor()` со следующей сигнатурой.</span><span class="sxs-lookup"><span data-stu-id="f3d36-309">Consider a `ForecastFor()` method with the following signature:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="ForecastSignature":::

<span data-ttu-id="f3d36-310">Его можно вызвать следующим образом.</span><span class="sxs-lookup"><span data-stu-id="f3d36-310">You could call it as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="TargetTypeNewArgument":::

<span data-ttu-id="f3d36-311">Еще один полезный способ использовать эту функцию — объединить ее со свойствами только для инициализации при инициализации нового объекта.</span><span class="sxs-lookup"><span data-stu-id="f3d36-311">Another nice use for this feature is to combine it with init only properties to initialize a new object:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="InitWeatherStation":::

<span data-ttu-id="f3d36-312">Экземпляр, созданный конструктором по умолчанию, можно вернуть с помощью инструкции `return new();`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-312">You can return an instance created by the default constructor using a `return new();` statement.</span></span>

<span data-ttu-id="f3d36-313">Аналогичная функция улучшает разрешение целевого типа в [условных выражениях](../language-reference/operators/conditional-operator.md).</span><span class="sxs-lookup"><span data-stu-id="f3d36-313">A similar feature improves the target type resolution of [conditional expressions](../language-reference/operators/conditional-operator.md).</span></span> <span data-ttu-id="f3d36-314">Благодаря такому изменению два выражения необязательно должны иметь неявное преобразование из одного в другое, но оба могут иметь неявные преобразования в целевой тип.</span><span class="sxs-lookup"><span data-stu-id="f3d36-314">With this change, the two expressions need not have an implicit conversion from one to the other, but may both have implicit conversions to a target type.</span></span> <span data-ttu-id="f3d36-315">Скорее всего, вы не заметите этого изменения.</span><span class="sxs-lookup"><span data-stu-id="f3d36-315">You likely won’t notice this change.</span></span> <span data-ttu-id="f3d36-316">Обратите внимание, что некоторые условные выражения, которые ранее требовали приведения или не компилировались, теперь просто начнут работать.</span><span class="sxs-lookup"><span data-stu-id="f3d36-316">What you will notice is that some conditional expressions that previously required casts or wouldn’t compile now just work.</span></span>

<span data-ttu-id="f3d36-317">Начиная с C# 9.0, можно добавлять модификатор `static` в [лямбда-выражения](../language-reference/operators/lambda-expressions.md) или [анонимные методы](../language-reference/operators/delegate-operator.md).</span><span class="sxs-lookup"><span data-stu-id="f3d36-317">Starting in C# 9.0, you can add the `static` modifier to [lambda expressions](../language-reference/operators/lambda-expressions.md) or [anonymous methods](../language-reference/operators/delegate-operator.md).</span></span> <span data-ttu-id="f3d36-318">Статические лямбда-выражения аналогичны локальным функциям с модификатором `static`: статические лямбда-выражения и анонимные методы не могут захватывать локальные переменные и состояние экземпляра.</span><span class="sxs-lookup"><span data-stu-id="f3d36-318">Static lambda expressions are analogous to the `static` local functions: a static lambda or anonymous method can't capture local variables or instance state.</span></span> <span data-ttu-id="f3d36-319">Модификатор `static` предотвращает случайное захватывание других переменных.</span><span class="sxs-lookup"><span data-stu-id="f3d36-319">The `static` modifier prevents accidentally capturing other variables.</span></span>

<span data-ttu-id="f3d36-320">Ковариантные возвращаемые типы обеспечивают гибкость для типов возвращаемых значений методов [переопределения](../language-reference/keywords/override.md).</span><span class="sxs-lookup"><span data-stu-id="f3d36-320">Covariant return types provide flexibility for the return types of [override](../language-reference/keywords/override.md) methods.</span></span> <span data-ttu-id="f3d36-321">Метод переопределения может возвращать тип, производный от типа возвращаемых значений переопределенного базового метода.</span><span class="sxs-lookup"><span data-stu-id="f3d36-321">An override method can return a type derived from the return type of the overridden base method.</span></span> <span data-ttu-id="f3d36-322">Это может быть полезно для записей и для других типов, которые поддерживают виртуальные методы клонирования или фабричные методы.</span><span class="sxs-lookup"><span data-stu-id="f3d36-322">This can be useful for records and for other types that support virtual clone or factory methods.</span></span>

<span data-ttu-id="f3d36-323">Кроме того, [цикл `foreach`](../language-reference/keywords/foreach-in.md) будет распознавать и использовать метод расширения `GetEnumerator`, который в противном случае удовлетворяет шаблону `foreach`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-323">In addition, the [`foreach` loop](../language-reference/keywords/foreach-in.md) will recognize and use an extension method `GetEnumerator` that otherwise satisfies the `foreach` pattern.</span></span> <span data-ttu-id="f3d36-324">Это изменение означает, что `foreach` согласуется с другими конструкциями на основе шаблонов, такими как асинхронная модель и деконструирование на основе шаблона.</span><span class="sxs-lookup"><span data-stu-id="f3d36-324">This change means `foreach` is consistent with other pattern-based constructions such as the async pattern, and pattern-based deconstruction.</span></span> <span data-ttu-id="f3d36-325">На практике это изменение означает, что можно добавить поддержку `foreach` в любой тип.</span><span class="sxs-lookup"><span data-stu-id="f3d36-325">In practice, this change means you can add `foreach` support to any type.</span></span> <span data-ttu-id="f3d36-326">При перечислении объектов имеет смысл ограничить его использование.</span><span class="sxs-lookup"><span data-stu-id="f3d36-326">You should limit its use to when enumerating an object makes sense in your design.</span></span>

<span data-ttu-id="f3d36-327">Кроме того, можно использовать пустые переменные в качестве параметров для лямбда-выражений.</span><span class="sxs-lookup"><span data-stu-id="f3d36-327">Next, you can use discards as parameters to lambda expressions.</span></span> <span data-ttu-id="f3d36-328">Это удобное изменение позволяет избежать присвоения имени аргументу, а компилятор может избежать его использования.</span><span class="sxs-lookup"><span data-stu-id="f3d36-328">This convenience enables you to avoid naming the argument, and the compiler may avoid using it.</span></span> <span data-ttu-id="f3d36-329">Для любого аргумента используется символ `_`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-329">You use the `_` for any argument.</span></span> <span data-ttu-id="f3d36-330">Дополнительные сведения см. в разделе [Входные параметры лямбда-выражения](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) статьи о [лямбда-выражениях](../language-reference/operators/lambda-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="f3d36-330">For more information, see the [Input parameters of a lambda expression](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) section of the [Lambda expressions](../language-reference/operators/lambda-expressions.md) article.</span></span>

<span data-ttu-id="f3d36-331">Наконец, теперь можно применять атрибуты к [локальным функциям](../programming-guide/classes-and-structs/local-functions.md).</span><span class="sxs-lookup"><span data-stu-id="f3d36-331">Finally, you can now apply attributes to [local functions](../programming-guide/classes-and-structs/local-functions.md).</span></span> <span data-ttu-id="f3d36-332">Например, к локальным функциям можно применить [заметки атрибутов, допускающих значение null](../language-reference/attributes/nullable-analysis.md).</span><span class="sxs-lookup"><span data-stu-id="f3d36-332">For example, you can apply [nullable attribute annotations](../language-reference/attributes/nullable-analysis.md) to local functions.</span></span>

## <a name="support-for-code-generators"></a><span data-ttu-id="f3d36-333">Поддержка генераторов кода</span><span class="sxs-lookup"><span data-stu-id="f3d36-333">Support for code generators</span></span>

<span data-ttu-id="f3d36-334">Две заключительные функции обеспечивают поддержку генераторов кода в C#.</span><span class="sxs-lookup"><span data-stu-id="f3d36-334">Two final features support C# code generators.</span></span> <span data-ttu-id="f3d36-335">Генераторы кода C# — это компонент, который вы можете написать подобно анализатору или исправлению кода Roslyn.</span><span class="sxs-lookup"><span data-stu-id="f3d36-335">C# code generators are a component you can write that is similar to a roslyn analyzer or code fix.</span></span> <span data-ttu-id="f3d36-336">Разница заключается в том, что генераторы кода анализируют код и пишут новые файлы исходного кода в рамках процесса компиляции.</span><span class="sxs-lookup"><span data-stu-id="f3d36-336">The difference is that code generators analyze code and write new source code files as part of the compilation process.</span></span> <span data-ttu-id="f3d36-337">Типичный генератор кода ищет в коде атрибуты или другие соглашения.</span><span class="sxs-lookup"><span data-stu-id="f3d36-337">A typical code generator searches code for attributes or other conventions.</span></span>

<span data-ttu-id="f3d36-338">Генератор кода считывает атрибуты или другие элементы кода с помощью анализирующих интерфейсов API Roslyn.</span><span class="sxs-lookup"><span data-stu-id="f3d36-338">A code generator reads attributes or other code elements using the Roslyn analysis APIs.</span></span> <span data-ttu-id="f3d36-339">На основе этой информации он добавляет новый код в компиляцию.</span><span class="sxs-lookup"><span data-stu-id="f3d36-339">From that information, it adds new code to the compilation.</span></span> <span data-ttu-id="f3d36-340">Генераторы исходного кода могут только добавлять код, они не могут изменять существующий код в компиляции.</span><span class="sxs-lookup"><span data-stu-id="f3d36-340">Source generators can only add code; they aren't allowed to modify any existing code in the compilation.</span></span>

<span data-ttu-id="f3d36-341">Этими двумя функциями, добавленными для поддержки генераторов кода, являются расширения для ***синтаксиса разделяемого метода** _ и _*_инициализаторов модулей_\*\*.</span><span class="sxs-lookup"><span data-stu-id="f3d36-341">The two features added for code generators are extensions to ***partial method syntax** _, and _*_module initializers_\*\*.</span></span> <span data-ttu-id="f3d36-342">Сначала рассмотрим изменения в разделяемые методы.</span><span class="sxs-lookup"><span data-stu-id="f3d36-342">First, the changes to partial methods.</span></span> <span data-ttu-id="f3d36-343">До C# 9.0 разделяемые методы были `private`, но не могли иметь модификаторов доступа, иметь возвращаемое значение `void` и параметры `out`.</span><span class="sxs-lookup"><span data-stu-id="f3d36-343">Before C# 9.0, partial methods are `private` but can't specify an access modifier, have a `void` return, and can't have `out` parameters.</span></span> <span data-ttu-id="f3d36-344">Эти ограничения подразумевают, что, если реализация метода не предоставлена, компилятор удаляет все вызовы к разделяемому методу.</span><span class="sxs-lookup"><span data-stu-id="f3d36-344">These restrictions meant that if no method implementation is provided, the compiler removes all calls to the partial method.</span></span> <span data-ttu-id="f3d36-345">В C# 9.0 эти ограничения снимаются, но требуется, чтобы объявления разделяемых методов имели реализацию.</span><span class="sxs-lookup"><span data-stu-id="f3d36-345">C# 9.0 removes these restrictions, but requires that partial method declarations have an implementation.</span></span> <span data-ttu-id="f3d36-346">Генераторы кода могут предоставить такую реализацию.</span><span class="sxs-lookup"><span data-stu-id="f3d36-346">Code generators can provide that implementation.</span></span> <span data-ttu-id="f3d36-347">Чтобы избежать критических изменений, компилятор рассматривает любой разделяемый метод без модификатора доступа как метод, следующий старым правилам.</span><span class="sxs-lookup"><span data-stu-id="f3d36-347">To avoid introducing a breaking change, the compiler considers any partial method without an access modifier to follow the old rules.</span></span> <span data-ttu-id="f3d36-348">Если разделяемый метод включает модификатор доступа `private`, этот разделяемый метод обрабатывается в соответствии с новыми правилами.</span><span class="sxs-lookup"><span data-stu-id="f3d36-348">If the partial method includes the `private` access modifier, the new rules govern that partial method.</span></span>

<span data-ttu-id="f3d36-349">Второй новой функцией для генераторов кода являются ***инициализаторы модулей***.</span><span class="sxs-lookup"><span data-stu-id="f3d36-349">The second new feature for code generators is ***module initializers***.</span></span> <span data-ttu-id="f3d36-350">Инициализаторы модулей — это методы, к которым прикреплен атрибут <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f3d36-350">Module initializers are methods that have the <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> attribute attached to them.</span></span> <span data-ttu-id="f3d36-351">Эти методы будут вызываться средой выполнения до доступа к полю или вызова метода в целом модуле.</span><span class="sxs-lookup"><span data-stu-id="f3d36-351">These methods will be called by the runtime before any other field access or method invocation within the entire module.</span></span> <span data-ttu-id="f3d36-352">Метод инициализатора модуля:</span><span class="sxs-lookup"><span data-stu-id="f3d36-352">A module initializer method:</span></span>

- <span data-ttu-id="f3d36-353">должен быть статическим;</span><span class="sxs-lookup"><span data-stu-id="f3d36-353">Must be static</span></span>
- <span data-ttu-id="f3d36-354">должен быть без параметров;</span><span class="sxs-lookup"><span data-stu-id="f3d36-354">Must be parameterless</span></span>
- <span data-ttu-id="f3d36-355">должен возвращать значение void;</span><span class="sxs-lookup"><span data-stu-id="f3d36-355">Must return void</span></span>
- <span data-ttu-id="f3d36-356">не должен быть универсальным методом;</span><span class="sxs-lookup"><span data-stu-id="f3d36-356">Must not be a generic method</span></span>
- <span data-ttu-id="f3d36-357">не должен содержаться в универсальном классе;</span><span class="sxs-lookup"><span data-stu-id="f3d36-357">Must not be contained in a generic class</span></span>
- <span data-ttu-id="f3d36-358">должен быть доступен из содержащего модуля.</span><span class="sxs-lookup"><span data-stu-id="f3d36-358">Must be accessible from the containing module</span></span>

<span data-ttu-id="f3d36-359">Последний пункт фактически означает, что метод и содержащий его класс должны быть внутренними или открытыми.</span><span class="sxs-lookup"><span data-stu-id="f3d36-359">That last bullet point effectively means the method and its containing class must be internal or public.</span></span> <span data-ttu-id="f3d36-360">Метод не может быть локальной функцией.</span><span class="sxs-lookup"><span data-stu-id="f3d36-360">The method can't be a local function.</span></span>
