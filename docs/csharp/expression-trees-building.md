---
title: Построение деревьев выражений
description: Сведения о способах построения деревьев выражений.
ms.date: 06/20/2016
ms.technology: csharp-advanced-concepts
ms.assetid: 542754a9-7f40-4293-b299-b9f80241902c
ms.openlocfilehash: f6752879dc01080e056221b00ca5377a6abc20db
ms.sourcegitcommit: c7f0beaa2bd66ebca86362ca17d673f7e8256ca6
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/23/2021
ms.locfileid: "104875815"
---
# <a name="building-expression-trees"></a>Построение деревьев выражений

[Предыдущий раздел — "Интерпретация выражений"](expression-trees-interpreting.md)

Все деревья выражений, которые вы уже видели, были созданы с помощью компилятора C#. Все, что нужно было сделать, — это создать лямбда-выражение, которое было присвоено переменной, типизированной как `Expression<Func<T>>`, или имеющий схожий тип. Это не единственный способ создания дерева выражений. Во многих случаях может понадобиться создать выражение в памяти во время выполнения.

Процесс построения деревьев выражений усложняется тем фактом, что эти деревья выражений являются неизменяемыми. Неизменяемость означает, что дерево необходимо создать, начиная с листьев и заканчивая корнем. API-интерфейсы, которые будут использоваться для создания деревьев выражений, отражают этот факт: методы, используемые для создания узла, будут принимать все его дочерние узлы в качестве аргументов. Рассмотрим несколько примеров, демонстрирующих способы создания.

## <a name="creating-nodes"></a>Создание узлов

Начнем с относительно простого варианта. Мы будем использовать выражение сложения, которое применялось в этих разделах:

```csharp
Expression<Func<int>> sum = () => 1 + 2;
```

Чтобы построить дерево выражения, необходимо создать конечные узлы.
Конечные узлы являются константами, поэтому для их создания можно использовать метод `Expression.Constant`:

```csharp
var one = Expression.Constant(1, typeof(int));
var two = Expression.Constant(2, typeof(int));
```

Затем вы создадите выражение сложения:

```csharp
var addition = Expression.Add(one, two);
```

После этого можно создать лямбда-выражение:

```csharp
var lambda = Expression.Lambda(addition);
```

Это очень простое лямбда-выражение, так как оно не содержит аргументов.
Далее в этом разделе вы узнаете, как сопоставлять аргументы с параметрами и создавать более сложные выражения.

Для выражений, которые так же просты, как и это, можно совместить все вызовы в одну инструкцию:

```csharp
var lambda = Expression.Lambda(
    Expression.Add(
        Expression.Constant(1, typeof(int)),
        Expression.Constant(2, typeof(int))
    )
);
```

## <a name="building-a-tree"></a>Построение дерева

Это основные принципы построения дерева выражения в памяти. Более сложные деревья обычно характеризуются большим количеством типов узлов и количеством самих узлов. Рассмотрим еще один пример и взглянем на два дополнительных типа узлов, которые обычно создаются при построении деревьев выражений: узлы аргументов и узлы вызовов методов.

Построим дерево выражения, чтобы создать это выражение:

```csharp
Expression<Func<double, double, double>> distanceCalc =
    (x, y) => Math.Sqrt(x * x + y * y);
```

Начнем с создания выражений параметров для `x` и `y`:

```csharp
var xParameter = Expression.Parameter(typeof(double), "x");
var yParameter = Expression.Parameter(typeof(double), "y");
```

Создание выражений умножения и сложения выполняется по шаблону, который вы уже видели:

```csharp
var xSquared = Expression.Multiply(xParameter, xParameter);
var ySquared = Expression.Multiply(yParameter, yParameter);
var sum = Expression.Add(xSquared, ySquared);
```

Затем необходимо создать выражение вызова метода для вызова `Math.Sqrt`.

```csharp
var sqrtMethod = typeof(Math).GetMethod("Sqrt", new[] { typeof(double) });
var distance = Expression.Call(sqrtMethod, sum);
```

И, наконец, нужно поместить вызов метода в лямбда-выражение и определить аргументы для лямбда-выражения:

```csharp
var distanceLambda = Expression.Lambda(
    distance,
    xParameter,
    yParameter);
```

В этом более сложном примере используется несколько дополнительных приемов, зачастую необходимых при созданий деревьев выражений.

Во-первых, необходимо создать объекты, представляющие параметры или локальные переменные, перед их использованием. Созданные объекты можно использовать в дереве выражения там, где это необходимо.

Во-вторых, необходимо использовать подмножество API-интерфейсов отражения для создания объекта `MethodInfo`, чтобы можно было построить дерево выражения для получения доступа к этому методу. Необходимо ограничить подмножество API-интерфейсов отражения, доступных на платформе .NET Core. Эти способы можно будет использовать для других деревьев выражений.

## <a name="building-code-in-depth"></a>Всестороннее создание кода

С помощью этих API вы можете создавать что угодно. Однако чем более сложное дерево выражения вы хотите построить, тем более сложными являются задачи чтения кода и управления им.

Давайте создадим дерево выражения, которое эквивалентно этому коду:

```csharp
Func<int, int> factorialFunc = (n) =>
{
    var res = 1;
    while (n > 1)
    {
        res = res * n;
        n--;
    }
    return res;
};
```

Обратите внимание, что было построено не дерево выражения, а просто делегат. С помощью класса `Expression` нельзя создать лямбды операторов. Ниже приведен код, необходимый для формирования тех же функциональных возможностей. Он усложняется тем фактом, что API для создания цикла `while` не существует. Вместо этого необходимо создать цикл, который содержит проверку условий, и целевой объект метки для разрыва цикла.

```csharp
var nArgument = Expression.Parameter(typeof(int), "n");
var result = Expression.Variable(typeof(int), "result");

// Creating a label that represents the return value
LabelTarget label = Expression.Label(typeof(int));

var initializeResult = Expression.Assign(result, Expression.Constant(1));

// This is the inner block that performs the multiplication,
// and decrements the value of 'n'
var block = Expression.Block(
    Expression.Assign(result,
        Expression.Multiply(result, nArgument)),
    Expression.PostDecrementAssign(nArgument)
);

// Creating a method body.
BlockExpression body = Expression.Block(
    new[] { result },
    initializeResult,
    Expression.Loop(
        Expression.IfThenElse(
            Expression.GreaterThan(nArgument, Expression.Constant(1)),
            block,
            Expression.Break(label, result)
        ),
        label
    )
);
```

Код для создания дерева выражения для функции факториала немного больше, более сложен и содержит операторы меток и прерываний и другие элементы, использования которых хотелось бы избежать при выполнении ежедневных задач по созданию кода.

Для работы в этом разделе также обновлен код посетителя для просмотра каждого узла в этом дереве выражения и записи сведений об узлах, созданных в этом примере. [Просмотреть или скачать пример кода](https://github.com/dotnet/samples/tree/main/csharp/expression-trees) можно в репозитории dotnet/docs на сайте GitHub. Поэкспериментируйте со сборкой и использованием примеров кода. Инструкции по загрузке см. в разделе [Просмотр и скачивание примеров](../samples-and-tutorials/index.md#view-and-download-samples).

## <a name="examining-the-apis"></a>Изучение API-интерфейсов

Возможности навигации по API-интерфейсам дерева выражений усложнены в .NET Core, но это нормально. Их назначение довольно сложное — написание кода, который создает код во время выполнения. Они с трудом обеспечивают баланс между поддержкой всех структур управления, доступных на языке C#, и сохранением минимально возможного размера контактной зоны API-интерфейсов. Этот баланс означает, что многие структуры управления представлены не своими конструкциями C#, а конструкциями, которые представляют базовую логику, создаваемую компилятором из этих конструкций более высокого уровня.

Кроме того, в настоящее время не существует выражений C#, которые создаются напрямую с помощью методов класса `Expression`. Как правило, это будут новые операторы и выражения, добавленные в C# 5 и C# 6. (Например, выражения `async` не могут быть созданы, и новый оператор `?.` нельзя создать напрямую.)

[Следующий раздел — "Преобразование выражений"](expression-trees-translating.md)
