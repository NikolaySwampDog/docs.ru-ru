---
title: Деконструкция кортежей и других типов
description: Сведения о деконструкции кортежей и других типов.
ms.technology: csharp-fundamentals
ms.date: 03/22/2021
ms.openlocfilehash: acacfb6a9401a3a888f9b8226798c95578f9fa45
ms.sourcegitcommit: c7f0beaa2bd66ebca86362ca17d673f7e8256ca6
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/23/2021
ms.locfileid: "104875828"
---
# <a name="deconstructing-tuples-and-other-types"></a><span data-ttu-id="e7941-103">Деконструкция кортежей и других типов</span><span class="sxs-lookup"><span data-stu-id="e7941-103">Deconstructing tuples and other types</span></span>

<span data-ttu-id="e7941-104">Кортеж позволяет вам легко получить несколько значений при вызове метода.</span><span class="sxs-lookup"><span data-stu-id="e7941-104">A tuple provides a lightweight way to retrieve multiple values from a method call.</span></span> <span data-ttu-id="e7941-105">Но после получения кортежа вам нужно будет обработать его отдельные элементы.</span><span class="sxs-lookup"><span data-stu-id="e7941-105">But once you retrieve the tuple, you have to handle its individual elements.</span></span> <span data-ttu-id="e7941-106">Это довольно неудобно, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="e7941-106">Doing this on an element-by-element basis is cumbersome, as the following example shows.</span></span> <span data-ttu-id="e7941-107">Метод `QueryCityData` возвращает кортеж из трех элементов, и каждый из его элементов присваивается переменной за отдельную операцию.</span><span class="sxs-lookup"><span data-stu-id="e7941-107">The `QueryCityData` method returns a 3-tuple, and each of its elements is assigned to a variable in a separate operation.</span></span>

[!code-csharp[WithoutDeconstruction](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple1.cs)]

<span data-ttu-id="e7941-108">Получение множества значений полей и свойств из объекта может быть столь же неудобно: необходимо присваивать значение каждого поля или свойства отдельной переменной.</span><span class="sxs-lookup"><span data-stu-id="e7941-108">Retrieving multiple field and property values from an object can be equally cumbersome: you have to assign a field or property value to a variable on a member-by-member basis.</span></span>

<span data-ttu-id="e7941-109">Начиная с C# 7.0 вы можете извлекать из кортежа множество элементов или получать множество значений полей, свойств и вычисляемых значений из объекта, используя всего одну операцию *деконструкции*.</span><span class="sxs-lookup"><span data-stu-id="e7941-109">Starting with C# 7.0, you can retrieve multiple elements from a tuple or retrieve multiple field, property, and computed values from an object in a single *deconstruct* operation.</span></span> <span data-ttu-id="e7941-110">При деконструкции кортежа вы присваиваете его элементы отдельным переменным.</span><span class="sxs-lookup"><span data-stu-id="e7941-110">When you deconstruct a tuple, you assign its elements to individual variables.</span></span> <span data-ttu-id="e7941-111">При деконструкции объекта вы присваиваете отдельным переменным выбранные значения.</span><span class="sxs-lookup"><span data-stu-id="e7941-111">When you deconstruct an object, you assign selected values to individual variables.</span></span>

## <a name="deconstructing-a-tuple"></a><span data-ttu-id="e7941-112">Деконструкция кортежа</span><span class="sxs-lookup"><span data-stu-id="e7941-112">Deconstructing a tuple</span></span>

<span data-ttu-id="e7941-113">Язык C# имеет встроенную поддержку деконструкции кортежей, которая позволяет извлекать из кортежа все элементы за одну операцию.</span><span class="sxs-lookup"><span data-stu-id="e7941-113">C# features built-in support for deconstructing tuples, which lets you unpackage all the items in a tuple in a single operation.</span></span> <span data-ttu-id="e7941-114">Общий синтаксис деконструкции кортежа напоминает синтаксис его определения: переменные, которым будут присвоены элементы кортежа, указываются в круглых скобках в левой части оператора присваивания.</span><span class="sxs-lookup"><span data-stu-id="e7941-114">The general syntax for deconstructing a tuple is similar to the syntax for defining one: you enclose the variables to which each element is to be assigned in parentheses in the left side of an assignment statement.</span></span> <span data-ttu-id="e7941-115">Например, следующий оператор присваивает элементы кортежа из четырех элементов четырем отдельным переменным:</span><span class="sxs-lookup"><span data-stu-id="e7941-115">For example, the following statement assigns the elements of a 4-tuple to four separate variables:</span></span>

```csharp
var (name, address, city, zip) = contact.GetAddressInfo();
```

<span data-ttu-id="e7941-116">Существует три способа деконструкции кортежа:</span><span class="sxs-lookup"><span data-stu-id="e7941-116">There are three ways to deconstruct a tuple:</span></span>

- <span data-ttu-id="e7941-117">Вы можете явно объявить тип каждого поля в скобках.</span><span class="sxs-lookup"><span data-stu-id="e7941-117">You can explicitly declare the type of each field inside parentheses.</span></span> <span data-ttu-id="e7941-118">В следующем примере этот способ используется для деконструкции кортежа из трех элементов, возвращаемого методом `QueryCityData`.</span><span class="sxs-lookup"><span data-stu-id="e7941-118">The following example uses this approach to deconstruct the 3-tuple returned by the `QueryCityData` method.</span></span>

    [!code-csharp[Deconstruction-Explicit](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple2.cs#1)]

- <span data-ttu-id="e7941-119">Вы можете использовать ключевое слово `var`, чтобы C# определил тип каждой переменной.</span><span class="sxs-lookup"><span data-stu-id="e7941-119">You can use the `var` keyword so that C# infers the type of each variable.</span></span> <span data-ttu-id="e7941-120">Ключевое слово `var` помещается за пределами скобок.</span><span class="sxs-lookup"><span data-stu-id="e7941-120">You place the `var` keyword outside of the parentheses.</span></span> <span data-ttu-id="e7941-121">В следующем примере используется определение типа при деконструкции кортежа из трех элементов, возвращаемого методом `QueryCityData`.</span><span class="sxs-lookup"><span data-stu-id="e7941-121">The following example uses type inference when deconstructing the 3-tuple returned by the `QueryCityData` method.</span></span>

    [!code-csharp[Deconstruction-Infer](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple3.cs#1)]

    <span data-ttu-id="e7941-122">Кроме того, вы можете использовать ключевое слово `var` при объявлении отдельных или всех переменных внутри скобок.</span><span class="sxs-lookup"><span data-stu-id="e7941-122">You can also use the `var` keyword individually with any or all of the variable declarations inside the parentheses.</span></span>

    [!code-csharp[Deconstruction-Infer-Some](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple4.cs#1)]

    <span data-ttu-id="e7941-123">Это неудобно и не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="e7941-123">This is cumbersome and is not recommended.</span></span>

- <span data-ttu-id="e7941-124">Наконец, можно выполнить деконструкцию кортежа в переменные, которые уже были объявлены.</span><span class="sxs-lookup"><span data-stu-id="e7941-124">Lastly, you may deconstruct the tuple into variables that have already been declared.</span></span>

    [!code-csharp[Deconstruction-Declared](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple5.cs#1)]

<span data-ttu-id="e7941-125">Обратите внимание, что вы не можете указать определенный тип за скобками, даже если все поля в кортеже имеют один и тот же тип.</span><span class="sxs-lookup"><span data-stu-id="e7941-125">Note that you cannot specify a specific type outside the parentheses even if every field in the tuple has the same type.</span></span> <span data-ttu-id="e7941-126">Это приведет к возникновению ошибки компилятора CS8136 "Форма деконструкции 'var (...)' не разрешает использовать конкретный тип для 'var'.".</span><span class="sxs-lookup"><span data-stu-id="e7941-126">This generates compiler error CS8136, "Deconstruction 'var (...)' form disallows a specific type for 'var'.".</span></span>

<span data-ttu-id="e7941-127">Обратите внимание, что каждый элемент кортежа необходимо присвоить переменной.</span><span class="sxs-lookup"><span data-stu-id="e7941-127">Note that you must also assign each element of the tuple to a variable.</span></span> <span data-ttu-id="e7941-128">Если вы пропустите какие-то элементы, компилятор выдаст сообщение об ошибке CS8132 "Невозможно деконструировать кортеж из "x" элементов на "y" переменных".</span><span class="sxs-lookup"><span data-stu-id="e7941-128">If you omit any elements, the compiler generates error CS8132, "Cannot deconstruct a tuple of 'x' elements into 'y' variables."</span></span>

<span data-ttu-id="e7941-129">Обратите внимание, что нельзя смешивать объявления и назначения существующим переменным в левой части деконструкции.</span><span class="sxs-lookup"><span data-stu-id="e7941-129">Note that you cannot mix declarations and assignments to existing variables on the left-hand side of a deconstruction.</span></span> <span data-ttu-id="e7941-130">Компилятор выводит ошибку CS8184: "Деконструкция не может содержать объявления и выражения в левой части",</span><span class="sxs-lookup"><span data-stu-id="e7941-130">The compiler generates error CS8184, "a deconstruction cannot mix declarations and expressions on the left-hand-side."</span></span> <span data-ttu-id="e7941-131">если члены содержат новые объявленные и существующие переменные.</span><span class="sxs-lookup"><span data-stu-id="e7941-131">when the members include newly declared and existing variables.</span></span>

## <a name="deconstructing-tuple-elements-with-discards"></a><span data-ttu-id="e7941-132">Деконструкция элементов кортежа с использованием пустых переменных</span><span class="sxs-lookup"><span data-stu-id="e7941-132">Deconstructing tuple elements with discards</span></span>

<span data-ttu-id="e7941-133">При деконструкции кортежа нас часто интересуют значения только некоторых элементов.</span><span class="sxs-lookup"><span data-stu-id="e7941-133">Often when deconstructing a tuple, you're interested in the values of only some elements.</span></span> <span data-ttu-id="e7941-134">Начиная с C# 7.0 вы можете воспользоваться поддержкой *пустых переменных* в C#, которые представляют собой доступные только для записи переменные, значения которых нас не интересуют.</span><span class="sxs-lookup"><span data-stu-id="e7941-134">Starting with C# 7.0, you can take advantage of C#'s support for *discards*, which are write-only variables whose values you've chosen to ignore.</span></span> <span data-ttu-id="e7941-135">Пустая переменная обозначается символом нижнего подчеркивания ("\_") в операторе присваивания.</span><span class="sxs-lookup"><span data-stu-id="e7941-135">A discard is designated by an underscore character ("\_") in an assignment.</span></span> <span data-ttu-id="e7941-136">Вы можете сделать пустыми сколько угодно значений. Все они будут считаться одной переменной, `_`.</span><span class="sxs-lookup"><span data-stu-id="e7941-136">You can discard as many values as you like; all are represented by the single discard, `_`.</span></span>

<span data-ttu-id="e7941-137">В следующем примере показано использование кортежей с пустыми переменными.</span><span class="sxs-lookup"><span data-stu-id="e7941-137">The following example illustrates the use of tuples with discards.</span></span> <span data-ttu-id="e7941-138">Метод `QueryCityDataForYears` возвращает кортеж из шести элементов: название города, его площадь, год, численность населения города в этом году, другой год и численность населения в том году.</span><span class="sxs-lookup"><span data-stu-id="e7941-138">The `QueryCityDataForYears` method returns a 6-tuple with the name of a city, its area, a year, the city's population for that year, a second year, and the city's population for that second year.</span></span> <span data-ttu-id="e7941-139">В примере показано изменение численности населения за эти два года.</span><span class="sxs-lookup"><span data-stu-id="e7941-139">The example shows the change in population between those two years.</span></span> <span data-ttu-id="e7941-140">Из доступных в кортеже данных нас не интересует площадь города, а название города и две даты известны нам уже на этапе разработки.</span><span class="sxs-lookup"><span data-stu-id="e7941-140">Of the data available from the tuple, we're unconcerned with the city area, and we know the city name and the two dates at design-time.</span></span> <span data-ttu-id="e7941-141">Следовательно, нас интересуют только два значения численности населения, которые хранятся в кортеже. Остальные значения можно обработать как пустые переменные.</span><span class="sxs-lookup"><span data-stu-id="e7941-141">As a result, we're only interested in the two population values stored in the tuple, and can handle its remaining values as discards.</span></span>  

[!code-csharp[Tuple-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/discard-tuple1.cs)]

## <a name="deconstructing-user-defined-types"></a><span data-ttu-id="e7941-142">Деконструкция пользовательских типов</span><span class="sxs-lookup"><span data-stu-id="e7941-142">Deconstructing user-defined types</span></span>

<span data-ttu-id="e7941-143">C# не предоставляет встроенную поддержку для деконструкции типов, не являющихся кортежами, кроме типов [`record`](#deconstructing-a-record-type) и [DictionaryEntry](xref:System.Collections.DictionaryEntry.Deconstruct%2A).</span><span class="sxs-lookup"><span data-stu-id="e7941-143">C# does not offer built-in support for deconstructing non-tuple types other than the [`record`](#deconstructing-a-record-type) and [DictionaryEntry](xref:System.Collections.DictionaryEntry.Deconstruct%2A) types.</span></span> <span data-ttu-id="e7941-144">Тем не менее, если вы являетесь создателем класса, структуры или интерфейса, вы можете разрешить деконструкцию экземпляров определенного типа, реализовав один или несколько методов `Deconstruct`.</span><span class="sxs-lookup"><span data-stu-id="e7941-144">However, as the author of a class, a struct, or an interface, you can allow instances of the type to be deconstructed by implementing one or more `Deconstruct` methods.</span></span> <span data-ttu-id="e7941-145">Метод возвращает "void", и каждое деконструируемое значение обозначается параметром [out](language-reference/keywords/out-parameter-modifier.md) в сигнатуре метода.</span><span class="sxs-lookup"><span data-stu-id="e7941-145">The method returns void, and each value to be deconstructed is indicated by an [out](language-reference/keywords/out-parameter-modifier.md) parameter in the method signature.</span></span> <span data-ttu-id="e7941-146">Например, следующий метод `Deconstruct` класса `Person` возвращает имя, отчество и фамилию:</span><span class="sxs-lookup"><span data-stu-id="e7941-146">For example, the following `Deconstruct` method of a `Person` class returns the first, middle, and last name:</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#1)]

<span data-ttu-id="e7941-147">Затем вы можете выполнить деконструкцию экземпляра класса `Person` с именем `p`, используя подобное присваивание:</span><span class="sxs-lookup"><span data-stu-id="e7941-147">You can then deconstruct an instance of the `Person` class named `p` with an assignment like the following:</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#2)]

<span data-ttu-id="e7941-148">В следующем примере показана перегрузка метода `Deconstruct` для возвращения различных сочетаний свойств объекта `Person`.</span><span class="sxs-lookup"><span data-stu-id="e7941-148">The following example overloads the `Deconstruct` method to return various combinations of properties of a `Person` object.</span></span> <span data-ttu-id="e7941-149">Отдельные перегрузки возвращают следующие значения:</span><span class="sxs-lookup"><span data-stu-id="e7941-149">Individual overloads return:</span></span>

- <span data-ttu-id="e7941-150">Имя и фамилия.</span><span class="sxs-lookup"><span data-stu-id="e7941-150">A first and last name.</span></span>
- <span data-ttu-id="e7941-151">Имя, отчество, фамилия.</span><span class="sxs-lookup"><span data-stu-id="e7941-151">A first, middle, and last name.</span></span>
- <span data-ttu-id="e7941-152">Имя, фамилия, название города и название штата.</span><span class="sxs-lookup"><span data-stu-id="e7941-152">A first name, a last name, a city name, and a state name.</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class2.cs)]

<span data-ttu-id="e7941-153">Несколько методов `Deconstruct` с одинаковым числом параметров вносят путаницу.</span><span class="sxs-lookup"><span data-stu-id="e7941-153">Multiple `Deconstruct` methods having the same number of parameters are ambiguous.</span></span> <span data-ttu-id="e7941-154">Старайтесь определять методы `Deconstruct` с разным числом параметров или аргументов.</span><span class="sxs-lookup"><span data-stu-id="e7941-154">You must be careful to define `Deconstruct` methods with different numbers of parameters, or "arity".</span></span> <span data-ttu-id="e7941-155">Методы `Deconstruct` с одинаковым количеством параметров невозможно различить при разрешении перегрузки.</span><span class="sxs-lookup"><span data-stu-id="e7941-155">`Deconstruct` methods with the same number of parameters cannot be distinguished during overload resolution.</span></span>

## <a name="deconstructing-a-user-defined-type-with-discards"></a><span data-ttu-id="e7941-156">Деконструкция пользовательского типа с пустыми переменными</span><span class="sxs-lookup"><span data-stu-id="e7941-156">Deconstructing a user-defined type with discards</span></span>

<span data-ttu-id="e7941-157">Как и с [кортежами](#deconstructing-tuple-elements-with-discards), пустые переменные можно применять с пользовательскими типами, чтобы игнорировать определенные элементы, возвращаемые методом `Deconstruct`.</span><span class="sxs-lookup"><span data-stu-id="e7941-157">Just as you do with [tuples](#deconstructing-tuple-elements-with-discards), you can use discards to ignore selected items returned by a `Deconstruct` method.</span></span> <span data-ttu-id="e7941-158">Каждая пустая переменная определяется переменной с именем "\_", и одна операция деконструкции может включать несколько пустых переменных.</span><span class="sxs-lookup"><span data-stu-id="e7941-158">Each discard is defined by a variable named "\_", and a single deconstruction operation can include multiple discards.</span></span>

<span data-ttu-id="e7941-159">В следующем примере показана деконструкция объекта `Person` на четыре строки (имя, фамилия, город и область), но для фамилии и области используются пустые переменные.</span><span class="sxs-lookup"><span data-stu-id="e7941-159">The following example deconstructs a `Person` object into four strings (the first and last names, the city, and the state) but discards the last name and the state.</span></span>

[!code-csharp[Class-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/class-discard1.cs#1)]

## <a name="deconstructing-a-user-defined-type-with-an-extension-method"></a><span data-ttu-id="e7941-160">Деконструкция пользовательского типа с использованием метода расширения</span><span class="sxs-lookup"><span data-stu-id="e7941-160">Deconstructing a user-defined type with an extension method</span></span>

<span data-ttu-id="e7941-161">Если вы не являетесь создателем класса, структуры или интерфейса, вы все равно можете выполнять деконструкцию объектов этого типа, реализовав один или несколько `Deconstruct` [методов расширения](programming-guide/classes-and-structs/extension-methods.md), которые будут возвращать интересующие вас значения.</span><span class="sxs-lookup"><span data-stu-id="e7941-161">If you didn't author a class, struct, or interface, you can still deconstruct objects of that type by implementing one or more `Deconstruct` [extension methods](programming-guide/classes-and-structs/extension-methods.md) to return the values in which you're interested.</span></span>

<span data-ttu-id="e7941-162">В приведенном ниже примере определены два метода расширения `Deconstruct` для класса <xref:System.Reflection.PropertyInfo?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e7941-162">The following example defines two `Deconstruct` extension methods for the <xref:System.Reflection.PropertyInfo?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="e7941-163">Первый метод возвращает набор значений, которые указывают характеристики свойства, в том числе его тип, является ли оно статическим свойством или экземпляром, доступно ли оно только для чтения и является ли оно индексируемым.</span><span class="sxs-lookup"><span data-stu-id="e7941-163">The first returns a set of values that indicate the characteristics of the property, including its type, whether it's static or instance, whether it's read-only, and whether it's indexed.</span></span> <span data-ttu-id="e7941-164">Второй метод показывает уровень доступа свойства.</span><span class="sxs-lookup"><span data-stu-id="e7941-164">The second indicates the property's accessibility.</span></span> <span data-ttu-id="e7941-165">Так как методы доступа для чтения и записи у свойства могут иметь разный уровень доступа, мы используем логические значения, которые показывают, имеет ли свойство разные методы для чтения и записи и, если это так, имеют ли эти методы один уровень доступа.</span><span class="sxs-lookup"><span data-stu-id="e7941-165">Because the accessibility of get and set accessors can differ, Boolean values indicate whether the property has separate get and set accessors and, if it does, whether they have the same accessibility.</span></span> <span data-ttu-id="e7941-166">Если существует только один метод доступа или если методы доступа для чтения и записи имеют один и тот же уровень доступа, переменная `access` показывает доступность свойства в целом.</span><span class="sxs-lookup"><span data-stu-id="e7941-166">If there is only one accessor or both the get and the set accessor have the same accessibility, the `access` variable indicates the accessibility of the property as a whole.</span></span> <span data-ttu-id="e7941-167">В противном случае доступность методов чтения и записи указывается переменными `getAccess` и `setAccess`.</span><span class="sxs-lookup"><span data-stu-id="e7941-167">Otherwise, the accessibility of the get and set accessors are indicated by the `getAccess` and `setAccess` variables.</span></span>

[!code-csharp[Extension-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-extension1.cs)]

## <a name="deconstructing-a-record-type"></a><span data-ttu-id="e7941-168">Деконструкция типа `record`</span><span class="sxs-lookup"><span data-stu-id="e7941-168">Deconstructing a `record` type</span></span>

<span data-ttu-id="e7941-169">При объявлении типа [record](language-reference/builtin-types/record.md) с помощью двух позиционных параметров или более компилятор создает метод `Deconstruct` с параметром `out` для каждого позиционного параметра в объявлении `record`.</span><span class="sxs-lookup"><span data-stu-id="e7941-169">When you declare a [record](language-reference/builtin-types/record.md) type by using two or more positional parameters, the compiler creates a `Deconstruct` method with an `out` parameter for each positional parameter in the `record` declaration.</span></span> <span data-ttu-id="e7941-170">Дополнительные сведения см. в разделах [Позиционный синтаксис для определения свойства](language-reference/builtin-types/record.md#positional-syntax-for-property-definition) и [Поведение деконструктора в производных записях](language-reference/builtin-types/record.md#deconstructor-behavior-in-derived-records).</span><span class="sxs-lookup"><span data-stu-id="e7941-170">For more information, see [Positional syntax for property definition](language-reference/builtin-types/record.md#positional-syntax-for-property-definition) and [Deconstructor behavior in derived records](language-reference/builtin-types/record.md#deconstructor-behavior-in-derived-records).</span></span>

## <a name="see-also"></a><span data-ttu-id="e7941-171">См. также</span><span class="sxs-lookup"><span data-stu-id="e7941-171">See also</span></span>

- [<span data-ttu-id="e7941-172">Операции удаления</span><span class="sxs-lookup"><span data-stu-id="e7941-172">Discards</span></span>](discards.md)
- [<span data-ttu-id="e7941-173">Типы кортежей</span><span class="sxs-lookup"><span data-stu-id="e7941-173">Tuple types</span></span>](language-reference/builtin-types/value-tuples.md)
