---
title: Концепции распределенной трассировки — .NET
description: Концепции распределенной трассировки .NET
ms.date: 03/14/2021
ms.openlocfilehash: 368cb545b9928534766e3005992a7a55571b8dcc
ms.sourcegitcommit: e16315d9f1ff355f55ff8ab84a28915be0a8e42b
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/25/2021
ms.locfileid: "105111516"
---
# <a name="net-distributed-tracing-concepts"></a>Концепции распределенной трассировки .NET

Распределенная трассировка — это диагностическая методика, помогающая инженерам локализовать сбои и проблемы с производительностью в приложениях, особенно те, которые могут охватывать несколько компьютеров или процессов. Общие сведения о том, где можно использовать распределенную трассировку, и примеры кода для начала работы см. в разделе [Обзор распределенной трассировки](distributed-tracing.md).

### <a name="traces-and-activities"></a>Трассировки и действия

Каждый раз, когда приложение получает новый запрос, его можно связать с трассировкой. В компонентах приложений, написанных на .NET, единицы работы в трассировке представлены экземплярами <xref:System.Diagnostics.Activity?displayProperty=nameWithType>, а трассировка в целом образует дерево этих действий, которое может охватывать множество различных процессов. Первое действие, созданное для нового запроса, образует корень дерева трассировки и отслеживает общую длительность и успех или неудачу обработки запроса. При необходимости можно создавать дочерние действия, чтобы разделить работу на шаги, которые можно отслеживать по отдельности.
Например, для действия, отслеживающего конкретный входящий HTTP-запрос на веб-сервере, можно создать дочерние действия отслеживания каждого запроса к базе данных, потребовавшегося для выполнения запроса. Это позволяет независимо регистрировать длительность и успешность каждого запроса.
Действия могут записывать другие сведения для каждой единицы работы, например <xref:System.Diagnostics.Activity.OperationName>, пары "имя — значение" (<xref:System.Diagnostics.Activity.Tags>) и <xref:System.Diagnostics.Activity.Events>. Имя определяет тип выполняемой работы, теги могут записывать описательные параметры работы, а события представляют собой простой механизм ведения журнала для регистрации диагностических сообщений с метками времени.

> [!NOTE]
> Другое распространенное отраслевое название для единиц работы в распределенной трассировке — рабочие интервалы.
> За много лет до того, как для этой концепции закрепилось название "рабочий интервал", в среде .NET применялся термин "действие".

### <a name="activity-ids"></a>ИД действий

Связи "родитель — потомок" между действиями в дереве распределенной трассировки устанавливаются с помощью уникальных идентификаторов. Реализация распределенной трассировки в .NET поддерживает две схемы идентификаторов: стандарт [TraceContext](https://www.w3.org/TR/trace-context/) консорциума W3C, используемый по умолчанию в .NET 5, и более старое соглашение .NET, именуемое иерархическим, которое доступно для обеспечения обратной совместимости.
<xref:System.Diagnostics.Activity.DefaultIdFormat?displayProperty=nameWithType> определяет, какая схема идентификаторов используется. В стандарте TraceContext консорциума W3C каждой трассировке присваивается глобально уникальный 16-байтный идентификатор трассировки (<xref:System.Diagnostics.Activity.TraceId?displayProperty=nameWithType>), а каждому действию внутри трассировки присваивается уникальный 8-байтный идентификатор рабочего интервала (<xref:System.Diagnostics.Activity.SpanId?displayProperty=nameWithType>). Каждое действие регистрирует идентификатор трассировки, собственный идентификатор рабочего интервала и идентификатор рабочего интервала своего родительского объекта (<xref:System.Diagnostics.Activity.ParentSpanId?displayProperty=nameWithType>). Так как распределенные трассировки могут отслеживать работу между границами процессов, родительские и дочерние действия могут не находиться в одном процессе. Сочетание идентификатора трассировки и идентификатора рабочего интервала родительского объекта позволяет однозначно идентифицировать родительское действие на глобальном уровне, независимо от того, в каком процессе оно находится.

<xref:System.Diagnostics.Activity.DefaultIdFormat?displayProperty=nameWithType> определяет, какой формат идентификатора используется для запуска новых трассировок, но по умолчанию при добавлении нового действия в существующую трассировку используется формат, используемый родительским действием.
Установка для <xref:System.Diagnostics.Activity.ForceDefaultIdFormat?displayProperty=nameWithType> значения true переопределяет это поведение и обеспечивает создание всех действий с DefaultIdFormat, даже если родительский объект использует другой формат идентификатора.

### <a name="starting-and-stopping-activities"></a>Запуск и остановка действий

Каждый поток в процессе может иметь соответствующий объект действия, отслеживающий работу в этом потоке, доступ к которому осуществляется через <xref:System.Diagnostics.Activity.Current?displayProperty=nameWithType>. Текущее действие автоматически проходит по всем синхронным вызовам в потоке, а также следующим асинхронным вызовам, которые обрабатываются в разных потоках. Если действие А является текущим в потоке и код запускает новое действие Б, то Б становится новым текущим действием в этом потоке. По умолчанию действие Б также расценивает действие А как свой родительский объект. Если позднее действие Б остановлено, действие А будет восстановлено в качестве текущего действия в потоке. При запуске действие фиксирует текущее время как <xref:System.Diagnostics.Activity.StartTimeUtc?displayProperty=nameWithType>. При его остановке вычисляется <xref:System.Diagnostics.Activity.Duration?displayProperty=nameWithType> как разница между текущим временем и временем начала.

### <a name="coordinating-across-process-boundaries"></a>Координация между границами процессов

Для отслеживания работы между границами процессов идентификаторы родительских действий должны передаваться по сети, чтобы принимающий процесс мог создавать ссылающиеся на них действия. При использовании формата идентификатора TraceContext консорциума W3C среда .NET также будет использовать заголовки HTTP, рекомендованные [этим стандартом](https://www.w3.org/TR/trace-context/), для передачи этих данных. При использовании формата идентификатора <xref:System.Diagnostics.ActivityIdFormat.Hierarchical> среда .NET использует настраиваемый заголовок HTTP request-id для передачи идентификатора. В отличие от многих других языковых сред выполнения встроенные библиотеки .NET, такие как веб-сервер ASP.NET и System.Net.Http, изначально могут декодировать и кодировать идентификаторы действий в сообщениях HTTP. Среда выполнения также понимает способ передачи идентификатора через синхронные и асинхронные вызовы. Это означает, что приложения .NET, которые получают и выдают сообщения HTTP, автоматически участвуют в передаче идентификаторов распределенной трассировки без написания специального кода разработчиком приложения или зависимостей сторонних библиотек. Сторонние библиотеки могут добавлять поддержку для передачи идентификаторов по протоколам обмена сообщениями, отличным от HTTP, или поддерживать пользовательские соглашения о кодировании для HTTP.

### <a name="collecting-traces"></a>Сбор трассировок

Инструментированный код может создавать объекты <xref:System.Diagnostics.Activity> в рамках распределенной трассировки, но информация в этих объектах должна быть передана и сериализована в централизованное постоянное хранилище, чтобы позднее можно было просмотреть всю трассировку. Существует несколько библиотек сбора данных телеметрии, способных выполнить эту задачу, например [Application Insights](https://docs.microsoft.com/azure/azure-monitor/app/distributed-tracing), [OpenTelemetry](https://github.com/open-telemetry/opentelemetry-dotnet/blob/main/docs/trace/getting-started/README.md) или библиотека, предоставляемая сторонним поставщиком телеметрии или APM. Кроме того, разработчики могут создавать собственные настраиваемые системы сбора данных телеметрии с использованием <xref:System.Diagnostics.ActivityListener?displayProperty=nameWithType> или <xref:System.Diagnostics.DiagnosticListener?displayProperty=nameWithType>. ActivityListener поддерживает наблюдение за любым действием, независимо от того, есть ли у разработчика какие-либо предварительные знания о нем.
Это делает ActivityListener простым и гибким решением общего назначения. Напротив, использование DiagnosticListener является более сложным сценарием, который требует, чтобы инструментированный код явно запрашивался вызовом, <xref:System.Diagnostics.DiagnosticSource.StartActivity%2A?displayProperty=nameWithType> а библиотеке сбора необходимо располагать точной информацией об именовании, используемой инструментированным кодом при ее запуске. Использование DiagnosticSource и DiagnosticListener позволяет создателю и прослушивателю обмениваться произвольными объектами .NET и устанавливать настраиваемые соглашения о передаче данных.

### <a name="sampling"></a>Дискретизация

Для повышения производительности в приложениях с высокой пропускной способностью распределенная трассировка на платформе .NET поддерживает выборку только подмножества трассировок вместо записи их всех. Для действий, созданных с помощью рекомендуемого API <xref:System.Diagnostics.ActivitySource.StartActivity%2A?displayProperty=nameWithType>, библиотеки сбора данных телеметрии могут управлять выборкой с помощью обратного вызова <xref:System.Diagnostics.ActivityListener.Sample%2A?displayProperty=nameWithType>.
Библиотека ведения журнала может не создавать никакого действия, создать его с минимальными сведениями, необходимыми для распространения идентификаторов распределенной трассировки, либо заполнить его полными диагностическими сведениями. Эти варианты повышают диагностическую значимость за счет увеличения объема служебных данных и снижения производительности. Действия, запускаемые с использованием устаревшего шаблона вызова <xref:System.Diagnostics.Activity.%23ctor%2A?displayProperty=nameWithType> и <xref:System.Diagnostics.DiagnosticSource.StartActivity%2A?displayProperty=nameWithType>, могут также поддерживать выборку DiagnosticListener путем первичного вызова <xref:System.Diagnostics.DiagnosticSource.IsEnabled%2A?displayProperty=nameWithType>.
Даже при сборе полной диагностической информации реализация .NET имеет высокое быстродействие — при использовании эффективного сборщика и на современном оборудовании действие может быть создано, заполнено и передано за одну микросекунду. Выборка может снизить временные затраты на инструментирование до менее чем 100 наносекунд для каждого действия, которое не записывается.

## <a name="next-steps"></a>Дальнейшие действия

Пример кода для начала работы с распределенной трассировкой в приложениях .NET см. в разделе [Обзор распределенной трассировки](distributed-tracing.md).
