---
title: Концепции распределенной трассировки — .NET
description: Концепции распределенной трассировки .NET
ms.date: 03/14/2021
ms.openlocfilehash: 368cb545b9928534766e3005992a7a55571b8dcc
ms.sourcegitcommit: e16315d9f1ff355f55ff8ab84a28915be0a8e42b
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/25/2021
ms.locfileid: "105111516"
---
# <a name="net-distributed-tracing-concepts"></a><span data-ttu-id="1b6c7-103">Концепции распределенной трассировки .NET</span><span class="sxs-lookup"><span data-stu-id="1b6c7-103">.NET Distributed Tracing Concepts</span></span>

<span data-ttu-id="1b6c7-104">Распределенная трассировка — это диагностическая методика, помогающая инженерам локализовать сбои и проблемы с производительностью в приложениях, особенно те, которые могут охватывать несколько компьютеров или процессов.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-104">Distributed tracing is a diagnostic technique that helps engineers localize failures and performance issues within applications, especially those that may be distributed across multiple machines or processes.</span></span> <span data-ttu-id="1b6c7-105">Общие сведения о том, где можно использовать распределенную трассировку, и примеры кода для начала работы см. в разделе [Обзор распределенной трассировки](distributed-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="1b6c7-105">See the [Distributed Tracing Overview](distributed-tracing.md) for general information about where distributed tracing is useful and example code to get started.</span></span>

### <a name="traces-and-activities"></a><span data-ttu-id="1b6c7-106">Трассировки и действия</span><span class="sxs-lookup"><span data-stu-id="1b6c7-106">Traces and Activities</span></span>

<span data-ttu-id="1b6c7-107">Каждый раз, когда приложение получает новый запрос, его можно связать с трассировкой.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-107">Each time a new request is received by an application it can be associated with a trace.</span></span> <span data-ttu-id="1b6c7-108">В компонентах приложений, написанных на .NET, единицы работы в трассировке представлены экземплярами <xref:System.Diagnostics.Activity?displayProperty=nameWithType>, а трассировка в целом образует дерево этих действий, которое может охватывать множество различных процессов.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-108">In application components written in .NET, units of work in a trace are represented by instances of <xref:System.Diagnostics.Activity?displayProperty=nameWithType> and the trace as a whole forms a tree of these Activities, potentially spanning across many distinct processes.</span></span> <span data-ttu-id="1b6c7-109">Первое действие, созданное для нового запроса, образует корень дерева трассировки и отслеживает общую длительность и успех или неудачу обработки запроса.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-109">The first Activity created for a new request forms the root of the trace tree and it tracks the overall duration and success/failure handling the request.</span></span> <span data-ttu-id="1b6c7-110">При необходимости можно создавать дочерние действия, чтобы разделить работу на шаги, которые можно отслеживать по отдельности.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-110">Child activities can be optionally created to sub-divide the work into different steps that can be tracked individually.</span></span>
<span data-ttu-id="1b6c7-111">Например, для действия, отслеживающего конкретный входящий HTTP-запрос на веб-сервере, можно создать дочерние действия отслеживания каждого запроса к базе данных, потребовавшегося для выполнения запроса.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-111">For example given an Activity that tracked a specific inbound HTTP request in a web server, child activites could be created to track each of the database queries that were necessary to complete the request.</span></span> <span data-ttu-id="1b6c7-112">Это позволяет независимо регистрировать длительность и успешность каждого запроса.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-112">This allows the duration and success for each query to be recorded independently.</span></span>
<span data-ttu-id="1b6c7-113">Действия могут записывать другие сведения для каждой единицы работы, например <xref:System.Diagnostics.Activity.OperationName>, пары "имя — значение" (<xref:System.Diagnostics.Activity.Tags>) и <xref:System.Diagnostics.Activity.Events>.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-113">Activities can record other information for each unit of work such as <xref:System.Diagnostics.Activity.OperationName>, name-value pairs called <xref:System.Diagnostics.Activity.Tags>, and <xref:System.Diagnostics.Activity.Events>.</span></span> <span data-ttu-id="1b6c7-114">Имя определяет тип выполняемой работы, теги могут записывать описательные параметры работы, а события представляют собой простой механизм ведения журнала для регистрации диагностических сообщений с метками времени.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-114">The name identifies the type of work being performed, tags can record descriptive parameters of the work, and events are a simple logging mechanism to record timestamped diagnostic messages.</span></span>

> [!NOTE]
> <span data-ttu-id="1b6c7-115">Другое распространенное отраслевое название для единиц работы в распределенной трассировке — рабочие интервалы.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-115">Another common industry name for units of work in a distributed trace are 'Spans'.</span></span>
> <span data-ttu-id="1b6c7-116">За много лет до того, как для этой концепции закрепилось название "рабочий интервал", в среде .NET применялся термин "действие".</span><span class="sxs-lookup"><span data-stu-id="1b6c7-116">.NET adopted the term 'Activity' many years ago, before the name 'Span' was well established for this concept.</span></span>

### <a name="activity-ids"></a><span data-ttu-id="1b6c7-117">ИД действий</span><span class="sxs-lookup"><span data-stu-id="1b6c7-117">Activity IDs</span></span>

<span data-ttu-id="1b6c7-118">Связи "родитель — потомок" между действиями в дереве распределенной трассировки устанавливаются с помощью уникальных идентификаторов.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-118">Parent-Child relationships between Activities in the distributed trace tree are established using unique IDs.</span></span> <span data-ttu-id="1b6c7-119">Реализация распределенной трассировки в .NET поддерживает две схемы идентификаторов: стандарт [TraceContext](https://www.w3.org/TR/trace-context/) консорциума W3C, используемый по умолчанию в .NET 5, и более старое соглашение .NET, именуемое иерархическим, которое доступно для обеспечения обратной совместимости.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-119">.NET's implementation of distributed tracing supports two ID schemes, the W3C standard [TraceContext](https://www.w3.org/TR/trace-context/) which is the default in .NET 5 and an older .NET convention called 'Hierarchical' that is available for backwards compatibility.</span></span>
<span data-ttu-id="1b6c7-120"><xref:System.Diagnostics.Activity.DefaultIdFormat?displayProperty=nameWithType> определяет, какая схема идентификаторов используется.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-120"><xref:System.Diagnostics.Activity.DefaultIdFormat?displayProperty=nameWithType> controls which ID scheme is used.</span></span> <span data-ttu-id="1b6c7-121">В стандарте TraceContext консорциума W3C каждой трассировке присваивается глобально уникальный 16-байтный идентификатор трассировки (<xref:System.Diagnostics.Activity.TraceId?displayProperty=nameWithType>), а каждому действию внутри трассировки присваивается уникальный 8-байтный идентификатор рабочего интервала (<xref:System.Diagnostics.Activity.SpanId?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="1b6c7-121">In the W3C TraceContext standard every trace is assigned a globally unique 16 byte trace-id (<xref:System.Diagnostics.Activity.TraceId?displayProperty=nameWithType>) and every Activity within the trace is assigned a unique 8 byte span-id (<xref:System.Diagnostics.Activity.SpanId?displayProperty=nameWithType>).</span></span> <span data-ttu-id="1b6c7-122">Каждое действие регистрирует идентификатор трассировки, собственный идентификатор рабочего интервала и идентификатор рабочего интервала своего родительского объекта (<xref:System.Diagnostics.Activity.ParentSpanId?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="1b6c7-122">Each Activity records the trace-id, its own span-id, and the span-id of its parent (<xref:System.Diagnostics.Activity.ParentSpanId?displayProperty=nameWithType>).</span></span> <span data-ttu-id="1b6c7-123">Так как распределенные трассировки могут отслеживать работу между границами процессов, родительские и дочерние действия могут не находиться в одном процессе.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-123">Because distributed traces can track work across process boundaries parent and child Activities may not be in the same process.</span></span> <span data-ttu-id="1b6c7-124">Сочетание идентификатора трассировки и идентификатора рабочего интервала родительского объекта позволяет однозначно идентифицировать родительское действие на глобальном уровне, независимо от того, в каком процессе оно находится.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-124">The combination of a trace-id and parent span-id can uniquely identify the parent Activity globally, regardless of what process it resides in.</span></span>

<span data-ttu-id="1b6c7-125"><xref:System.Diagnostics.Activity.DefaultIdFormat?displayProperty=nameWithType> определяет, какой формат идентификатора используется для запуска новых трассировок, но по умолчанию при добавлении нового действия в существующую трассировку используется формат, используемый родительским действием.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-125"><xref:System.Diagnostics.Activity.DefaultIdFormat?displayProperty=nameWithType> controls which ID format is used for starting new traces, but by default adding a new Activity to an existing trace uses whatever format the parent Activity is using.</span></span>
<span data-ttu-id="1b6c7-126">Установка для <xref:System.Diagnostics.Activity.ForceDefaultIdFormat?displayProperty=nameWithType> значения true переопределяет это поведение и обеспечивает создание всех действий с DefaultIdFormat, даже если родительский объект использует другой формат идентификатора.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-126">Setting <xref:System.Diagnostics.Activity.ForceDefaultIdFormat?displayProperty=nameWithType> to true overrides this behavior and creates all new Activities with the DefaultIdFormat, even when the parent uses a different ID format.</span></span>

### <a name="starting-and-stopping-activities"></a><span data-ttu-id="1b6c7-127">Запуск и остановка действий</span><span class="sxs-lookup"><span data-stu-id="1b6c7-127">Starting and stopping Activities</span></span>

<span data-ttu-id="1b6c7-128">Каждый поток в процессе может иметь соответствующий объект действия, отслеживающий работу в этом потоке, доступ к которому осуществляется через <xref:System.Diagnostics.Activity.Current?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-128">Each thread in a process may have a corresponding Activity object that is tracking the work occuring on that thread, accessible via <xref:System.Diagnostics.Activity.Current?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1b6c7-129">Текущее действие автоматически проходит по всем синхронным вызовам в потоке, а также следующим асинхронным вызовам, которые обрабатываются в разных потоках.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-129">The current activity automatically flows along all synchronous calls on a thread as well as following async calls that are processed on different threads.</span></span> <span data-ttu-id="1b6c7-130">Если действие А является текущим в потоке и код запускает новое действие Б, то Б становится новым текущим действием в этом потоке.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-130">If Activity A is the current activity on a thread and code starts a new Activity B then B becomes the new current activity on that thread.</span></span> <span data-ttu-id="1b6c7-131">По умолчанию действие Б также расценивает действие А как свой родительский объект.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-131">By default activity B will also treat Activity A as its parent.</span></span> <span data-ttu-id="1b6c7-132">Если позднее действие Б остановлено, действие А будет восстановлено в качестве текущего действия в потоке.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-132">When Activity B is later stopped activity A will be restored as the current Activity on the thread.</span></span> <span data-ttu-id="1b6c7-133">При запуске действие фиксирует текущее время как <xref:System.Diagnostics.Activity.StartTimeUtc?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-133">When an Activity is started it captures the current time as the <xref:System.Diagnostics.Activity.StartTimeUtc?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1b6c7-134">При его остановке вычисляется <xref:System.Diagnostics.Activity.Duration?displayProperty=nameWithType> как разница между текущим временем и временем начала.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-134">When it stops <xref:System.Diagnostics.Activity.Duration?displayProperty=nameWithType> is calculated as the difference between the current time and the start time.</span></span>

### <a name="coordinating-across-process-boundaries"></a><span data-ttu-id="1b6c7-135">Координация между границами процессов</span><span class="sxs-lookup"><span data-stu-id="1b6c7-135">Coordinating across process boundaries</span></span>

<span data-ttu-id="1b6c7-136">Для отслеживания работы между границами процессов идентификаторы родительских действий должны передаваться по сети, чтобы принимающий процесс мог создавать ссылающиеся на них действия.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-136">In order to track work across process boundaries Activity parent IDs need to be transmitted across the network so that the receiving process can create Activities that refer to them.</span></span> <span data-ttu-id="1b6c7-137">При использовании формата идентификатора TraceContext консорциума W3C среда .NET также будет использовать заголовки HTTP, рекомендованные [этим стандартом](https://www.w3.org/TR/trace-context/), для передачи этих данных.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-137">When using W3C TraceContext ID format .NET will also use the HTTP headers recommended by [the standard](https://www.w3.org/TR/trace-context/) to transmit this information.</span></span> <span data-ttu-id="1b6c7-138">При использовании формата идентификатора <xref:System.Diagnostics.ActivityIdFormat.Hierarchical> среда .NET использует настраиваемый заголовок HTTP request-id для передачи идентификатора.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-138">When using the <xref:System.Diagnostics.ActivityIdFormat.Hierarchical> ID format .NET uses a custom request-id HTTP header to transmit the ID.</span></span> <span data-ttu-id="1b6c7-139">В отличие от многих других языковых сред выполнения встроенные библиотеки .NET, такие как веб-сервер ASP.NET и System.Net.Http, изначально могут декодировать и кодировать идентификаторы действий в сообщениях HTTP.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-139">Unlike many other language runtimes .NET in-box libraries such as the ASP.NET web server and System.Net.Http natively understand how to decode and encode Activity IDs on HTTP messages.</span></span> <span data-ttu-id="1b6c7-140">Среда выполнения также понимает способ передачи идентификатора через синхронные и асинхронные вызовы.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-140">The runtime also understands how to flow the ID through sychronous and asynchronous calls.</span></span> <span data-ttu-id="1b6c7-141">Это означает, что приложения .NET, которые получают и выдают сообщения HTTP, автоматически участвуют в передаче идентификаторов распределенной трассировки без написания специального кода разработчиком приложения или зависимостей сторонних библиотек.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-141">This means that .NET applications that receive and emit HTTP messages participate in flowing distributed trace IDs automatically, with no special coding by the app developer nor 3rd party library dependencies.</span></span> <span data-ttu-id="1b6c7-142">Сторонние библиотеки могут добавлять поддержку для передачи идентификаторов по протоколам обмена сообщениями, отличным от HTTP, или поддерживать пользовательские соглашения о кодировании для HTTP.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-142">3rd party libraries may add support for transmitting IDs over non-HTTP message protocols or supporting custom encoding conventions for HTTP.</span></span>

### <a name="collecting-traces"></a><span data-ttu-id="1b6c7-143">Сбор трассировок</span><span class="sxs-lookup"><span data-stu-id="1b6c7-143">Collecting traces</span></span>

<span data-ttu-id="1b6c7-144">Инструментированный код может создавать объекты <xref:System.Diagnostics.Activity> в рамках распределенной трассировки, но информация в этих объектах должна быть передана и сериализована в централизованное постоянное хранилище, чтобы позднее можно было просмотреть всю трассировку.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-144">Instrumented code can create <xref:System.Diagnostics.Activity> objects as part of a distributed trace, but the information in these objects needs to be transmitted and serialized in a centralized persistant store so that the entire trace can be usefully reviewed later.</span></span> <span data-ttu-id="1b6c7-145">Существует несколько библиотек сбора данных телеметрии, способных выполнить эту задачу, например [Application Insights](https://docs.microsoft.com/azure/azure-monitor/app/distributed-tracing), [OpenTelemetry](https://github.com/open-telemetry/opentelemetry-dotnet/blob/main/docs/trace/getting-started/README.md) или библиотека, предоставляемая сторонним поставщиком телеметрии или APM.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-145">There are several telemetry collection libraries that can do this task such as [Application Insights](https://docs.microsoft.com/azure/azure-monitor/app/distributed-tracing), [OpenTelemetry](https://github.com/open-telemetry/opentelemetry-dotnet/blob/main/docs/trace/getting-started/README.md), or a library provided by a 3rd party telemetry or APM vendor.</span></span> <span data-ttu-id="1b6c7-146">Кроме того, разработчики могут создавать собственные настраиваемые системы сбора данных телеметрии с использованием <xref:System.Diagnostics.ActivityListener?displayProperty=nameWithType> или <xref:System.Diagnostics.DiagnosticListener?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-146">Alternately developers can author their own custom Activity telemetry collection by using <xref:System.Diagnostics.ActivityListener?displayProperty=nameWithType> or <xref:System.Diagnostics.DiagnosticListener?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1b6c7-147">ActivityListener поддерживает наблюдение за любым действием, независимо от того, есть ли у разработчика какие-либо предварительные знания о нем.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-147">ActivityListener supports observing any Activity regardless whether the developer has any a-priori knowledge about it.</span></span>
<span data-ttu-id="1b6c7-148">Это делает ActivityListener простым и гибким решением общего назначения.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-148">This makes ActivityListener a simple and flexible general purpose solution.</span></span> <span data-ttu-id="1b6c7-149">Напротив, использование DiagnosticListener является более сложным сценарием, который требует, чтобы инструментированный код явно запрашивался вызовом, <xref:System.Diagnostics.DiagnosticSource.StartActivity%2A?displayProperty=nameWithType> а библиотеке сбора необходимо располагать точной информацией об именовании, используемой инструментированным кодом при ее запуске.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-149">By contrast using DiagnosticListener is a more complex scenario that requires the instrumented code to opt-in by invoking <xref:System.Diagnostics.DiagnosticSource.StartActivity%2A?displayProperty=nameWithType> and the collection library needs to know the exact naming information that the instrumented code used when starting it.</span></span> <span data-ttu-id="1b6c7-150">Использование DiagnosticSource и DiagnosticListener позволяет создателю и прослушивателю обмениваться произвольными объектами .NET и устанавливать настраиваемые соглашения о передаче данных.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-150">Using DiagnosticSource and DiagnosticListener allows the creator and listener to exchange arbitrary .NET objects and establish customized information passing conventions.</span></span>

### <a name="sampling"></a><span data-ttu-id="1b6c7-151">Дискретизация</span><span class="sxs-lookup"><span data-stu-id="1b6c7-151">Sampling</span></span>

<span data-ttu-id="1b6c7-152">Для повышения производительности в приложениях с высокой пропускной способностью распределенная трассировка на платформе .NET поддерживает выборку только подмножества трассировок вместо записи их всех.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-152">For improved performance in high throughput applications, distributed tracing on .NET supports sampling only a subset of traces rather than recording all of them.</span></span> <span data-ttu-id="1b6c7-153">Для действий, созданных с помощью рекомендуемого API <xref:System.Diagnostics.ActivitySource.StartActivity%2A?displayProperty=nameWithType>, библиотеки сбора данных телеметрии могут управлять выборкой с помощью обратного вызова <xref:System.Diagnostics.ActivityListener.Sample%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-153">For activites created with the recommended <xref:System.Diagnostics.ActivitySource.StartActivity%2A?displayProperty=nameWithType> API, telemetry collection libraries can control sampling with the <xref:System.Diagnostics.ActivityListener.Sample%2A?displayProperty=nameWithType> callback.</span></span>
<span data-ttu-id="1b6c7-154">Библиотека ведения журнала может не создавать никакого действия, создать его с минимальными сведениями, необходимыми для распространения идентификаторов распределенной трассировки, либо заполнить его полными диагностическими сведениями.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-154">The logging library can elect not to create the Activity at all, to create it with minimal information necessary to propagate distributing tracing IDs, or to populate it with complete diagnostic information.</span></span> <span data-ttu-id="1b6c7-155">Эти варианты повышают диагностическую значимость за счет увеличения объема служебных данных и снижения производительности.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-155">These choices trade-off increasing performance overhead for increasing diagnostic utility.</span></span> <span data-ttu-id="1b6c7-156">Действия, запускаемые с использованием устаревшего шаблона вызова <xref:System.Diagnostics.Activity.%23ctor%2A?displayProperty=nameWithType> и <xref:System.Diagnostics.DiagnosticSource.StartActivity%2A?displayProperty=nameWithType>, могут также поддерживать выборку DiagnosticListener путем первичного вызова <xref:System.Diagnostics.DiagnosticSource.IsEnabled%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-156">Activities that are started using the older pattern of invoking <xref:System.Diagnostics.Activity.%23ctor%2A?displayProperty=nameWithType> and <xref:System.Diagnostics.DiagnosticSource.StartActivity%2A?displayProperty=nameWithType> may also support DiagnosticListener sampling by first calling <xref:System.Diagnostics.DiagnosticSource.IsEnabled%2A?displayProperty=nameWithType>.</span></span>
<span data-ttu-id="1b6c7-157">Даже при сборе полной диагностической информации реализация .NET имеет высокое быстродействие — при использовании эффективного сборщика и на современном оборудовании действие может быть создано, заполнено и передано за одну микросекунду.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-157">Even when capturing full diagnostic information the .NET implementation is designed to be fast - coupled with an efficient collector an Activity can be created, populated, and transmitted in about a microsecond on modern hardware.</span></span> <span data-ttu-id="1b6c7-158">Выборка может снизить временные затраты на инструментирование до менее чем 100 наносекунд для каждого действия, которое не записывается.</span><span class="sxs-lookup"><span data-stu-id="1b6c7-158">Sampling can reduce the instrumentation cost to less than 100 nanoseconds for each Activity that isn't recorded.</span></span>

## <a name="next-steps"></a><span data-ttu-id="1b6c7-159">Дальнейшие действия</span><span class="sxs-lookup"><span data-stu-id="1b6c7-159">Next steps</span></span>

<span data-ttu-id="1b6c7-160">Пример кода для начала работы с распределенной трассировкой в приложениях .NET см. в разделе [Обзор распределенной трассировки](distributed-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="1b6c7-160">See the [Distributed Tracing Overview](distributed-tracing.md) for example code to get started using distributed tracing in .NET applications.</span></span>
