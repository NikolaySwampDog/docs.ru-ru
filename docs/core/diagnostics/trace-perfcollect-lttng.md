---
title: Трассировка приложений .NET с помощью PerfCollect.
description: Руководство по сбору трассировки с помощью PerfCollect в .NET.
ms.topic: tutorial
ms.date: 10/23/2020
ms.openlocfilehash: 20e1bf56714fb32b5231d45b0ba35cdfcedaea2e
ms.sourcegitcommit: e3cf8227573e13b8e1f4e3dc007404881cdafe47
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/11/2021
ms.locfileid: "103189934"
---
# <a name="trace-net-applications-with-perfcollect"></a>Трассировка приложений .NET с помощью PerfCollect

**Эта статья относится к:** ✔️ пакету SDK для .NET Core 2.1 и более поздних версий

При возникновении проблем с производительностью в Linux сбор данных трассировки с `perfcollect` можно использовать для получения подробных сведений о том, что произошло на компьютере, когда возникла проблема с производительностью.

`perfcollect` — это скрипт Bash, использующий [Linux Tracing Tookit-Next Generation (LTTng)](https://lttng.org) для сбора событий, записываемых из среды выполнения, или [EventSource](xref:System.Diagnostics.Tracing.EventListener), а также [perf](https://perf.wiki.kernel.org/) для сбора образцов ЦП целевого процесса.

## <a name="prepare-your-machine"></a>Подготовка компьютера

Выполните следующие действия, чтобы подготовить компьютер к собранию трассировки производительности с `perfcollect`.

> [!NOTE]
> В среде контейнера у контейнера должно быть разрешение `SYS_ADMIN`. Дополнительные сведения о трассировке приложений в контейнерах с помощью PerfCollect см. в разделе [Сбор диагностики в контейнерах](./diagnostics-in-containers.md).

1. Загрузите `perfcollect`.

    > ```bash
    > curl -OL https://aka.ms/perfcollect
    > ```

2. Сделайте файл скрипта исполняемым.

    > ```bash
    > chmod +x perfcollect
    > ```

3. Установите необходимые компоненты для трассировки — фактические библиотеки трассировки.

    > ```bash
    > sudo ./perfcollect install
    > ```

    На компьютере будут установлены следующие необходимые компоненты:

    1. `perf`: подсистема событий производительности Linux и сопутствующее приложение для сбора и просмотра в пользовательском режиме. `perf` является частью источника ядра Linux, но обычно не устанавливается по умолчанию.

    2. `LTTng`: используется для записи данных событий, возникших во время выполнения CoreCLR. Эти данные затем используются для анализа поведения различных компонентов среды выполнения, таких как GC, JIT и пул потоков.

Последние версии .NET Core и средство производительности Linux поддерживают автоматическое разрешение имен методов для кода платформы. Если вы работаете с .NET Core версии 3.1 или более ранней, потребуется дополнительный шаг. Дополнительные сведения см. в разделе [Разрешение символов платформы](#resolve-framework-symbols).

Для разрешения имен методов в собственных библиотеках DLL времени выполнения (например, libcoreclr.so) `perfcollect` будет разрешать символы при преобразовании данных, но только в том случае, если символы для этих двоичных файлов существуют. Дополнительные сведения см. в разделе [Получение символов для собственной среды выполнения](#get-symbols-for-the-native-runtime).

## <a name="collect-a-trace"></a>Сбор трассировки

1. Понадобится две оболочки: одна для управления трассировкой, или **[Trace]** , и одна для запуска приложения, или **[App]** .

2. **[Trace]** Запустите сбор.

    > ```bash
    > sudo ./perfcollect collect sampleTrace
    > ```

    Ожидаемые выходные данные:

    > ```bash
    > Collection started.  Press CTRL+C to stop.
    > ```

3. **[App]** Настройте оболочку приложения со следующими переменными среды — это позволяет отслеживать конфигурацию CoreCLR.

    > ```bash
    > export COMPlus_PerfMapEnabled=1
    > export COMPlus_EnableEventLog=1
    > ```

4. **[App]** Запустите приложение. Пусть оно выполняется до тех пор, пока вы не соберете данные о проблеме с производительностью. Приложение должно выполняться столько, сколько это необходимо для захвата периода, когда возникла соответствующая проблема с производительностью.

    > ```bash
    > dotnet run
    > ```

5. **[Trace]** Прекратите сбор, нажав клавиши CTRL+C.

    > ```bash
    > ^C
    > ...STOPPED.
    >
    > Starting post-processing. This may take some time.
    >
    > Generating native image symbol files
    > ...SKIPPED
    > Saving native symbols
    > ...FINISHED
    > Exporting perf.data file
    > ...FINISHED
    > Compressing trace files
    > ...FINISHED
    > Cleaning up artifacts
    > ...FINISHED
    >
    > Trace saved to sampleTrace.trace.zip
    > ```

    Сжатый файл трассировки теперь хранится в текущем рабочем каталоге.

## <a name="view-a-trace"></a>Просмотр трассировки

Существует несколько вариантов просмотра собранных данных трассировки. Удобнее всего просматривать трассировки с помощью [PerfView](https://aka.ms/perfview) в Windows, но их можно просматривать непосредственно в Linux с помощью `PerfCollect` или `TraceCompass`.

### <a name="use-perfcollect-to-view-the-trace-file"></a>Использование PerfCollect для просмотра файла трассировки

Для просмотра собранной трассировки можно использовать PerfCollect. Для этого воспользуйтесь следующей командой:

```bash
./perfcollect view sampleTrace.trace.zip
```

По умолчанию при этом отображается трассировка ЦП приложения с помощью `perf`.

Чтобы изучить события, собранные с помощью `LTTng`, можно передать флаг `-viewer lttng` и просмотреть отдельные события:

```bash
./perfcollect view sampleTrace.trace.zip -viewer lttng
```

Для вывода полезных данных событий будет использоваться средство просмотра `babeltrace`:

```bash
# [01:02:18.189217659] (+0.020132603) ubuntu-xenial DotNETRuntime:ExceptionThrown_V1: { cpu_id = 0 }, { ExceptionType = "System.Exception", ExceptionMessage = "An exception happened", ExceptionEIP = 139875671834775, ExceptionHRESULT = 2148734208, ExceptionFlags = 16, ClrInstanceID = 0 }
# [01:02:18.189250227] (+0.020165171) ubuntu-xenial DotNETRuntime:ExceptionCatchStart: { cpu_id = 0 }, { EntryEIP = 139873639728404, MethodID = 139873626968120, MethodName = "void [helloworld] helloworld.Program::Main(string[])", ClrInstanceID = 0 }
```

### <a name="use-perfview-to-open-the-trace-file"></a>Открытие файла трассировки с помощью PerfView

Чтобы просмотреть общее представление примера ЦП и событий, можно использовать `PerfView` на компьютере Windows.

1. Скопируйте файл trace.zip из Linux на компьютер Windows.

2. Скачайте PerfView с <https://aka.ms/perfview>.

3. Запуск PerfView.exe

    > ```cmd
    > PerfView.exe <path to trace.zip file>
    > ```

PerfView будет отображать список поддерживаемых представлений в зависимости от данных, содержащихся в файле трассировки.

- Для изучения ресурсов ЦП выберите **CPU stacks**.

- Для получения подробных сведений о сборке мусора выберите **GCStats**.

- Чтобы получить сведения о JIT для каждого процесса, модуля или метода, выберите **JITStats**.

- Если представления для необходимой информации нет, можно попробовать найти события в представлении необработанных событий.  Выберите **События**.

Дополнительные сведения о том, как интерпретировать представления в PerfView, нажмите на ссылку справки в самом представлении или в главном окне PerfView выберите **Справка-> Руководство пользователя**.

> [!NOTE]
> События, записанные через API <xref:System.Diagnostics.Tracing.EventSource?displayProperty=nameWithType> (включая события из Framework), не будут включать данные об имени поставщика. Они записываются как события `EventSourceEvent` от поставщика `Microsoft-Windows-DotNETRuntime`, а для их полезных данных выполняется сериализация в формате JSON.

### <a name="use-tracecompass-to-open-the-trace-file"></a>Открытие файла трассировки с помощью TraceCompass

[Eclipse TraceCompass](https://www.eclipse.org/tracecompass/) — это еще один вариант, который можно использовать для просмотра трассировок. `TraceCompass` работает на компьютерах Linux, поэтому вам не нужно перемещать трассировку на компьютер Windows. Чтобы открыть файл трассировки с помощью `TraceCompass`, необходимо распаковать его.

```bash
unzip myTrace.trace.zip
```

`perfcollect` сохранит записанную трассировку LTTng в формате файла CTF в подкаталоге в `lttngTrace`. В частности, файл CTF будет находиться в аналогичном каталоге: `lttngTrace/auto-20201025-101230\ust\uid\1000\64-bit\`.

Вы можете открыть файл трассировки CTF в `TraceCompass`, выбрав `File -> Open Trace` и файл `metadata`.

Подробности см. в [документации по `TraceCompass`](https://www.eclipse.org/tracecompass/).

## <a name="resolve-framework-symbols"></a>Разрешение символов платформы

Символы платформы должны создаваться вручную во время сбора трассировки. Они отличаются от символов на уровне приложения, так как платформа предварительно компилируется во время JIT-компиляции кода приложения. Для кода платформы, предварительно скомпилированного в машинный код, необходимо вызвать `crossgen`, который знает, как создать сопоставление из машинного кода с именами методов.

`perfcollect` может обработать большую часть сведений автоматически, но требуется `crossgen`. По умолчанию он не устанавливается вместе с дистрибутивом .NET. Если `crossgen` отсутствует, `perfcollect` выдает предупреждение и ссылается на эти инструкции. Чтобы устранить эту проблему, необходимо получить нужную версию crossgen для используемой среды выполнения. Если вы поместите инструмент crossgen в тот же каталог, что и библиотеки DLL среды выполнения .NET (например, libcoreclr.so), `perfcollect` может найти его и добавить символы платформы в файл трассировки.

Обычно при создании приложения .NET оно просто создает библиотеку DLL для написанного кода, используя общую копию среды выполнения для остального.   Однако вы также можете создать так называемую "автономную" версию приложения, которая содержит все библиотеки DLL среды выполнения. `crossgen` является частью пакета NuGet, который используется для создания автономных приложений, поэтому один из способов получить правильную версию `crossgen` — создать автономный пакет приложения.

Пример:

   >```bash
   > mkdir helloWorld
   > cd helloWorld
   > dotnet new console
   > dotnet publish --self-contained -r linux-x64
   >```

В результате будет создано новое приложение Hello World, собранное как автономное приложение.

В качестве побочного эффекта создания автономного приложения средство DotNet загрузит пакет NuGet с именем runtime.linux-x64.microsoft.netcore.app и поместит его в каталог ~/.nuget/packages/runtime.linux-x64.microsoft.netcore.app/VERSION, где VERSION — номер версии среды выполнения .NET Core (например, 2.1.0). Здесь находится каталог средств, в котором расположен нужный вам инструмент crossgen. Начиная с .NET Core 3.0 пакет расположен в папке ~/.nuget/packages/microsoft.netcore.app.runtime.linux-x64/VERSION.

Средство `crossgen` необходимо разместить рядом со средой выполнения, которая фактически используется приложением. Обычно приложение использует общую версию .NET Core, установленную в папке /usr/share/dotnet/shared/Microsoft.NETCore.App/VERSION, где VERSION — это номер версии среды выполнения .NET. Это общее расположение, поэтому для его изменения необходимо иметь права суперпользователя. Если VERSION имеет значение 2.1.0, команды для обновления `crossgen` будут выглядеть следующим образом:

   >```bash
   > sudo bash
   > cp ~/.nuget/packages/runtime.linux-x64.microsoft.netcore.app/2.1.0/tools/crossgen /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0
   >```

После этого `perfcollect` будет использовать crossgen для включения символов платформы. Предупреждение, которое раньше выдавалось `perfcollect`, исчезнет. Это необходимо сделать только один раз для каждого компьютера (пока не будет обновлена среда выполнения).

### <a name="alternative-turn-off-use-of-precompiled-code"></a>Альтернатива: отключить использование предварительно скомпилированного кода

Если у вас нет возможности обновить среду выполнения .NET (для добавления `crossgen`) или если описанная выше процедура по какой-то причине не сработала, существует другой подход к получению символов платформы. Укажите, что среда выполнения не должна использовать предварительно скомпилированный код платформы. Для кода будет использоваться JIT-компиляция, а `crossgen` не потребуется.

> [!NOTE]
> Этот подход может увеличить время запуска приложения.

Для этого можно добавить следующую переменную среды:

```bash
export COMPlus_ZapDisable=1
```

После этого изменения вы получите символы для всего кода .NET.

## <a name="get-symbols-for-the-native-runtime"></a>Получение символов для собственной среды выполнения

В большинстве случаев вы заинтересованы в своем коде, который `perfcollect` разрешает по умолчанию. Иногда бывает полезно понять, что происходит внутри библиотек DLL .NET (как указано в последнем разделе), но иногда интересно узнать, что происходит в библиотеках собственной среды выполнения (обычно это libcoreclr.so).  `perfcollect` будет разрешать символы при преобразовании данных, но только если символы для этих собственных библиотек DLL присутствуют (и находятся рядом с библиотекой, для которой они предназначены).

Для этого существует глобальная команда [dotnet-symbol](https://github.com/dotnet/symstore/blob/master/src/dotnet-symbol/README.md#symbol-downloader-dotnet-cli-extension). Чтобы использовать dotnet-symbol для получения собственных символов среды выполнения:

1. Установите `dotnet-symbol`:

    ```bash
    dotnet tool install -g dotnet-symbol
    ```

2. Скачайте символы. Если установлена версия среды выполнения .NET Core 2.1.0, выполните следующую команду:

    ```bash
    mkdir mySymbols
    dotnet symbol --symbols --output mySymbols  /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0/lib*.so
    ```

3. Скопируйте символы в правильное место.

    ```bash
    sudo cp mySymbols/* /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0
    ```

    Если это не удается сделать из-за отсутствия доступа на запись к соответствующему каталогу, можно использовать `perf buildid-cache` для добавления символов.

После этого необходимо получить символьные имена для собственных библиотек DLL при запуске `perfcollect`.

## <a name="collect-in-a-docker-container"></a>Сборка в контейнере Docker

Дополнительные сведения об использовании `perfcollect` в средах контейнеров см. в разделе [Сбор диагностики в контейнерах](./diagnostics-in-containers.md).

## <a name="learn-more-about-collection-options"></a>Подробнее о параметрах сбора

Можно указать следующие необязательные флаги с `perfcollect`, чтобы обеспечить более качественную диагностику.

### <a name="collect-for-a-specific-duration"></a>Сбор в течение определенного периода времени

Если требуется получить трассировку за определенное время, можно использовать параметр `-collectsec`, после которого следует число, указывающее общее количество секунд для получения трассировки.

### <a name="collect-threadtime-traces"></a>Получение трассировок времени потока

Указав `-threadtime` с `perfcollect`, можно получить данные об использовании ЦП для каждого потока. Это позволяет анализировать, на что каждый поток тратит время ЦП.

### <a name="collect-traces-for-managed-memory-and-garbage-collector-performance"></a>Сбор трассировок для управляемой памяти и производительности сборщика мусора

Следующие параметры позволяют специально собирать события сборки мусора из среды выполнения.

* `perfcollect collect -gccollectonly`

Сбор только минимального набора событий коллекции сборки мусора. Это наименее подробный профиль сбора коллекции сборки мусора с наименьшим влиянием на производительность целевого приложения. Эта команда аналогична команде `PerfView.exe /GCCollectOnly collect` в PerfView.

* `perfcollect collect -gconly`

Сбор более подробных событий коллекции сборки мусора с помощью JIT, загрузчика и событий исключений. Запрос более подробных событий (таких как сведения о выделении памяти и сведения о присоединении к сборке мусора), который влияет на производительность целевого приложения больше, чем вариант `-gccollectonly`. Эта команда аналогична команде `PerfView.exe /GCOnly collect` в PerfView.

* `perfcollect collect -gcwithheap`

Сбор самых подробных событий коллекции сбора мусора, а также отслеживание выживания и перемещения кучи. Это позволяет выполнить подробный анализ поведения сборки мусора, но при этом обеспечивает высокую производительность, поскольку длительность каждой сборки мусора может оказаться больше чем в два раза. Следует понимать влияние этого варианта трассировки на производительность при трассировке в рабочей среде.
