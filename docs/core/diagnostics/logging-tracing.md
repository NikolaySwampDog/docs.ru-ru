---
title: Ведение журнала и трассировка (.NET Core)
description: Общие сведения о ведении журнала и трассировке в .NET Core.
ms.date: 10/12/2020
ms.openlocfilehash: dfecdad4518c79b605eb4fbe991af07fcba7db1c
ms.sourcegitcommit: e16315d9f1ff355f55ff8ab84a28915be0a8e42b
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/25/2021
ms.locfileid: "105111092"
---
# <a name="net-core-logging-and-tracing"></a>Ведение журнала и трассировка в .NET Core

Термины "ведение журнала" и "трассировка" по сути обозначают одну и ту же методику. Этот простой метод отладки появился одновременно с первыми компьютерами. Он подразумевает создание в приложении средств для сохранения выходных данных, которые будут использоваться позднее.

## <a name="reasons-to-use-logging-and-tracing"></a>Причины для трассировки и ведения журнала

Этот простой прием является удивительно эффективным. Его можно использовать в ситуациях, с которыми не справляется отладчик.

- Проблемы, возникающие в течение длительного периода, часто трудно устранять в традиционном отладчике. Журналы позволяют выполнять подробный анализ после проявления проблем, накопившихся за длительный период. В отладчиках, напротив, доступен лишь анализ в режиме реального времени.
- Многопоточные приложения и распределенные приложения часто трудно отлаживать.  Присоединение отладчика часто изменяет поведение приложения. Подробные журналы можно изучать по мере необходимости для анализа сложных систем.
- Проблемы в распределенных приложениях могут возникать из-за сложностей взаимодействия между многими компонентами, а подключение отладчика к каждой части системы неоправданно усложняет процесс.
- Многие службы нельзя останавливать. Присоединение отладчика часто приводит к превышению времени ожидания.
- Проблемы не всегда удается прогнозировать. Ведение журнала и трассировка создают очень низкую нагрузку, поэтому программы будут сохранять данные даже при возникновении проблемы.

## <a name="net-core-apis"></a>API-интерфейсы для .NET Core

### <a name="print-style-apis"></a>API стиля печати

Классы <xref:System.Console?displayProperty=nameWithType>, <xref:System.Diagnostics.Trace?displayProperty=nameWithType> и <xref:System.Diagnostics.Debug?displayProperty=nameWithType> предоставляют похожие API-интерфейсы стиля печати, удобные для ведения журнала.

Вы можете выбрать любой из этих API стиля печати. Основные отличия указаны далее.

- <xref:System.Console?displayProperty=nameWithType>
  - Всегда включен и всегда записывает данные в консоль.
  - Полезно для сведений, которые могут потребоваться клиенту для просмотра в выпуске.
  - Это самый простой подход. Он часто используется для краткосрочных и непредвиденных действий по отладке. Такой код отладки часто даже не попадает в систему управления версиями.
- <xref:System.Diagnostics.Trace?displayProperty=nameWithType>
  - Включается только в том случае, если `TRACE` определяется путем добавления `#define TRACE` в источник или указания параметра `/d:TRACE` при компиляции.
  - Записывает данные в присоединенные прослушиватели (<xref:System.Diagnostics.Trace.Listeners>, по умолчанию это <xref:System.Diagnostics.DefaultTraceListener>).
  - Используйте этот API при создании журналов, которые будут включены в большинстве сборок.
- <xref:System.Diagnostics.Debug?displayProperty=nameWithType>
  - Включается только в том случае, если `DEBUG` определяется путем добавления `#define DEBUG` в источник или указания параметра `/d:DEBUG` при компиляции.
  - Передает данные в присоединенный отладчик.
  - В системах `*nix` ведет запись в stderr, если задан параметр `COMPlus_DebugWriteToStdErr`.
  - Используйте этот API при создании журналов, которые будут включены только в сборках отладки.

### <a name="logging-events"></a>События ведения журнала

Следующие API-интерфейсы больше ориентированы на события. Они сохраняют в журнал не простые строки текста, а целые объекты событий.

- <xref:System.Diagnostics.Tracing.EventSource?displayProperty=nameWithType>
  - EventSource является основным корневым API для трассировки в .NET Core.
  - Доступен во всех стандартных версиях .NET Standard.
  - Поддерживает трассировку только сериализуемых объектов.
  - Можно использовать в процессе через любые экземпляры [EventListener](xref:System.Diagnostics.Tracing.EventListener), настроенные для использования EventSource.
  - Можно использовать вне процесса через:
    - [EventPipe из .NET Core](./eventpipe.md) на всех платформах.
    - [Трассировка событий Windows (ETW).](/windows/win32/etw/event-tracing-portal)
    - [Платформа трассировки LTTng для Linux.](https://lttng.org/)
      - Пошаговое руководство. [Сбор трассировки LTTng с помощью PerfCollect](trace-perfcollect-lttng.md).

- <xref:System.Diagnostics.DiagnosticSource?displayProperty=nameWithType>
  - Предоставляется в составе .NET Core и в отдельном [пакете NuGet](https://www.nuget.org/packages/System.Diagnostics.DiagnosticSource) для .NET Framework.
  - Позволяет выполнять внутрипроцессную трассировку для несериализуемых объектов.
  - Содержит мост, который поддерживает сохранение выбранных полей регистрируемых объектов в <xref:System.Diagnostics.Tracing.EventSource>.

- <xref:System.Diagnostics.EventLog?displayProperty=nameWithType>
  - Только для Windows.
  - Сохраняет сообщения в журнал событий Windows.
  - Системные администраторы ожидают, что сообщения об ошибках, приводящих к сбоям приложений, будут отображаться в журнале событий Windows.

## <a name="distributed-tracing"></a>Распределенная трассировка

[Распределенная трассировка](./distributed-tracing.md) — это диагностическая методика, помогающая инженерам локализовать сбои и проблемы с производительностью в приложениях, особенно те, которые могут охватывать несколько компьютеров или процессов. Эта методика отслеживает запросы через приложение, сопоставляя работу различных компонентов приложения и отделяя ее от другой работы, которую приложение может выполнять для параллельных запросов.

## <a name="ilogger-and-logging-frameworks"></a>ILogger и платформы ведения журналов

Низкоуровневые API могут оказаться плохим вариантом для некоторых задач ведения журнала. Возможно, вам лучше подойдет платформа ведения журналов.

На основе интерфейса <xref:Microsoft.Extensions.Logging.ILogger> был создан единый интерфейс ведения журналов, который позволяет добавлять средства ведения журнала через внедрение зависимостей.

Например, .NET предоставляет поддержку большого числа встроенных и сторонних платформ, что позволяет вам правильно выбрать нужный вариант для своего приложения:

- [Встроенные поставщики ведения журналов .NET](../extensions/logging-providers.md#built-in-logging-providers)
- [Сторонние поставщики ведения журналов для .NET](../extensions/logging-providers.md#third-party-logging-providers)

## <a name="logging-related-references"></a>Справочные материалы по ведению журналов

- [Практическое руководство. Условная компиляция с использованием атрибутов Trace и Debug](../../framework/debug-trace-profile/how-to-compile-conditionally-with-trace-and-debug.md)

- [Практическое руководство. Добавление операторов трассировки в код приложения](../../framework/debug-trace-profile/how-to-add-trace-statements-to-application-code.md)

- Статья [о ведении журналов в .NET](../extensions/logging.md) содержит обзор поддерживаемых технологий ведения журналов.

- [Интерполяция строк в C#](../../csharp/language-reference/tokens/interpolated.md) помогает упростить создание кода для ведения журналов.

- [Список событий поставщика среды выполнения](../../fundamentals/diagnostics/runtime-events.md)

- [Стандартные поставщики событий в .NET](well-known-event-providers.md)

- Свойство <xref:System.Exception.Message?displayProperty=nameWithType> очень полезно для ведения журналов исключений.

- Класс <xref:System.Diagnostics.StackTrace?displayProperty=nameWithType> позволяет передать в журнал сведения о текущем состоянии стека.

## <a name="performance-considerations"></a>Вопросы производительности

Форматирование строк может создавать значительную нагрузку на ЦП.

В приложениях, для которых производительность критически важна, мы рекомендуем соблюдать следующие рекомендации:

- Не создавайте большой объем журналов, если их никто не проверяет. Не создавайте ресурсоемкие сообщения журнала, не проверив сначала, включено ли ведение журнала.
- Включайте в журнал только полезные сведения.
- Красивое форматирование отложите на этап анализа данных.
