---
title: Общие сведения об EventPipe
description: Узнайте об EventPipe и о том, как использовать его для трассировки приложений .NET для диагностики проблем с производительностью.
ms.date: 11/09/2020
ms.topic: overview
ms.openlocfilehash: 0b4782306c85590d74b521edd254659fb162b0c2
ms.sourcegitcommit: d623f686701b94bef905ec5e93d8b55d031c5d6f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/17/2021
ms.locfileid: "103624166"
---
# <a name="eventpipe"></a>Каналы событий

EventPipe — это компонент среды выполнения, который можно использовать для получения данных трассировки, аналогично ETW или LTTng. Цель использования EventPipe заключается в том, чтобы позволить разработчикам .NET с легкостью отслеживать свои приложения .NET, не прибегая к собственным компонентам операционной системы, таким как ETW или LTTng.

EventPipe — это механизм для многих средств диагностики, который можно использовать для потребления событий, генерируемых средой выполнения, а также настраиваемых событий, написанных с помощью [EventSource](xref:System.Diagnostics.Tracing.EventSource).

В этой статье представлены общие сведения об EventPipe, касающиеся того, когда и как использовать EventPipe, и как настроить его в соответствии с вашими потребностями.

## <a name="eventpipe-basics"></a>Основы EventPipe

EventPipe объединяет события, созданные компонентами среды выполнения, например JIT-компилятором или сборщиком мусора, а также события, записанные из экземпляров [EventSource](xref:System.Diagnostics.Tracing.EventSource) в библиотеках и пользовательском коде.

Затем события сериализуются и могут быть записаны непосредственно в файл или использованы через порт диагностики вне процесса. В Windows порты диагностики реализуются как `NamedPipe`. На платформах, отличных от Windows, таких как Linux или macOS, это реализуется с помощью сокетов доменов UNIX. Дополнительные сведения о порте диагностики и о том, как взаимодействовать с ним через свой настраиваемый протокол межпроцессного взаимодействия, см. в [документации по протоколу диагностики IPC](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/ipc-protocol.md).

Затем EventPipe записывает сериализованные события в файл `.nettrace` в виде потока через диагностические порты или непосредственно в файл. Дополнительные сведения о формате сериализации EventPipe см. в [документации по формату EventPipe](https://github.com/microsoft/perfview/blob/master/src/TraceEvent/EventPipe/EventPipeFormat.md).

## <a name="eventpipe-vs-etwlttng"></a>EventPipe и ETW/LTTng

EventPipe является частью среды выполнения .NET (CoreCLR) и разработан так же, как и на всех платформах, поддерживаемых .NET Core. Это позволяет средствам трассировки, основанным на EventPipe, например `dotnet-counters`, `dotnet-gcdump` и `dotnet-trace`, беспрепятственно работать на разных платформах.

Однако, поскольку EventPipe является встроенным компонентом среды выполнения, его область ограничена управляемым кодом и самой средой выполнения. EventPipe нельзя использовать для отслеживания некоторых событий низкого уровня, таких как разрешение стека машинного кода или получение различных событий ядра. Если вы используете в своем приложении межпроцессное взаимодействие C/C++ или требуется отследить саму среду выполнения (написанную на C++), а может, хотите глубже отслеживать поведение приложения, которое требует событий ядра (то есть событий переключения контекста в собственном потоке), следует использовать ETW или [perf/LTTng](./trace-perfcollect-lttng.md).

Еще одно важное различие между EventPipe и ETW/LTTng — обязательное наличие прав администратора или прав корневого уровня. Чтобы выполнить трассировку приложения с помощью ETW или LTTng, необходимо быть администратором или обладать правами корневого уровня. С помощью EventPipe можно выполнять трассировку приложений, если трассировка (например, `dotnet-trace`) выполняется от имени пользователя, запустившего приложение.

В следующей таблице приведена сводка различий между EventPipe и ETW/LTTng.

|Функция|Каналы событий|Трассировка событий Windows|LTTng|
|-------|---------|---|-----------|
|Поддержка разных платформ|Да|Нет (только в Windows)|Нет (только в поддерживаемых дистрибутивах Linux)|
|Требуются права администратора или корневого пользователя|Нет|Да|Да|
|Может получить события операционной системы или ядра|Нет|Да|Да|
|Может разрешить собственные стеки вызовов|Нет|Да|Да|

## <a name="use-eventpipe-to-trace-your-net-application"></a>Использование EventPipe для трассировки приложения .NET

EventPipe можно использовать для трассировки приложения .NET различными способами:

* Используйте одно из [средств диагностики](#tools-that-use-eventpipe), созданных на основе EventPipe.

* Используйте библиотеку [Microsoft.Diagnostics.NETCore.Client](https://github.com/dotnet/diagnostics/blob/master/documentation/diagnostics-client-library-instructions.md), чтобы написать собственное средство для самостоятельной настройки и запуска сеансов EventPipe.

* Для запуска EventPipe используйте [переменные среды](#trace-using-environment-variables).

После создания файла `nettrace`, содержащего события EventPipe, можно просмотреть файл в [`PerfView`](https://github.com/Microsoft/perfview#perfview-overview) или Visual Studio. На платформах, отличных от Windows, можно преобразовать файл `nettrace` в формат трассировки `speedscope` или `Chromium` с помощью команды [`dotnet-trace convert`](./dotnet-trace.md#dotnet-trace-convert) и просмотреть ее с помощью [`speedscope`](https://www.speedscope.app/) или Chrome DevTools.

Трассировки EventPipe можно также анализировать программно с помощью [TraceEvent](https://github.com/Microsoft/perfview/blob/master/documentation/TraceEvent/TraceEventLibrary.md).

### <a name="tools-that-use-eventpipe"></a>Средства, использующие EventPipe

Это самый простой способ использовать EventPipe для трассировки приложения. Дополнительные сведения об использовании каждого из этих средств см. в документации к каждому средству.

* [dotnet-counters](./dotnet-counters.md) позволяет отслеживать и получать различные метрики, созданные средой выполнения .NET и основными библиотеками, а также пользовательские метрики, которые можно писать.

* [dotnet-gcdump](./dotnet-gcdump.md) позволяет выполнять сбор дампов кучи сборщика мусора для активных процессов для анализа управляемой кучи приложения.

* [dotnet-trace](./dotnet-trace.md) позволяет собирать данные анализа производительности приложений.

## <a name="trace-using-environment-variables"></a>Трассировка с помощью переменных среды

Предпочтительным механизмом для использования EventPipe является использование `dotnet-trace` или библиотеки `Microsoft.Diagnostics.NETCore.Client`.

Однако можно использовать следующие переменные среды для настройки сеанса EventPipe в приложении и записи трассировки непосредственно в файл. Чтобы прекратить трассировку, закройте приложение.

* `COMPlus_EnableEventPipe`: Задайте значение `1`, чтобы запустить сеанс EventPipe, который выполняет запись непосредственно в файл. Значение по умолчанию — `0`.

* `COMPlus_EventPipeOutputPath`: Путь к выходному файлу трассировки EventPipe, когда он настроен для выполнения через `COMPlus_EnableEventPipe`. Значение по умолчанию — `trace.nettrace`, которое будет создано в том же каталоге, из которого выполняется приложение.

* `COMPlus_EventPipeCircularMB`: шестнадцатеричное значение, представляющее размер внутреннего буфера EventPipe в мегабайтах. Это значение конфигурации используется только в том случае, если EventPipe настроен для выполнения через `COMPlus_EnableEventPipe`. Размер буфера по умолчанию — 1024 МБ, который для этой переменной среды преобразуется в значение `400`, поскольку `0x400` == `1024`.

  > [!NOTE]
  > Если для целевого процесса события записываются слишком часто, это может привести к переполнению буфера и удалению некоторых событий. Если удаляется слишком много событий, увеличьте размер буфера и посмотрите, уменьшается ли число удаленных событий. Если не уменьшается, причиной может быть медленная работа средства чтения, из-за чего целевой буфер процесса не освобождается.

* `COMPlus_EventPipeProcNumbers`: установите значение `1`, чтобы включить захват номеров процессоров в заголовках событий EventPipe. Значение по умолчанию — `0`.

* `COMPlus_EventPipeConfig`: Настраивает конфигурацию сеанса EventPipe при запуске сеанса EventPipe с `COMPlus_EnableEventPipe`.
  Синтаксис выглядит следующим образом:

  `<provider>:<keyword>:<level>`

  Можно также указать несколько поставщиков, объединив их с помощью запятой:

  `<provider1>:<keyword1>:<level1>,<provider2>:<keyword2>:<level2>`

  Если эта переменная среды не задана, но EventPipe включен с помощью `COMPlus_EnableEventPipe`, компонент начнет трассировку, включив следующие поставщики со следующими ключевыми словами и уровнями:

  - `Microsoft-Windows-DotNETRuntime:4c14fccbd:5`
  - `Microsoft-Windows-DotNETRuntimePrivate:4002000b:5`
  - `Microsoft-DotNETCore-SampleProfiler:0:5`

  Дополнительные сведения о некоторых известных поставщиках в .NET см. в статье [Стандартные поставщики событий в .NET](./well-known-event-providers.md).
