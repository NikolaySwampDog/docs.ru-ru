---
title: Счетчики событий в .NET Core
description: В этой статье вы узнаете, что такое счетчики событий и как их реализовать и использовать.
ms.date: 08/07/2020
ms.openlocfilehash: 8efa3134e83ba6fdc7563e97ef6422cb5f2099b6
ms.sourcegitcommit: c7f0beaa2bd66ebca86362ca17d673f7e8256ca6
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/23/2021
ms.locfileid: "104872786"
---
# <a name="eventcounters-in-net-core"></a><span data-ttu-id="3e1f9-103">Счетчики событий в .NET Core</span><span class="sxs-lookup"><span data-stu-id="3e1f9-103">EventCounters in .NET Core</span></span>

<span data-ttu-id="3e1f9-104">**Эта статья относится к:** ✔️ пакету SDK для .NET Core 3.0 и более поздних версий</span><span class="sxs-lookup"><span data-stu-id="3e1f9-104">**This article applies to: ✔️** .NET Core 3.0 SDK and later versions</span></span>

<span data-ttu-id="3e1f9-105">Счетчики событий — это API .NET Core, которые используются для упрощенного кроссплатформенного сбора метрик производительности практически в реальном времени.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-105">EventCounters are .NET Core APIs used for lightweight, cross-platform, and near real-time performance metric collection.</span></span> <span data-ttu-id="3e1f9-106">Счетчики событий были добавлены как альтернатива счетчикам производительности, которые применялись в .NET Framework на базе Windows.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-106">EventCounters were added as a cross-platform alternative to the "performance counters" of the .NET Framework on Windows.</span></span> <span data-ttu-id="3e1f9-107">В этой статье вы узнаете, что такое счетчики событий и как их реализовать и использовать.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-107">In this article you'll learn what EventCounters are, how to implement them, and how to consume them.</span></span>

<span data-ttu-id="3e1f9-108">Начиная с NET Core 3.0 среда выполнения .NET Core и некоторые библиотеки .NET публикуют основные данные диагностики, используя счетчики событий.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-108">The .NET Core runtime and a few .NET libraries publish basic diagnostics information using EventCounters starting in .NET Core 3.0.</span></span> <span data-ttu-id="3e1f9-109">Помимо счетчиков событий, предоставляемых средой выполнения .NET, вы можете реализовывать и собственные счетчики событий.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-109">Apart from the EventCounters that are provided by the .NET runtime, you may choose to implement your own EventCounters.</span></span> <span data-ttu-id="3e1f9-110">Счетчики событий можно использовать для отслеживания различных метрик.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-110">EventCounters can be used to track various metrics.</span></span> <span data-ttu-id="3e1f9-111">Узнайте подробнее о них в статье, посвященной [известным счетчикам событий в .NET](available-counters.md)</span><span class="sxs-lookup"><span data-stu-id="3e1f9-111">Learn more about them in the [well-known EventCounters in .NET](available-counters.md)</span></span>

<span data-ttu-id="3e1f9-112">Они являются частью <xref:System.Diagnostics.Tracing.EventSource> и передаются в средства прослушивания автоматически и на регулярной основе.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-112">EventCounters live as a part of an <xref:System.Diagnostics.Tracing.EventSource>, and are automatically pushed to listener tools on a regular basis.</span></span> <span data-ttu-id="3e1f9-113">Как и все остальные события в <xref:System.Diagnostics.Tracing.EventSource>, их можно использовать как внутри, так и вне процессов через <xref:System.Diagnostics.Tracing.EventListener> и [EventPipe](./eventpipe.md).</span><span class="sxs-lookup"><span data-stu-id="3e1f9-113">Like all other events on an <xref:System.Diagnostics.Tracing.EventSource>, they can be consumed both in-proc and out-of-proc via <xref:System.Diagnostics.Tracing.EventListener> and [EventPipe](./eventpipe.md).</span></span> <span data-ttu-id="3e1f9-114">В этой статье рассматриваются межплатформенные возможности счетчиков событий и намеренно исключены PerfView и ETW (трассировка событий для Windows), хотя обе эти функции можно использовать со счетчиками событий.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-114">This article focuses on the cross-platform capabilities of EventCounters, and intentionally excludes PerfView and ETW (Event Tracing for Windows) - although both can be used with EventCounters.</span></span>

![Схема счетчиков событий внутри и вне процессов](media/event-counters.svg)

## <a name="eventcounter-api-overview"></a><span data-ttu-id="3e1f9-116">Общие сведения об API счетчиков событий</span><span class="sxs-lookup"><span data-stu-id="3e1f9-116">EventCounter API overview</span></span>

<span data-ttu-id="3e1f9-117">Счетчики делятся на две основные категории.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-117">There are two primary categories of counters.</span></span> <span data-ttu-id="3e1f9-118">Некоторые счетчики предназначены для "оценки" значений, таких как общее число исключений, общее число глобальных каталогов и общее число запросов.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-118">Some counters are for "rate" values, such as total number of exceptions, total number of GCs, and total number of requests.</span></span> <span data-ttu-id="3e1f9-119">Другие счетчики представляют "моментальные снимки" таких значений, как использование кучи, загрузка ЦП и размер рабочего набора.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-119">Other counters are "snapshot" values, such as heap usage, CPU usage, and working set size.</span></span> <span data-ttu-id="3e1f9-120">В каждой из этих категорий есть два типа счетчиков, которые различаются по тому, как они получают значение.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-120">Within each of these categories of counters, there are two types of counters that vary by how they get their value.</span></span> <span data-ttu-id="3e1f9-121">Счетчики с опросом получают значение в результате обратного вызова, а значения счетчиков без опроса задаются непосредственно в экземпляре соответствующего счетчика.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-121">Polling counters retrieve their value via a callback, and non-polling counters have their values directly set on the counter instance.</span></span>

<span data-ttu-id="3e1f9-122">Счетчики работают следующим образом:</span><span class="sxs-lookup"><span data-stu-id="3e1f9-122">The counters are represented by the following implementations:</span></span>

* <xref:System.Diagnostics.Tracing.EventCounter>
* <xref:System.Diagnostics.Tracing.IncrementingEventCounter>
* <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>
* <xref:System.Diagnostics.Tracing.PollingCounter>

<span data-ttu-id="3e1f9-123">Прослушиватель событий определяет величину интервала измерений.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-123">An event listener specifies how long measurement intervals are.</span></span> <span data-ttu-id="3e1f9-124">В конце каждого интервала в прослушиватель передается значение для каждого счетчика.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-124">At the end of each interval a value is transmitted to the listener for each counter.</span></span> <span data-ttu-id="3e1f9-125">Реализации счетчика определяют, какие API и вычисления использовались в каждом интервале для получения значения.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-125">The implementations of a counter determine what APIs and calculations are used to produce the value each interval.</span></span>

1. <span data-ttu-id="3e1f9-126">Метод <xref:System.Diagnostics.Tracing.EventCounter> регистрирует набор значений.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-126">The <xref:System.Diagnostics.Tracing.EventCounter> records a set of values.</span></span> <span data-ttu-id="3e1f9-127">Метод <xref:System.Diagnostics.Tracing.EventCounter.WriteMetric%2A?displayProperty=nameWithType> добавляет новое значение в набор.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-127">The <xref:System.Diagnostics.Tracing.EventCounter.WriteMetric%2A?displayProperty=nameWithType> method adds a new value to the set.</span></span> <span data-ttu-id="3e1f9-128">В каждом интервале вычисляется статистическая сводка по набору, например минимальное, максимальное и среднее значение.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-128">With each interval, a statistical summary for the set is computed, such as the min, max, and mean.</span></span> <span data-ttu-id="3e1f9-129">Средство [dotnet-counters](dotnet-counters.md) всегда отображает среднее значение.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-129">The [dotnet-counters](dotnet-counters.md) tool will always display the mean value.</span></span> <span data-ttu-id="3e1f9-130">Метод <xref:System.Diagnostics.Tracing.EventCounter> пригодится для описания дискретного набора операций.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-130">The <xref:System.Diagnostics.Tracing.EventCounter> is useful to describe a discrete set of operations.</span></span> <span data-ttu-id="3e1f9-131">Общее использование может включать мониторинг среднего размера последних операций ввода-вывода в байтах или среднее денежное значение набора финансовых транзакций.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-131">Common usage may include monitoring the average size in bytes of recent IO operations, or the average monetary value of a set of financial transactions.</span></span>

1. <span data-ttu-id="3e1f9-132">Метод <xref:System.Diagnostics.Tracing.IncrementingEventCounter> записывает промежуточные итоги для каждого интервала.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-132">The <xref:System.Diagnostics.Tracing.IncrementingEventCounter> records a running total for each time interval.</span></span> <span data-ttu-id="3e1f9-133">Метод <xref:System.Diagnostics.Tracing.IncrementingEventCounter.Increment%2A?displayProperty=nameWithType> добавляется к итогу.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-133">The <xref:System.Diagnostics.Tracing.IncrementingEventCounter.Increment%2A?displayProperty=nameWithType> method adds to the total.</span></span> <span data-ttu-id="3e1f9-134">Например, если `Increment()` за один и тот же интервал вызывается трижды со значениями `1`, `2` и `5`, то в качестве значения счетчика для этого интервала будет выводиться промежуточный итог `8`.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-134">For example, if `Increment()` is called three times during one interval with values `1`, `2`, and `5`, then the running total of `8` will be reported as the counter value for this interval.</span></span> <span data-ttu-id="3e1f9-135">Средство [dotnet-counters](dotnet-counters.md) отображает скорость из расчета общая сумма/время.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-135">The [dotnet-counters](dotnet-counters.md) tool will display the rate as the recorded total / time.</span></span> <span data-ttu-id="3e1f9-136">Метод <xref:System.Diagnostics.Tracing.IncrementingEventCounter> позволяет измерять частоту выполнения того или иного действия, например число запросов, обрабатываемых в секунду.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-136">The <xref:System.Diagnostics.Tracing.IncrementingEventCounter> is useful to measure how frequently an action is occurring, such as the number of requests processed per second.</span></span>

1. <span data-ttu-id="3e1f9-137">Метод <xref:System.Diagnostics.Tracing.PollingCounter> определяет выводимое значение, используя обратный вызов.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-137">The <xref:System.Diagnostics.Tracing.PollingCounter> uses a callback to determine the value that is reported.</span></span> <span data-ttu-id="3e1f9-138">В каждом интервале вызывается предоставляемая пользователем функция обратного вызова, а возвращаемое значение становится значением счетчика.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-138">With each time interval, the user provided callback function is invoked and the return value is used as the counter value.</span></span> <span data-ttu-id="3e1f9-139">Метод <xref:System.Diagnostics.Tracing.PollingCounter> можно использовать для запроса метрики из внешнего источника, например для получения текущего количества свободных байтов на диске.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-139">A <xref:System.Diagnostics.Tracing.PollingCounter> can be used to query a metric from an external source, for example getting the current free bytes on a disk.</span></span> <span data-ttu-id="3e1f9-140">Его также можно использовать для получения пользовательской статистики, вычисляемой приложением по запросу.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-140">It can also be used to report custom statistics that can be computed on demand by an application.</span></span> <span data-ttu-id="3e1f9-141">В качестве примеров можно привести отчеты по 95-му процентилю задержек последних запросов и по текущему проценту попадания в кэш.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-141">Examples include reporting the 95th percentile of recent request latencies, or the current hit or miss ratio of a cache.</span></span>

1. <span data-ttu-id="3e1f9-142">Метод <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> определяет выводимое значение приращения, используя обратный вызов.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-142">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> uses a callback to determine the reported increment value.</span></span> <span data-ttu-id="3e1f9-143">В каждом интервале выполняется обратный вызов, а разница между текущим и предыдущим вызовами становится отчетным значением.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-143">With each time interval, the callback is invoked, and then the difference between the current invocation, and the last invocation is the reported value.</span></span> <span data-ttu-id="3e1f9-144">Средство [dotnet-counters](dotnet-counters.md) всегда отображает разницу как скорость из расчета отчетное значение/время.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-144">The [dotnet-counters](dotnet-counters.md) tool will always display the difference as a rate, the reported value / time.</span></span> <span data-ttu-id="3e1f9-145">Этот счетчик полезен, если при каждом вхождении вызывать API нецелесообразно, но можно запрашивать общее количество вхождений.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-145">This counter is useful when it isn't feasible to call an API on each occurrence, but it's possible to query the total number of occurrences.</span></span> <span data-ttu-id="3e1f9-146">Например, можно указывать, сколько байтов записывается в файл в секунду, даже без уведомления о записи каждого байта.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-146">For example, you could report the number of bytes written to a file per second, even without a notification each time a byte is written.</span></span>

## <a name="implement-an-eventsource"></a><span data-ttu-id="3e1f9-147">Реализация счетчика событий</span><span class="sxs-lookup"><span data-stu-id="3e1f9-147">Implement an EventSource</span></span>

<span data-ttu-id="3e1f9-148">В приведенном ниже коде реализуется пример <xref:System.Diagnostics.Tracing.EventSource>, предоставляемый как именованный поставщик `"Sample.EventCounter.Minimal"`.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-148">The following code implements a sample <xref:System.Diagnostics.Tracing.EventSource> exposed as the named `"Sample.EventCounter.Minimal"` provider.</span></span> <span data-ttu-id="3e1f9-149">Этот источник содержит <xref:System.Diagnostics.Tracing.EventCounter>, который представляет время обработки запроса.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-149">This source contains an <xref:System.Diagnostics.Tracing.EventCounter> representing request processing time.</span></span> <span data-ttu-id="3e1f9-150">Счетчик имеет имя (т. е. уникальный идентификатор в источнике) и отображаемое имя, и оба этих имени используют средства прослушивателя, такие как [dotnet-counter](dotnet-counters.md).</span><span class="sxs-lookup"><span data-stu-id="3e1f9-150">Such a counter has a name (that is, its unique ID in the source) and a display name, both used by listener tools such as [dotnet-counter](dotnet-counters.md).</span></span>

:::code language="csharp" source="snippets/EventCounters/MinimalEventCounterSource.cs":::

<span data-ttu-id="3e1f9-151">Метод `dotnet-counters ps` отображает список процессов .NET, которые можно отслеживать:</span><span class="sxs-lookup"><span data-stu-id="3e1f9-151">You use `dotnet-counters ps` to display a list of .NET processes that can be monitored:</span></span>

```console
dotnet-counters ps
   1398652 dotnet     C:\Program Files\dotnet\dotnet.exe
   1399072 dotnet     C:\Program Files\dotnet\dotnet.exe
   1399112 dotnet     C:\Program Files\dotnet\dotnet.exe
   1401880 dotnet     C:\Program Files\dotnet\dotnet.exe
   1400180 sample-counters C:\sample-counters\bin\Debug\netcoreapp3.1\sample-counters.exe
```

<span data-ttu-id="3e1f9-152">Передайте имя <xref:System.Diagnostics.Tracing.EventSource> в параметр `--counters`, чтобы начать мониторинг счетчика:</span><span class="sxs-lookup"><span data-stu-id="3e1f9-152">Pass the <xref:System.Diagnostics.Tracing.EventSource> name to the `--counters` option to start monitoring your counter:</span></span>

```console
dotnet-counters monitor --process-id 1400180 --counters Sample.EventCounter.Minimal
```

<span data-ttu-id="3e1f9-153">В следующем примере показаны выходные данные мониторинга:</span><span class="sxs-lookup"><span data-stu-id="3e1f9-153">The following example shows monitor output:</span></span>

```console
Press p to pause, r to resume, q to quit.
    Status: Running

[Samples-EventCounterDemos-Minimal]
    Request Processing Time (ms)                            0.445
```

<span data-ttu-id="3e1f9-154">Нажмите <kbd>q</kbd>, чтобы остановить мониторинг.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-154">Press <kbd>q</kbd> to stop the monitoring command.</span></span>

#### <a name="conditional-counters"></a><span data-ttu-id="3e1f9-155">Условные счетчики</span><span class="sxs-lookup"><span data-stu-id="3e1f9-155">Conditional counters</span></span>

<span data-ttu-id="3e1f9-156">При реализации <xref:System.Diagnostics.Tracing.EventSource> для соответствующих счетчиков могут быть созданы условные экземпляры при вызове метода <xref:System.Diagnostics.Tracing.EventSource.OnEventCommand%2A?displayProperty=nameWithType> со значением <xref:System.Diagnostics.Tracing.EventCommandEventArgs.Command> параметра `EventCommand.Enable`.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-156">When implementing an <xref:System.Diagnostics.Tracing.EventSource>, the containing counters can be conditionally instantiated when the <xref:System.Diagnostics.Tracing.EventSource.OnEventCommand%2A?displayProperty=nameWithType> method is called with a <xref:System.Diagnostics.Tracing.EventCommandEventArgs.Command> value of `EventCommand.Enable`.</span></span> <span data-ttu-id="3e1f9-157">Чтобы экземпляр счетчика создавался только в том случае, если он имеет значение `null`, используйте [оператор присваивания объединения со значением NULL](../../csharp/language-reference/operators/null-coalescing-operator.md).</span><span class="sxs-lookup"><span data-stu-id="3e1f9-157">To safely instantiate a counter instance only if it is `null`, use the [null-coalescing assignment operator](../../csharp/language-reference/operators/null-coalescing-operator.md).</span></span> <span data-ttu-id="3e1f9-158">Кроме того, пользовательские методы могут оценивать метод <xref:System.Diagnostics.DiagnosticSource.IsEnabled%2A>, чтобы определить, включен ли текущий источник событий.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-158">Additionally, custom methods can evaluate the <xref:System.Diagnostics.DiagnosticSource.IsEnabled%2A> method to determine whether or not the current event source is enabled.</span></span>

:::code language="csharp" source="snippets/EventCounters/ConditionalEventCounterSource.cs":::

> [!TIP]
> <span data-ttu-id="3e1f9-159">Условными называются счетчики, для которых создается условный экземпляр, т. е. производится микрооптимизация.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-159">Conditional counters are counters that are conditionally instantiated, a micro-optimization.</span></span> <span data-ttu-id="3e1f9-160">Среда выполнения адаптирует этот шаблон для сценариев, в которых счетчики обычно не используются, чтобы сэкономить долю миллисекунды.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-160">The runtime adopts this pattern for scenarios where counters are normally not used, to save a fraction of a millisecond.</span></span>

### <a name="net-core-runtime-example-counters"></a><span data-ttu-id="3e1f9-161">Примеры счетчиков в среде выполнения .NET Core</span><span class="sxs-lookup"><span data-stu-id="3e1f9-161">.NET Core runtime example counters</span></span>

<span data-ttu-id="3e1f9-162">В среде выполнения .NET Core можно привести множество хороших примеров реализации.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-162">There are many great example implementations in the .NET Core runtime.</span></span> <span data-ttu-id="3e1f9-163">Ниже показана реализация среды выполнения для счетчика, который отслеживает размер рабочего набора приложения.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-163">Here is the runtime implementation for the counter that tracks the working set size of the application.</span></span>

```csharp
var workingSetCounter = new PollingCounter(
    "working-set",
    this,
    () => (double)(Environment.WorkingSet / 1_000_000))
{
    DisplayName = "Working Set",
    DisplayUnits = "MB"
};
```

<span data-ttu-id="3e1f9-164">Метод <xref:System.Diagnostics.Tracing.PollingCounter> сообщает о текущем объеме физической памяти, сопоставленном с процессом (рабочим набором) приложения, так как он фиксирует метрику в определенный момент времени.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-164">The <xref:System.Diagnostics.Tracing.PollingCounter> reports the current amount of physical memory mapped to the process (working set) of the app, since it captures a metric at a moment in time.</span></span> <span data-ttu-id="3e1f9-165">Обратный вызов для опроса значения — это заданное лямбда-выражение, которое, по сути, представляет собой вызов API <xref:System.Environment.WorkingSet?displayProperty=fullName>.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-165">The callback for polling a value is the provided lambda expression, which is just a call to the <xref:System.Environment.WorkingSet?displayProperty=fullName> API.</span></span> <span data-ttu-id="3e1f9-166"><xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayName> и <xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayUnits> — необязательные свойства, которые можно задать, чтобы помочь клиентской стороне счетчика отображать значение точнее.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-166"><xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayName> and <xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayUnits> are optional properties that can be set to help the consumer side of the counter to display the value more clearly.</span></span> <span data-ttu-id="3e1f9-167">Например, [dotnet-counters](dotnet-counters.md) использует эти свойства для более удобного отображения имен счетчиков на экране.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-167">For example, [dotnet-counters](dotnet-counters.md) uses these properties to display the more display-friendly version of the counter names.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="3e1f9-168">Свойства `DisplayName` не локализуются.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-168">The `DisplayName` properties are not localized.</span></span>

<span data-ttu-id="3e1f9-169">Для <xref:System.Diagnostics.Tracing.PollingCounter> и <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>не нужно выполнять никаких других действий.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-169">For the <xref:System.Diagnostics.Tracing.PollingCounter>, and the <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>, nothing else needs to be done.</span></span> <span data-ttu-id="3e1f9-170">Оба они сами опрашивают значения через указанный клиентом интервал.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-170">They both poll the values themselves at an interval requested by the consumer.</span></span>

<span data-ttu-id="3e1f9-171">Ниже приведен пример счетчика среды выполнения, реализованного с помощью <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-171">Here is an example of a runtime counter implemented using <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>.</span></span>

```csharp
var monitorContentionCounter = new IncrementingPollingCounter(
    "monitor-lock-contention-count",
    this,
    () => Monitor.LockContentionCount
)
{
    DisplayName = "Monitor Lock Contention Count",
    DisplayRateTimeScale = TimeSpan.FromSeconds(1)
};
```

<span data-ttu-id="3e1f9-172"><xref:System.Diagnostics.Tracing.IncrementingPollingCounter> использует API <xref:System.Threading.Monitor.LockContentionCount?displayProperty=nameWithType> для сообщения о приращении общего количества конфликтов блокировок.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-172">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> uses the <xref:System.Threading.Monitor.LockContentionCount?displayProperty=nameWithType> API to report the increment of the total lock contention count.</span></span> <span data-ttu-id="3e1f9-173">Свойство <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> необязательное, но может подсказать, какой интервал лучше выбрать для счетчика.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-173">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> property is optional, but when used it can provide a hint for what time interval the counter is best displayed at.</span></span> <span data-ttu-id="3e1f9-174">Например, число конфликтов блокировки лучше отображать как _количество в секунду_, поэтому для параметра <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> этого счетчика устанавливается значение одна секунда.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-174">For example, the lock contention count is best displayed as _count per second_, so its <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> is set to one second.</span></span> <span data-ttu-id="3e1f9-175">Частоту отображения данных можно настраивать для различных типов счетчиков скорости.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-175">The display rate can be adjusted for different types of rate counters.</span></span>

> [!NOTE]
> <span data-ttu-id="3e1f9-176">Параметр <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> _не_ используется средством [dotnet-counters](dotnet-counters.md), а прослушиватели событий не обязаны его использовать.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-176">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> is _not_ used by [dotnet-counters](dotnet-counters.md), and event listeners are not required to use it.</span></span>

<span data-ttu-id="3e1f9-177">Существуют и другие реализации счетчиков, к которым можно обращаться для справки. См. репозиторий [среды выполнения .NET](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/RuntimeEventSource.cs).</span><span class="sxs-lookup"><span data-stu-id="3e1f9-177">There are more counter implementations to use as a reference in the [.NET runtime](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/RuntimeEventSource.cs) repo.</span></span>

## <a name="concurrency"></a><span data-ttu-id="3e1f9-178">Параллелизм</span><span class="sxs-lookup"><span data-stu-id="3e1f9-178">Concurrency</span></span>

> [!TIP]
> <span data-ttu-id="3e1f9-179">API счетчиков событий не гарантирует безопасность потоков.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-179">The EventCounters API does not guarantee thread safety.</span></span> <span data-ttu-id="3e1f9-180">Когда делегаты, передаваемые в экземпляры <xref:System.Diagnostics.Tracing.PollingCounter> или <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>, вызываются несколькими потоками, за безопасность потоков таких делегатов отвечаете вы.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-180">When the delegates passed to <xref:System.Diagnostics.Tracing.PollingCounter> or <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> instances are called by multiple threads, it's your responsibility to guarantee the delegates' thread-safety.</span></span>

<span data-ttu-id="3e1f9-181">Например, рассмотрим следующий <xref:System.Diagnostics.Tracing.EventSource> для отслеживания запросов.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-181">For example, consider the following <xref:System.Diagnostics.Tracing.EventSource> to keep track of requests.</span></span>

:::code language="csharp" source="snippets/EventCounters/RequestEventSource.cs":::

<span data-ttu-id="3e1f9-182">Метод `AddRequest()` может вызываться из обработчика запросов, а `RequestRateCounter` опрашивает значение с интервалом, указанным клиентом счетчика.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-182">The `AddRequest()` method can be called from a request handler, and the `RequestRateCounter` polls the value at the interval specified by the consumer of the counter.</span></span> <span data-ttu-id="3e1f9-183">Однако метод `AddRequest()` могут вызываться одновременно несколько потоков, создавая для `_requestCount` состояние гонки.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-183">However, the `AddRequest()` method can be called by multiple threads at once, putting a race condition on `_requestCount`.</span></span> <span data-ttu-id="3e1f9-184">Альтернативный, поточно-ориентированный способ приращения `_requestCount` — использовать <xref:System.Threading.Interlocked.Increment%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-184">A thread-safe alternative way to increment the `_requestCount` is to use <xref:System.Threading.Interlocked.Increment%2A?displayProperty=nameWithType>.</span></span>

```csharp
public void AddRequest() => Interlocked.Increment(ref _requestCount);
```

<span data-ttu-id="3e1f9-185">Чтобы предотвратить разорванные операции чтения (в 32-разрядных архитектурах) поля `_requestCount` типа `long`, используйте <xref:System.Threading.Interlocked.Read%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-185">To prevent torn reads (on 32-bit architectures) of the `long`-field `_requestCount` use <xref:System.Threading.Interlocked.Read%2A?displayProperty=nameWithType>.</span></span>

```csharp
_requestRateCounter = new IncrementingPollingCounter("request-rate", this, () => Interlocked.Read(ref _requestCount))
{
    DisplayName = "Request Rate",
    DisplayRateTimeScale = TimeSpan.FromSeconds(1)
};
```

## <a name="consume-eventcounters"></a><span data-ttu-id="3e1f9-186">Использование счетчиков событий</span><span class="sxs-lookup"><span data-stu-id="3e1f9-186">Consume EventCounters</span></span>

<span data-ttu-id="3e1f9-187">Счетчики событий можно использовать двумя основными способами — внутри и вне процессов.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-187">There are two primary ways of consuming EventCounters, either in-proc, or out-of-proc.</span></span> <span data-ttu-id="3e1f9-188">Использование счетчиков событий можно разделить на три уровня различных технологий потребления.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-188">The consumption of EventCounters can be distinguished into three layers of various consuming technologies.</span></span>

- <span data-ttu-id="3e1f9-189">Транспортировка событий в поток необработанных данных через ETW или EventPipe:</span><span class="sxs-lookup"><span data-stu-id="3e1f9-189">Transporting events in a raw stream via ETW or EventPipe:</span></span>
  - <span data-ttu-id="3e1f9-190">ETW API входят с ОС Windows, а EventPipe доступен как [.NET API](https://github.com/dotnet/diagnostics/blob/main/documentation/design-docs/diagnostics-client-library.md#1-attaching-to-a-process-and-dumping-out-all-the-runtime-gc-events-in-real-time-to-the-console) или как диагностический [протокол IPC](https://github.com/dotnet/diagnostics/blob/main/documentation/design-docs/ipc-protocol.md).</span><span class="sxs-lookup"><span data-stu-id="3e1f9-190">ETW APIs come with the Windows OS, and EventPipe is accessible as a [.NET API](https://github.com/dotnet/diagnostics/blob/main/documentation/design-docs/diagnostics-client-library.md#1-attaching-to-a-process-and-dumping-out-all-the-runtime-gc-events-in-real-time-to-the-console), or the diagnostic [IPC protocol](https://github.com/dotnet/diagnostics/blob/main/documentation/design-docs/ipc-protocol.md).</span></span>
- <span data-ttu-id="3e1f9-191">Декодирование потока двоичных событий в события:</span><span class="sxs-lookup"><span data-stu-id="3e1f9-191">Decoding the binary event stream into events:</span></span>
  - <span data-ttu-id="3e1f9-192">[Библиотека TraceEvent](https://www.nuget.org/packages/Microsoft.Diagnostics.Tracing.TraceEvent) обрабатывает оба формата потоковой передачи, ETW и EventPipe.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-192">The [TraceEvent library](https://www.nuget.org/packages/Microsoft.Diagnostics.Tracing.TraceEvent) handles both ETW and EventPipe stream formats.</span></span>
- <span data-ttu-id="3e1f9-193">Средства командной строки и графического интерфейса:</span><span class="sxs-lookup"><span data-stu-id="3e1f9-193">Command-line and GUI tools:</span></span>
  - <span data-ttu-id="3e1f9-194">Такие средства, как PerfView (ETW или EventPipe), dotnet-counters (только EventPipe) и dotnet-monitor (только EventPipe).</span><span class="sxs-lookup"><span data-stu-id="3e1f9-194">Tools like PerfView (ETW or EventPipe), dotnet-counters (EventPipe only), and dotnet-monitor (EventPipe only).</span></span>

### <a name="consume-out-of-proc"></a><span data-ttu-id="3e1f9-195">Использование вне процессов</span><span class="sxs-lookup"><span data-stu-id="3e1f9-195">Consume out-of-proc</span></span>

<span data-ttu-id="3e1f9-196">Очень часто счетчики событий используются вне процессов.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-196">Consuming EventCounters out-of-proc is a very common approach.</span></span> <span data-ttu-id="3e1f9-197">Для получения данных в кроссплатформенном режиме через EventPipe можно использовать [dotnet-counters](dotnet-counters.md).</span><span class="sxs-lookup"><span data-stu-id="3e1f9-197">You can use [dotnet-counters](dotnet-counters.md) to consume them in a cross-platform manner via an EventPipe.</span></span> <span data-ttu-id="3e1f9-198">Средство `dotnet-counters` — это кроссплатформенный глобальный инструмент dotnet CLI, который можно использовать для отслеживания значений счетчиков.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-198">The `dotnet-counters` tool is a cross-platform dotnet CLI global tool that can be used to monitor the counter values.</span></span> <span data-ttu-id="3e1f9-199">Чтобы узнать, как использовать `dotnet-counters` для мониторинга счетчиков, ознакомьтесь с информацией о [dotnet-counters](dotnet-counters.md) или изучите руководство [Измерение производительности с помощью счетчиков событий](event-counter-perf.md).</span><span class="sxs-lookup"><span data-stu-id="3e1f9-199">To find out how to use `dotnet-counters` to monitor your counters, see [dotnet-counters](dotnet-counters.md), or work through the [Measure performance using EventCounters](event-counter-perf.md) tutorial.</span></span>

#### <a name="dotnet-trace"></a><span data-ttu-id="3e1f9-200">dotnet-trace</span><span class="sxs-lookup"><span data-stu-id="3e1f9-200">dotnet-trace</span></span>

<span data-ttu-id="3e1f9-201">Средство `dotnet-trace` можно использовать для получения данных счетчика через EventPipe.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-201">The `dotnet-trace` tool can be used to consume the counter data through an EventPipe.</span></span> <span data-ttu-id="3e1f9-202">Ниже приведен пример использования `dotnet-trace` для получения данных счетчика.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-202">Here is an example using `dotnet-trace` to collect counter data.</span></span>

```console
dotnet-trace collect --process-id <pid> Sample.EventCounter.Minimal:0:0:EventCounterIntervalSec=1
```

<span data-ttu-id="3e1f9-203">Дополнительные сведения о том, как получать значения счетчиков в перспективе, см. в документации по [dotnet-trace](dotnet-trace.md#use-dotnet-trace-to-collect-counter-values-over-time).</span><span class="sxs-lookup"><span data-stu-id="3e1f9-203">For more information on how to collect counter values over time, see the [dotnet-trace](dotnet-trace.md#use-dotnet-trace-to-collect-counter-values-over-time) documentation.</span></span>

#### <a name="azure-application-insights"></a><span data-ttu-id="3e1f9-204">Azure Application Insights</span><span class="sxs-lookup"><span data-stu-id="3e1f9-204">Azure Application Insights</span></span>

<span data-ttu-id="3e1f9-205">Счетчики событий можно использовать с помощью Azure Monitor, а именно — Application Insights Azure.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-205">EventCounters can be consumed by Azure Monitor, specifically Azure Application Insights.</span></span> <span data-ttu-id="3e1f9-206">Счетчики можно добавлять и удалять, а также выбирать пользовательские или популярные счетчики.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-206">Counters can be added and removed, and you're free to specify custom counters, or well-known counters.</span></span> <span data-ttu-id="3e1f9-207">Дополнительные сведения см. в статье [Настройка счетчиков для получения данных](/azure/azure-monitor/app/eventcounters#customizing-counters-to-be-collected).</span><span class="sxs-lookup"><span data-stu-id="3e1f9-207">For more information, see [Customizing counters to be collected](/azure/azure-monitor/app/eventcounters#customizing-counters-to-be-collected).</span></span>

#### <a name="dotnet-monitor"></a><span data-ttu-id="3e1f9-208">dotnet-monitor</span><span class="sxs-lookup"><span data-stu-id="3e1f9-208">dotnet-monitor</span></span>

<span data-ttu-id="3e1f9-209">`dotnet-monitor` — экспериментальное средство, упрощающее доступ к диагностическим сведениям в процессе .NET.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-209">The `dotnet-monitor` tool is an experimental tool that makes it easier to get access to diagnostics information in a .NET process.</span></span> <span data-ttu-id="3e1f9-210">Оно представляет собой расширенную версию всех средств диагностики.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-210">The tool serves as a superset of all diagnostics tools.</span></span> <span data-ttu-id="3e1f9-211">Наряду с трассировкой оно может отслеживать метрики и собирать дампы памяти и дампы сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-211">In addition to traces, it can monitor metrics, collect memory dumps, and collect GC dumps.</span></span> <span data-ttu-id="3e1f9-212">Оно распространяется как в виде средства командной строки, так и в виде образа Docker.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-212">It's distributed as both a CLI tool and a docker image.</span></span> <span data-ttu-id="3e1f9-213">Оно предоставляет REST API, а сбор артефактов диагностики осуществляется с помощью вызовов REST.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-213">It exposes a REST API, and the collection of diagnostic artifacts occurs through REST calls.</span></span>

<span data-ttu-id="3e1f9-214">Дополнительные сведения см. в статье [Знакомство с экспериментальным средством dotnet-monitor](https://devblogs.microsoft.com/dotnet/introducing-dotnet-monitor).</span><span class="sxs-lookup"><span data-stu-id="3e1f9-214">For more information, see [Introducing dotnet-monitor, an experimental tool](https://devblogs.microsoft.com/dotnet/introducing-dotnet-monitor).</span></span>

### <a name="consume-in-proc"></a><span data-ttu-id="3e1f9-215">Использование внутри процесса</span><span class="sxs-lookup"><span data-stu-id="3e1f9-215">Consume in-proc</span></span>

<span data-ttu-id="3e1f9-216">Значения счетчика можно использовать через API <xref:System.Diagnostics.Tracing.EventListener>.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-216">You can consume the counter values via the <xref:System.Diagnostics.Tracing.EventListener> API.</span></span> <span data-ttu-id="3e1f9-217"><xref:System.Diagnostics.Tracing.EventListener> — это внутрипроцессный способ использования любых событий, записанных всеми экземплярами <xref:System.Diagnostics.Tracing.EventSource> в приложении.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-217">An <xref:System.Diagnostics.Tracing.EventListener> is an in-proc way of consuming any events written by all instances of an <xref:System.Diagnostics.Tracing.EventSource> in your application.</span></span> <span data-ttu-id="3e1f9-218">Дополнительные сведения об использовании API `EventListener` см. в статье <xref:System.Diagnostics.Tracing.EventListener>.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-218">For more information on how to use the `EventListener` API, see <xref:System.Diagnostics.Tracing.EventListener>.</span></span>

<span data-ttu-id="3e1f9-219">Сначала необходимо включить <xref:System.Diagnostics.Tracing.EventSource>, который создает значение счетчика.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-219">First, the <xref:System.Diagnostics.Tracing.EventSource> that produces the counter value needs to be enabled.</span></span> <span data-ttu-id="3e1f9-220">Переопределите метод <xref:System.Diagnostics.Tracing.EventListener.OnEventSourceCreated%2A?displayProperty=nameWithType> так, чтобы получать уведомление при создании <xref:System.Diagnostics.Tracing.EventSource>, и, если это правильный метод <xref:System.Diagnostics.Tracing.EventSource> со счетчиками событий, вы сможете вызывать для него <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-220">Override the <xref:System.Diagnostics.Tracing.EventListener.OnEventSourceCreated%2A?displayProperty=nameWithType> method to get a notification when an <xref:System.Diagnostics.Tracing.EventSource> is created, and if this is the correct <xref:System.Diagnostics.Tracing.EventSource> with your EventCounters, then you can call <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A?displayProperty=nameWithType> on it.</span></span> <span data-ttu-id="3e1f9-221">Пример переопределения:</span><span class="sxs-lookup"><span data-stu-id="3e1f9-221">Here is an example override:</span></span>

:::code language="csharp" source="snippets/EventCounters/SimpleEventListener.cs" range="11-22":::

#### <a name="sample-code"></a><span data-ttu-id="3e1f9-222">Образец кода</span><span class="sxs-lookup"><span data-stu-id="3e1f9-222">Sample code</span></span>

<span data-ttu-id="3e1f9-223">Ниже приведен пример класса <xref:System.Diagnostics.Tracing.EventListener>, который выводит все имена и значения счетчиков из среды выполнения .NET <xref:System.Diagnostics.Tracing.EventSource> для публикации внутренних счетчиков (`System.Runtime`) каждую секунду.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-223">Here is a sample <xref:System.Diagnostics.Tracing.EventListener> class that prints out all the counter names and values from the .NET runtime's <xref:System.Diagnostics.Tracing.EventSource>, for publishing its internal counters (`System.Runtime`) every second.</span></span>

:::code language="csharp" source="snippets/EventCounters/SimpleEventListener.cs":::

<span data-ttu-id="3e1f9-224">Как показано выше, _необходимо_ убедиться, что аргумент `"EventCounterIntervalSec"` задан в аргументе `filterPayload` при вызове <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-224">As shown above, you _must_ make sure the `"EventCounterIntervalSec"` argument is set in the `filterPayload` argument when calling <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A>.</span></span> <span data-ttu-id="3e1f9-225">В противном случае счетчики не смогут сбрасывать значения, так как не будут знать, с каким интервалом нужно выполнять сброс.</span><span class="sxs-lookup"><span data-stu-id="3e1f9-225">Otherwise the counters will not be able to flush out values since it doesn't know at which interval it should be getting flushed out.</span></span>

## <a name="see-also"></a><span data-ttu-id="3e1f9-226">См. также</span><span class="sxs-lookup"><span data-stu-id="3e1f9-226">See also</span></span>

- [<span data-ttu-id="3e1f9-227">dotnet-counters</span><span class="sxs-lookup"><span data-stu-id="3e1f9-227">dotnet-counters</span></span>](dotnet-counters.md)
- [<span data-ttu-id="3e1f9-228">dotnet-trace</span><span class="sxs-lookup"><span data-stu-id="3e1f9-228">dotnet-trace</span></span>](dotnet-trace.md)
- <xref:System.Diagnostics.Tracing.EventCounter>
- <xref:System.Diagnostics.Tracing.EventListener>
- <xref:System.Diagnostics.Tracing.EventSource>
