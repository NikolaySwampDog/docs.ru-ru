---
title: Типы критических изменений
description: Узнайте, как .NET пытается обеспечить совместимость для разработчиков в разных версиях .NET и какого рода изменения рассматриваются как критические.
ms.date: 01/28/2021
ms.topic: conceptual
ms.openlocfilehash: 5814aa03d89cde086c4f055f36def77d4405be6f
ms.sourcegitcommit: 178ccefa8c454bfae844ce12ed222a54913df157
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/22/2021
ms.locfileid: "107883258"
---
# <a name="changes-that-affect-compatibility"></a>Изменения, влияющие на совместимость

На протяжении всей истории своего развития в .NET по возможности поддерживался высокий уровень совместимости между версиями и вариантами этой платформы. Хотя .NET 5 (и .NET Core) и более поздних версий можно считать новой технологией в сравнении с платформой .NET Framework, возможность независимого от .NET Framework развития данной реализации .NET ограничивается следующими двумя факторами.

- Большое количество разработчиков разрабатывали ранее и продолжают разрабатывать приложения для .NET Framework. Все они рассчитывают на согласованное поведение разных реализаций .NET.

- Проекты библиотек .NET Standard позволяют разработчикам создавать библиотеки для распространенных API, которые совместно используются в .NET Framework и .NET 5 (и .NET Core) и более поздних версий. Разработчики ожидают, что библиотеки из приложения .NET 5 будут вести себя точно так же, как аналогичные библиотеки в приложении .NET Framework.

Кроме совместимости разных реализаций .NET, разработчики также ожидают высокий уровень совместимости между версиями данной реализации .NET. В частности, код, написанный для более ранней версии .NET Core, должен без проблем работать в .NET 5 и любой последующей версии. Более того, многие разработчики ожидают, что новые API в свежих версиях .NET будут также совместимы с предварительными версиями, в которых впервые появились эти API.

Эта статья описывает, какие изменения связаны с совместимостью и каким образом каждый тип изменений анализируется командой создателей .NET. Узнать о подходах создателей .NET к внедрению потенциальных критических изменений будет особенно полезно разработчикам, которые открывают запросы на вытягивание, изменяющие работу [существующих API .NET](https://github.com/dotnet/runtime).

В следующих разделах описываются категории изменений, внесенных в API .NET, и их влияние на совместимость приложений. Изменения могут быть разрешены (✔️), запрещены (❌) или требовать оценки предсказуемости и очевидности, а также согласованности таких изменений с прежним поведением.

> [!NOTE]
>
> - Эти критерии не только разъясняют оценку изменений в библиотеках .NET, но и могут помочь разработчикам оценивать изменения в собственных библиотеках, предназначенных для различных реализаций и версий .NET.
> - Категории совместимости, например обратная и с будущими версиями, описаны в статье [Совместимость](categories.md).

## <a name="modifications-to-the-public-contract"></a>Изменения в открытом контракте

Изменения в этой категории изменяют общую контактную зону для типа. Большинство изменений в этой категории запрещены, так как они нарушают *обратную совместимость* (возможность выполнять приложения, разработанные для предыдущих версий API, без повторной компиляции для более поздней версии).

### <a name="types"></a>Типы

- ✔️ **РАЗРЕШЕНО. Удаление реализации интерфейса из типа, если этот интерфейс уже реализован в базовом типе**

- ❓ **ТРЕБУЕТСЯ ОЦЕНКА. Добавление новой реализации интерфейса в тип**

  Это допустимое изменение, так как оно не сказывается отрицательно на существующих клиентах. Чтобы новая реализация оставалась допустимой, любые изменения типа должны выполняться в пределах допустимых изменений, которые определены здесь. Следует соблюдать предельную осторожность при добавлении интерфейсов, которые напрямую влияют на способность конструктора или сериализатора создавать код или данные, которые нельзя использовать на нижнем уровне. Пример — интерфейс <xref:System.Runtime.Serialization.ISerializable>.

- ❓ **ТРЕБУЕТСЯ ОЦЕНКА. Добавление нового базового класса**

  Тип можно включать в иерархию между двумя существующими типами, если он не включает новые [абстрактные](../../csharp/language-reference/keywords/abstract.md) элементы и не изменяет семантику или поведение существующих типов. Например, в .NET Framework 2.0 класс <xref:System.Data.Common.DbConnection> стал новым базовым классом для <xref:System.Data.SqlClient.SqlConnection> с наследованием напрямую от <xref:System.ComponentModel.Component>.

- ✔️ **РАЗРЕШЕНО. Перемещение типа из одной сборки в другую**

  *Старой* сборке следует присвоить метку <xref:System.Runtime.CompilerServices.TypeForwardedToAttribute>, указывающую на новую сборку.

- ✔️ **РАЗРЕШЕНО. Изменение типа [struct](../../csharp/language-reference/builtin-types/struct.md) на тип `readonly struct`**

  Изменение типа `readonly struct` на тип `struct` запрещено.

- ✔️ **РАЗРЕШЕНО. Добавление ключевых слов [sealed](../../csharp/language-reference/keywords/sealed.md) или [abstract](../../csharp/language-reference/keywords/abstract.md) к типу, в котором нет *доступных* конструкторов (открытых или защищенных)**

- ✔️ **РАЗРЕШЕНО. Расширение видимости типа**

- ❌ **ЗАПРЕЩЕНО. Изменение пространства имен или имени типа**

- ❌ **ЗАПРЕЩЕНО. Переименование или удаление открытого типа**

   Это изменение нарушает весь код, в котором использовался переименованный или удаленный тип.

- ❌ **ЗАПРЕЩЕНО. Изменение базового типа для перечисления**

   Это критическое изменение нарушает процесс компиляции и поведение приложения, а также совместимость на двоичном уровне вплоть до невозможности анализировать аргументы атрибутов.

- ❌ **ЗАПРЕЩЕНО. Запечатывание типа, который ранее был незапечатанным**

- ❌ **ЗАПРЕЩЕНО. Добавление интерфейса в набор базовых типов интерфейса**

   Если интерфейс реализует другой интерфейс, который ранее не был в нем реализован, нарушаются все типы, которые реализовали исходную версию этого интерфейса.

- ❓ **ТРЕБУЕТСЯ ОЦЕНКА. Удаление класса из набора базовых классов или интерфейса из набора реализованных интерфейсов**

  Есть одно исключение из правила удаления интерфейса: вы можете добавить реализацию интерфейса, наследуемую от удаленного интерфейса. Например, можно удалить <xref:System.IDisposable>, если тип или интерфейс теперь реализуют <xref:System.ComponentModel.IComponent> с реализацией <xref:System.IDisposable>.

- ❌ **ЗАПРЕЩЕНО. Изменение типа `readonly struct` на тип [struct](../../csharp/language-reference/builtin-types/struct.md)**

  Обратите внимание, что изменение типа `struct` на тип `readonly struct` разрешено.

- ❌ **ЗАПРЕЩЕНО. Изменение типа [struct](../../csharp/language-reference/builtin-types/struct.md) на тип `ref struct` и наоборот**

- ❌ **ЗАПРЕЩЕНО. Снижение видимости типа**

   При этом увеличение видимости типа разрешено.

### <a name="members"></a>Участники

- ✔️ **РАЗРЕШЕНО. Расширение видимости для элемента, который не является [виртуальным](../../csharp/language-reference/keywords/sealed.md)**

- ✔️ **РАЗРЕШЕНО. Добавление абстрактного элемента в открытый тип без *доступных* конструкторов (открытых или защищенных) или в [запечатанный тип](../../csharp/language-reference/keywords/sealed.md)**

  При этом добавление абстрактного элемента в тип с доступными конструкторами (открытыми или защищенными) и в незапечатанный тип (`sealed`) разрешено.

- ✔️ **РАЗРЕШЕНО. Ограничение видимости [защищенного](../../csharp/language-reference/keywords/protected.md) элемента, если у типа нет доступных (открытых или защищенных) конструкторов или этот тип [запечатан](../../csharp/language-reference/keywords/sealed.md)**

- ✔️ **РАЗРЕШЕНО. Перемещение элемента в класс, расположенный в иерархии выше типа, из которого он был удален**

- ✔️ **РАЗРЕШЕНО. Добавление или удаление переопределения**

  Добавление переопределения может привести к тому, что прежние пользователи не будут его использовать при вызове [базового](../../csharp/language-reference/keywords/base.md) типа.

- ✔️ **РАЗРЕШЕНО. Добавление в класс конструктора одновременно с конструктором без параметров, если ранее у этого класса не было конструкторов**

   При этом добавление конструктора в класс, ранее не имевший конструкторов, *без* добавления конструктора без параметров, не разрешено.

- ✔️ **РАЗРЕШЕНО. Изменение [абстрактного](../../csharp/language-reference/keywords/abstract.md) элемента на [виртуальный](../../csharp/language-reference/keywords/virtual.md)**

- ✔️ **РАЗРЕШЕНО. Изменение возвращаемого значения с `ref readonly` на `ref` (за исключением виртуальных методов или интерфейсов)**

- ✔️ **РАЗРЕШЕНО. Удаление из поля метки [readonly](../../csharp/language-reference/keywords/readonly.md), за исключением полей со статическим типом изменяемого значения**

- ✔️ **РАЗРЕШЕНО. Вызов нового события, которое не было определено ранее**

- ❓ **ТРЕБУЕТСЯ ОЦЕНКА. Добавление нового поля экземпляра к типу**

   Это изменение влияет на сериализацию.

- ❌ **ЗАПРЕЩЕНО. Переименование или удаление открытого типа или параметра**

   Это изменение нарушает весь код, в котором использовался переименованный или удаленный элемент либо параметр.

   Сюда относятся удаление и переименование методов получения и определения свойств, а также элементов перечисления.

- ❌ **ЗАПРЕЩЕНО. Добавление элемента к интерфейсу**

- ❌ **ЗАПРЕЩЕНО. Изменение значения общедоступной константы или элемента перечисления**

- ❌ **ЗАПРЕЩЕНО. Изменение типа для свойства, поля, параметра или возвращаемого значения**

- ❌ **ЗАПРЕЩЕНО. Добавление, удаление параметров или изменение их порядка**

- ❌ **ЗАПРЕЩЕНО. Добавление или удаление ключевого слова [in](../../csharp/language-reference/keywords/in.md), [out](../../csharp/language-reference/keywords/out.md) или [ref](../../csharp/language-reference/keywords/ref.md) для параметра**

- ❌ **ЗАПРЕЩЕНО. Переименование параметра (в том числе изменение регистра символов)**

  Такое изменение считается критическим по двум причинам:

  - Оно нарушает сценарии с поздним связыванием, например функцию поздней привязки в Visual Basic и функцию [dynamic](../../csharp/language-reference/builtin-types/reference-types.md#the-dynamic-type) в C#.

  - Оно нарушает [совместимость на уровне кода](categories.md#source-compatibility), если разработчик использует [именованные аргументы](../../csharp/programming-guide/classes-and-structs/named-and-optional-arguments.md#named-arguments).

- ❌ **ЗАПРЕЩЕНО. Изменение возвращаемого значения с `ref` на `ref readonly`**

- ❌️ **ЗАПРЕЩЕНО. Изменение возвращаемого значения с `ref readonly` на `ref` для виртуальных методов или интерфейсов**

- ❌ **ЗАПРЕЩЕНО. Добавление или удаление ключевого слова [abstract](../../csharp/language-reference/keywords/abstract.md) для элемента**

- ❌ **ЗАПРЕЩЕНО. Удаление ключевого слова [virtual](../../csharp/language-reference/keywords/virtual.md) для элемента**

- ❌ **ЗАПРЕЩЕНО. Добавление ключевого слова [virtual](../../csharp/language-reference/keywords/virtual.md) к элементу**

  Такое изменение часто не является критическим, так как компилятор C# обычно выдает инструкции [callvirt](<xref:System.Reflection.Emit.OpCodes.Callvirt>) на промежуточном языке (IL) для вызова невиртуальных методов (`callvirt`, в отличие об обычного кода, выполняет проверку значений null). При этом такое поведение не может считаться стабильным по следующим причинам:
  
  - .NET используется не только с C#, но и с другими языками.

  - Компилятор C# продолжает попытки оптимизировать `callvirt` в обычный вызов, если целевой метод не является виртуальным и с высокой вероятностью не имеет значения null (например, метод с доступом с использованием [оператора распространения значений null ?.](../../csharp/language-reference/operators/member-access-operators.md#null-conditional-operators--and-)).

  Преобразование метода в виртуальный означает, что код объекта-получателя будет часто вызывать его не виртуально.

- ❌ **ЗАПРЕЩЕНО. Преобразование виртуального элемента в абстрактный**

  [Виртуальный элемент](../../csharp/language-reference/keywords/virtual.md) предоставляет реализацию метода, которую *можно* переопределить производным классом. [Абстрактный элемент](../../csharp/language-reference/keywords/abstract.md) не предоставляет реализацию и *должен быть* переопределен.

- ❌ **ЗАПРЕЩЕНО. Добавление абстрактного элемента в общедоступный тип с доступными конструкторами (открытыми или защищенными) и [незапечатанный тип](../../csharp/language-reference/keywords/sealed.md)**

- ❌ **ЗАПРЕЩЕНО. Добавление в элемент ключевого слова [static](../../csharp/language-reference/keywords/static.md) или его удаление**

- ❌ **ЗАПРЕЩЕНО. Добавление перегрузки, которая исключает существующую перегрузку и определяет другое поведение**

  Такое изменение нарушает логику существующих клиентов, которые зависели от предыдущей перегрузки. Например, если у класса есть одна версия метода, которая принимает <xref:System.UInt32>, существующий получатель будет успешно привязан к этой перегрузке при отправке значения <xref:System.Int32>. Но если вы добавите перегрузку, которая принимает <xref:System.Int32>, при повторной компиляции или при использовании позднего связывания компилятор будет выполнять привязку к новой перегрузке. Любые изменения, приводящие к разным реакциям на события, считаются критическими.

- ❌ **ЗАПРЕЩЕНО. Добавление конструктора в класс, ранее не имевший конструкторов, без добавления конструктора без параметров**

- ❌️ **ЗАПРЕЩЕНО. Добавление ключевого слова [readonly](../../csharp/language-reference/keywords/readonly.md) в поле**

- ❌ **ЗАПРЕЩЕНО. Снижение видимости элемента**

   Сюда входит ограничение видимости [защищенного](../../csharp/language-reference/keywords/protected.md) элемента, если имеются *доступные* (`public` или `protected`) конструкторы, но тип *не* является [запечатанным](../../csharp/language-reference/keywords/sealed.md). Если это не так, снижение видимости защищенного элемента разрешено.

   Увеличение видимости типа разрешено.

- ❌ **ЗАПРЕЩЕНО. Изменение типа элемента**

   Возвращаемое значение метода или типа свойства или поля изменить нельзя. Например, сигнатуру метода, который возвращает <xref:System.Object>, нельзя изменить так, чтобы он возвращал <xref:System.String>, или наоборот.

- ❌ **ЗАПРЕЩЕНО. Добавление поля к структуре, у которой ранее не было состояний**

  Правила определенного назначения допускают использование неинициализированных переменных, если переменная имеет тип структуры без отслеживания состояния. Если этой структуре добавить отслеживание состояния, код может получить неинициализированные данные. Такое изменение может быть критическим на уровне источника и двоичного кода.

- ❌ **ЗАПРЕЩЕНО. Вызов существующего события, которое ранее никогда не срабатывало**

## <a name="behavioral-changes"></a>Изменения поведения

### <a name="assemblies"></a>Сборки

- ✔️ **РАЗРЕШЕНО. Преобразование сборки в переносимую при сохранении поддержки тех же платформ**

- ❌ **ЗАПРЕЩЕНО. Изменение имени сборки**
- ❌ **ЗАПРЕЩЕНО. Изменение открытого ключа сборки**

### <a name="properties-fields-parameters-and-return-values"></a>Свойства, поля, параметры и возвращаемые значения

- ✔️ **РАЗРЕШЕНО. Изменение значения для свойства, поля, возвращаемого значения или параметра [out](../../csharp/language-reference/keywords/out-parameter-modifier.md) на более производный тип**

  Например, метод, возвращающий тип <xref:System.Object>, может возвращать экземпляр <xref:System.String>. (Но при этом сигнатура метода не должна изменяться.)

- ✔️ **РАЗРЕШЕНО. Увеличение диапазона допустимых значений для свойства или параметра, если элемент не является [виртуальным](../../csharp/language-reference/keywords/virtual.md)**

  Можно расширять диапазон значений, которые передаются методу или возвращаются из него, но нельзя расширять тип параметра или элемента. Например, диапазон передаваемых методу значений можно расширить с 0–124 до 0–255, но нельзя изменить тип параметра с <xref:System.Byte> на <xref:System.Int32>.

- ❌ **ЗАПРЕЩЕНО. Увеличение диапазона допустимых значений для свойства или параметра, если элемент является [виртуальным](../../csharp/language-reference/keywords/virtual.md)**

   Такое изменение нарушает существующие переопределенные элементы, которые не будут правильно работать с расширенным диапазоном значений.

- ❌ **ЗАПРЕЩЕНО. Уменьшение диапазона допустимых значений для свойства или параметра**

- ❌ **ЗАПРЕЩЕНО. Увеличение диапазона допустимых значений для свойства, поля, возвращаемого значения или параметра [out](../../csharp/language-reference/keywords/out-parameter-modifier.md)**

- ❌ **ЗАПРЕЩЕНО. Изменение возвращаемых значений для свойства, поля, возвращаемого значения метода или параметра [out](../../csharp/language-reference/keywords/out-parameter-modifier.md)**

- ❌ **ЗАПРЕЩЕНО. Изменение значения по умолчанию для свойства, поля или параметра**

- ❌ **ЗАПРЕЩЕНО. Изменение точности числового возвращаемого значения**

- ❓ **ТРЕБУЕТСЯ ОЦЕНКА. Изменение логики синтаксического анализа входных данных и создание новых исключений (даже если поведение синтаксического анализа не указано в документации**

### <a name="exceptions"></a>Исключения

- ✔️ **РАЗРЕШЕНО. Вызов более производного исключения, чем существующие исключения**

  Так как новое исключение является подклассом существующего исключения, существующий код обработки исключений будет обрабатывать это исключение. Например, в .NET Framework 4 методы создания и получения языка и региональных параметров теперь вызывают исключение <xref:System.Globalization.CultureNotFoundException> вместо <xref:System.ArgumentException>, если не могут найти язык и региональные параметры. Так как <xref:System.Globalization.CultureNotFoundException> является производным от <xref:System.ArgumentException>, это изменение считается допустимым.

- ✔️ **РАЗРЕШЕНО. Вызов более конкретного исключения, чем <xref:System.NotSupportedException>, <xref:System.NotImplementedException>, <xref:System.NullReferenceException>**

- ✔️ **РАЗРЕШЕНО. Вызов исключения, которое считается неустранимым**

  Неустранимые исключения не нужно перехватывать, они попадают в обработчик catch-all на верхнем уровне. Это означает, что у пользователей нет кода, который перехватывает эти явные исключения. Неустранимыми считаются следующие исключения:

  - <xref:System.AccessViolationException>
  - <xref:System.ExecutionEngineException>
  - <xref:System.Runtime.InteropServices.SEHException>
  - <xref:System.StackOverflowException>

- ✔️ **РАЗРЕШЕНО. Вызов нового исключения в новом пути кода**

  Исключения должны применяться только к новому пути кода, который выполняется с новыми значениями параметров или состоянием и который невозможно выполнить в существующем коде, ориентированном на предыдущую версию.

- ✔️ **РАЗРЕШЕНО. Удаление исключения для более надежной работы или для нового сценария**

  Например, метод `Divide`, который ранее обрабатывал только положительные значения и вызвал исключение <xref:System.ArgumentOutOfRangeException>, можно изменить так, чтобы он поддерживал положительные и отрицательные значения без вызова исключения.

- ✔️ **РАЗРЕШЕНО. Изменение текста сообщения об ошибке**

  Разработчикам не следует полагаться на текст сообщения об ошибках, который изменяется еще и в зависимости от языка и региональных параметров пользователя.

- ❌ **ЗАПРЕЩЕНО. Вызов исключения в любом случае, кроме перечисленных выше**

- ❌ **ЗАПРЕЩЕНО. Удаление исключения в любом случае, кроме перечисленных выше**

### <a name="attributes"></a>Атрибуты

- ✔️ **РАЗРЕШЕНО. Изменение значения атрибута, который *не* является наблюдаемым**

- ❌ **ЗАПРЕЩЕНО. Изменение значения атрибута, который *является* наблюдаемым**

- ❓ **ТРЕБУЕТСЯ ОЦЕНКА. Удаление атрибута**

  В большинстве случаев удаление атрибута (например, <xref:System.NonSerializedAttribute>) является критическим изменением.

## <a name="platform-support"></a>Поддержка платформ

- ✔️ **РАЗРЕШЕНО. Поддержка операции для платформы, которая ранее не поддерживалась**

- ❌ **ЗАПРЕЩЕНО. Прекращение поддержки или требование конкретного пакета обновления для операции, которая ранее поддерживалась для платформы**

## <a name="internal-implementation-changes"></a>Изменения внутренней реализации

- ❓ **ТРЕБУЕТСЯ ОЦЕНКА. Изменение контактной зоны внутреннего типа**

   Такие изменения обычно разрешены, хотя они изменяют закрытое отражение. Эти изменения могут быть не разрешены в некоторых случаях, если популярные сторонние библиотеки или большое количество разработчиков полагаются на внутренние API.

- ❓ **ТРЕБУЕТСЯ ОЦЕНКА. Изменение внутренней реализации элемента**

  Такие изменения обычно разрешены, хотя они изменяют закрытое отражение. Эти изменения могут быть не разрешены в некоторых случаях, если код клиента часто зависит от закрытого отражения или если изменения связаны с нежелательными побочными эффектами.

- ✔️ **РАЗРЕШЕНО. Повышение производительности операции**

   Возможность изменять производительность операции очень важна, но такие изменения могут нарушить код, который зависит от текущей скорости операции. Это особенно важно для кода, который зависит от скорости выполнения асинхронных операций. Изменение производительности не должно влиять на другие аспекты поведения API, в противном случае изменение будет считаться критическим.

- ✔️ **РАЗРЕШЕНО. Косвенное (и обычно отрицательное) изменение производительности операции**

  Если изменение не относится к категории критических по другим причинам, оно считается допустимым. Зачастую требуются дополнительные действия, включая дополнительные операции или операции, которые добавляют новые функции. Это почти всегда влияет на производительность, но может требоваться для правильной работы API.

- ❌ **ЗАПРЕЩЕНО. Преобразование синхронного API в асинхронный (и наоборот)**

## <a name="code-changes"></a>Изменения кода

- ✔️ **РАЗРЕШЕНО. Добавление [params](../../csharp/language-reference/keywords/params.md) в параметр**

- ❌ **ЗАПРЕЩЕНО. Замена [структуры](../../csharp/language-reference/builtin-types/struct.md) на [класс](../../csharp/language-reference/keywords/class.md) и наоборот**

- ❌ **ЗАПРЕЩЕНО. Добавление ключевого слова [checked](../../csharp/language-reference/keywords/virtual.md) в блок кода**

   Такое изменение может привести к тому, что ранее правильно выполнявшийся код будет вызывать исключение <xref:System.OverflowException>, что является недопустимым.

- ❌ **ЗАПРЕЩЕНО. Удаление [params](../../csharp/language-reference/keywords/params.md) из параметра**

- ❌ **ЗАПРЕЩЕНО. Изменение порядка возникновения событий**

  Разработчики могут рассчитывать на то, что события будут срабатывать в определенном порядке, и создаваемый ими код часто зависит от этого порядка.

- ❌ **ЗАПРЕЩЕНО. Удаление вызова события для конкретного действия**

- ❌ **ЗАПРЕЩЕНО. Изменение количества вызовов определенных событий**

- ❌ **ЗАПРЕЩЕНО. Добавление <xref:System.FlagsAttribute> к типу перечисления**
