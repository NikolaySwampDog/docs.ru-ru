---
title: Рекомендации по внедрению зависимостей
description: Ознакомьтесь с рекомендациями по внедрению зависимостей и разработке приложений для .NET.
author: IEvangelist
ms.author: dapine
ms.date: 10/29/2020
ms.topic: guide
ms.openlocfilehash: 105536df873829dc79dcca1b86d080360e71303f
ms.sourcegitcommit: f2ab02d9a780819ca2e5310bbcf5cfe5b7993041
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/03/2021
ms.locfileid: "102402147"
---
# <a name="dependency-injection-guidelines"></a><span data-ttu-id="ca8e2-103">Рекомендации по внедрению зависимостей</span><span class="sxs-lookup"><span data-stu-id="ca8e2-103">Dependency injection guidelines</span></span>

<span data-ttu-id="ca8e2-104">В этой статье приведены общие рекомендации по внедрению зависимостей в приложениях .NET.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-104">This article provides general guidelines and best practices for implementing dependency injection in .NET applications.</span></span>

## <a name="design-services-for-dependency-injection"></a><span data-ttu-id="ca8e2-105">Проектирование служб для внедрения зависимостей</span><span class="sxs-lookup"><span data-stu-id="ca8e2-105">Design services for dependency injection</span></span>

<span data-ttu-id="ca8e2-106">При разработке служб для внедрения зависимостей придерживайтесь следующих рекомендаций:</span><span class="sxs-lookup"><span data-stu-id="ca8e2-106">When designing services for dependency injection:</span></span>

- <span data-ttu-id="ca8e2-107">Избегайте статических классов и членов с отслеживанием состояния.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-107">Avoid stateful, static classes and members.</span></span> <span data-ttu-id="ca8e2-108">Избегайте создания глобального состояния. Для этого проектируйте приложения для использования отдельных служб.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-108">Avoid creating global state by designing apps to use singleton services instead.</span></span>
- <span data-ttu-id="ca8e2-109">Избегайте прямого создания экземпляров зависимых классов внутри служб.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-109">Avoid direct instantiation of dependent classes within services.</span></span> <span data-ttu-id="ca8e2-110">Прямое создание экземпляров обязывает использовать в коде определенную реализацию.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-110">Direct instantiation couples the code to a particular implementation.</span></span>
- <span data-ttu-id="ca8e2-111">Сделайте службы приложения небольшими, хорошо организованными и удобными в тестировании.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-111">Make services small, well-factored, and easily tested.</span></span>

<span data-ttu-id="ca8e2-112">Если в классе много внедренных зависимостей, это может указывать на то, что у класса слишком много задач и он нарушает [принцип единственной обязанности](/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles#single-responsibility).</span><span class="sxs-lookup"><span data-stu-id="ca8e2-112">If a class has many injected dependencies, it might be a sign that the class has too many responsibilities and violates the [Single Responsibility Principle (SRP)](/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles#single-responsibility).</span></span> <span data-ttu-id="ca8e2-113">Попробуйте выполнить рефакторинг класса и перенести часть его обязанностей в новые классы.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-113">Attempt to refactor the class by moving some of its responsibilities into new classes.</span></span>

### <a name="disposal-of-services"></a><span data-ttu-id="ca8e2-114">Удаление служб</span><span class="sxs-lookup"><span data-stu-id="ca8e2-114">Disposal of services</span></span>

<span data-ttu-id="ca8e2-115">Контейнер отвечает за очистку создаваемых типов и вызывает <xref:System.IDisposable.Dispose%2A> для экземпляров <xref:System.IDisposable>.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-115">The container is responsible for cleanup of types it creates, and calls <xref:System.IDisposable.Dispose%2A> on <xref:System.IDisposable> instances.</span></span> <span data-ttu-id="ca8e2-116">Службы, разрешенные из контейнера, никогда не должны удаляться разработчиком.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-116">Services resolved from the container should never be disposed by the developer.</span></span> <span data-ttu-id="ca8e2-117">Если тип или фабрика зарегистрированы как одноэлементный объект, контейнер автоматически удалит одноэлементные объекты.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-117">If a type or factory is registered as a singleton, the container disposes the singleton automatically.</span></span>

<span data-ttu-id="ca8e2-118">В следующем примере службы создаются контейнером службы и автоматически удаляются:</span><span class="sxs-lookup"><span data-stu-id="ca8e2-118">In the following example, the services are created by the service container and disposed automatically:</span></span>

:::code language="csharp" source="snippets/configuration/console-di-disposable/TransientDisposable.cs":::

<span data-ttu-id="ca8e2-119">Предыдущий удаляемый объект должен иметь временное существование.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-119">The preceding disposable is intended to have a transient lifetime.</span></span>

:::code language="csharp" source="snippets/configuration/console-di-disposable/ScopedDisposable.cs":::

<span data-ttu-id="ca8e2-120">Предыдущий удаляемый объект должен существовать в пределах заданной области.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-120">The preceding disposable is intended to have a scoped lifetime.</span></span>

:::code language="csharp" source="snippets/configuration/console-di-disposable/SingletonDisposable.cs":::

<span data-ttu-id="ca8e2-121">Предыдущий удаляемый объект должен существовать только в одном экземпляре.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-121">The preceding disposable is intended to have a singleton lifetime.</span></span>

:::code language="csharp" source="snippets/configuration/console-di-disposable/Program.cs" range="1-21,41-60" highlight="":::

<span data-ttu-id="ca8e2-122">Консоль отладки после выполнения отображает следующие выходные данные:</span><span class="sxs-lookup"><span data-stu-id="ca8e2-122">The debug console shows the following sample output after running:</span></span>

```console
Scope 1...
ScopedDisposable.Dispose()
TransientDisposable.Dispose()

Scope 2...
ScopedDisposable.Dispose()
TransientDisposable.Dispose()

info: Microsoft.Hosting.Lifetime[0]
      Application started.Press Ctrl+C to shut down.
info: Microsoft.Hosting.Lifetime[0]
     Hosting environment: Production
info: Microsoft.Hosting.Lifetime[0]
     Content root path: .\configuration\console-di-disposable\bin\Debug\net5.0
info: Microsoft.Hosting.Lifetime[0]
     Application is shutting down...
SingletonDisposable.Dispose()
```

### <a name="services-not-created-by-the-service-container"></a><span data-ttu-id="ca8e2-123">Службы, не созданные контейнером службы</span><span class="sxs-lookup"><span data-stu-id="ca8e2-123">Services not created by the service container</span></span>

<span data-ttu-id="ca8e2-124">Рассмотрим следующий код.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-124">Consider the following code:</span></span>

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddSingleton(new ExampleService());

    // ...
}
```

<span data-ttu-id="ca8e2-125">В приведенном выше коде:</span><span class="sxs-lookup"><span data-stu-id="ca8e2-125">In the preceding code:</span></span>

- <span data-ttu-id="ca8e2-126">Экземпляр `ExampleService` **не** создается контейнером службы.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-126">The `ExampleService` instance is **not** created by the service container.</span></span>
- <span data-ttu-id="ca8e2-127">Платформа **не** удаляет службы автоматически.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-127">The framework does **not** dispose of the services automatically.</span></span>
- <span data-ttu-id="ca8e2-128">За удаление служб отвечает разработчик.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-128">The developer is responsible for disposing the services.</span></span>

### <a name="idisposable-guidance-for-transient-and-shared-instances"></a><span data-ttu-id="ca8e2-129">Руководство по применению временных и общих экземпляров IDisposable</span><span class="sxs-lookup"><span data-stu-id="ca8e2-129">IDisposable guidance for Transient and shared instances</span></span>

#### <a name="transient-limited-lifetime"></a><span data-ttu-id="ca8e2-130">Временный экземпляр, ограниченное время существования</span><span class="sxs-lookup"><span data-stu-id="ca8e2-130">Transient, limited lifetime</span></span>

<span data-ttu-id="ca8e2-131">**Сценарий**</span><span class="sxs-lookup"><span data-stu-id="ca8e2-131">**Scenario**</span></span>

<span data-ttu-id="ca8e2-132">Приложению требуется экземпляр <xref:System.IDisposable> с ограниченным временем существования для реализации любого из следующих сценариев:</span><span class="sxs-lookup"><span data-stu-id="ca8e2-132">The app requires an <xref:System.IDisposable> instance with a transient lifetime for either of the following scenarios:</span></span>

- <span data-ttu-id="ca8e2-133">Экземпляр разрешается в корневой области (в корневом контейнере).</span><span class="sxs-lookup"><span data-stu-id="ca8e2-133">The instance is resolved in the root scope (root container).</span></span>
- <span data-ttu-id="ca8e2-134">Экземпляр должен быть удален до завершения области.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-134">The instance should be disposed before the scope ends.</span></span>

<span data-ttu-id="ca8e2-135">**Решение**</span><span class="sxs-lookup"><span data-stu-id="ca8e2-135">**Solution**</span></span>

<span data-ttu-id="ca8e2-136">Используйте шаблон фабрики для создания экземпляра за пределами родительской области.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-136">Use the factory pattern to create an instance outside of the parent scope.</span></span> <span data-ttu-id="ca8e2-137">В этом случае приложение обычно имеет метод `Create`, который непосредственно вызывает конструктор окончательного типа.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-137">In this situation, the app would generally have a `Create` method that calls the final type's constructor directly.</span></span> <span data-ttu-id="ca8e2-138">Если окончательный тип имеет другие зависимости, фабрика позволяет:</span><span class="sxs-lookup"><span data-stu-id="ca8e2-138">If the final type has other dependencies, the factory can:</span></span>

- <span data-ttu-id="ca8e2-139">Получить <xref:System.IServiceProvider> в своем конструкторе.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-139">Receive an <xref:System.IServiceProvider> in its constructor.</span></span>
- <span data-ttu-id="ca8e2-140">Используйте <xref:Microsoft.Extensions.DependencyInjection.ActivatorUtilities.CreateInstance%2A?displayProperty=nameWithType>, чтобы создать экземпляр за пределами контейнера, используя контейнер для его зависимостей.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-140">Use <xref:Microsoft.Extensions.DependencyInjection.ActivatorUtilities.CreateInstance%2A?displayProperty=nameWithType> to instantiate the instance outside of the container, while using the container for its dependencies.</span></span>

#### <a name="shared-instance-limited-lifetime"></a><span data-ttu-id="ca8e2-141">Общий экземпляр, ограниченное время существования</span><span class="sxs-lookup"><span data-stu-id="ca8e2-141">Shared instance, limited lifetime</span></span>

<span data-ttu-id="ca8e2-142">**Сценарий**</span><span class="sxs-lookup"><span data-stu-id="ca8e2-142">**Scenario**</span></span>

<span data-ttu-id="ca8e2-143">Приложению требуется общий экземпляр <xref:System.IDisposable> в нескольких службах, но для экземпляра <xref:System.IDisposable> требуется ограниченное время существования.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-143">The app requires a shared <xref:System.IDisposable> instance across multiple services, but the <xref:System.IDisposable> instance should have a limited lifetime.</span></span>

<span data-ttu-id="ca8e2-144">**Решение**</span><span class="sxs-lookup"><span data-stu-id="ca8e2-144">**Solution**</span></span>

<span data-ttu-id="ca8e2-145">Зарегистрируйте экземпляр с временем существования с заданной областью.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-145">Register the instance with a scoped lifetime.</span></span> <span data-ttu-id="ca8e2-146">Используйте <xref:Microsoft.Extensions.DependencyInjection.IServiceScopeFactory.CreateScope%2A?displayProperty=nameWithType> для создания нового <xref:Microsoft.Extensions.DependencyInjection.IServiceScope>.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-146">Use <xref:Microsoft.Extensions.DependencyInjection.IServiceScopeFactory.CreateScope%2A?displayProperty=nameWithType> to create a new <xref:Microsoft.Extensions.DependencyInjection.IServiceScope>.</span></span> <span data-ttu-id="ca8e2-147">Используйте <xref:System.IServiceProvider> области для получения необходимых служб.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-147">Use the scope's <xref:System.IServiceProvider> to get required services.</span></span> <span data-ttu-id="ca8e2-148">Удалите область, если она больше не нужна.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-148">Dispose the scope when it's no longer needed.</span></span>

#### <a name="general-idisposable-guidelines"></a><span data-ttu-id="ca8e2-149">Общие рекомендации для `IDisposable`</span><span class="sxs-lookup"><span data-stu-id="ca8e2-149">General `IDisposable` guidelines</span></span>

- <span data-ttu-id="ca8e2-150">Не регистрируйте экземпляры <xref:System.IDisposable> с временным временем существования.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-150">Don't register <xref:System.IDisposable> instances with a transient lifetime.</span></span> <span data-ttu-id="ca8e2-151">Вместо этого используйте шаблон фабрики.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-151">Use the factory pattern instead.</span></span>
- <span data-ttu-id="ca8e2-152">Не разрешайте экземпляры <xref:System.IDisposable> с временным временем существования или временем существования с заданной областью в корневую область.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-152">Don't resolve <xref:System.IDisposable> instances with a transient or scoped lifetime in the root scope.</span></span> <span data-ttu-id="ca8e2-153">Единственное исключение — это когда приложение создает или повторно создает и удаляет <xref:System.IServiceProvider>, но это не является идеальным вариантом.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-153">The only exception to this is if the app creates/recreates and disposes <xref:System.IServiceProvider>, but this isn't an ideal pattern.</span></span>
- <span data-ttu-id="ca8e2-154">Для получения зависимости <xref:System.IDisposable> через DI не требуется, чтобы получатель реализовывал сам интерфейс <xref:System.IDisposable>.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-154">Receiving an <xref:System.IDisposable> dependency via DI doesn't require that the receiver implement <xref:System.IDisposable> itself.</span></span> <span data-ttu-id="ca8e2-155">Получатель зависимости <xref:System.IDisposable> не должен вызывать <xref:System.IDisposable.Dispose%2A> для этой зависимости.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-155">The receiver of the <xref:System.IDisposable> dependency shouldn't call <xref:System.IDisposable.Dispose%2A> on that dependency.</span></span>
- <span data-ttu-id="ca8e2-156">Области должны использоваться для управления временем существования служб.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-156">Use scopes to control the lifetimes of services.</span></span> <span data-ttu-id="ca8e2-157">Области не являются иерархическими, и между ними нет специальной связи.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-157">Scopes aren't hierarchical, and there's no special connection among scopes.</span></span>

<span data-ttu-id="ca8e2-158">Дополнительные сведения об очистке ресурсов см. в статьях [Реализация метода `Dispose`](../../standard/garbage-collection/implementing-dispose.md)или [Реализация метода `DisposeAsync`](../../standard/garbage-collection/implementing-disposeasync.md).</span><span class="sxs-lookup"><span data-stu-id="ca8e2-158">For more information on resource cleanup, see [Implement a `Dispose` method](../../standard/garbage-collection/implementing-dispose.md), or [Implement a `DisposeAsync` method](../../standard/garbage-collection/implementing-disposeasync.md).</span></span> <span data-ttu-id="ca8e2-159">Кроме того, изучите сценарий [Удаляемые временные службы собираются контейнером](#disposable-transient-services-captured-by-container), так как он имеет отношение к очистке ресурсов.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-159">Additionally, consider the [Disposable transient services captured by container](#disposable-transient-services-captured-by-container) scenario as it relates to resource cleanup.</span></span>

## <a name="default-service-container-replacement"></a><span data-ttu-id="ca8e2-160">Замена стандартного контейнера служб</span><span class="sxs-lookup"><span data-stu-id="ca8e2-160">Default service container replacement</span></span>

<span data-ttu-id="ca8e2-161">Встроенный контейнер служб предназначен для удовлетворения потребностей платформы и большинства клиентских приложений.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-161">The built-in service container is designed to serve the needs of the framework and most consumer apps.</span></span> <span data-ttu-id="ca8e2-162">Мы рекомендуем использовать встроенный контейнер, если только не требуется конкретная функциональная возможность, которую он не поддерживает, например:</span><span class="sxs-lookup"><span data-stu-id="ca8e2-162">We recommend using the built-in container unless you need a specific feature that it doesn't support, such as:</span></span>

- <span data-ttu-id="ca8e2-163">Внедрение свойств</span><span class="sxs-lookup"><span data-stu-id="ca8e2-163">Property injection</span></span>
- <span data-ttu-id="ca8e2-164">Внедрение по имени</span><span class="sxs-lookup"><span data-stu-id="ca8e2-164">Injection based on name</span></span>
- <span data-ttu-id="ca8e2-165">Дочерние контейнеры</span><span class="sxs-lookup"><span data-stu-id="ca8e2-165">Child containers</span></span>
- <span data-ttu-id="ca8e2-166">Настраиваемое управление временем существования</span><span class="sxs-lookup"><span data-stu-id="ca8e2-166">Custom lifetime management</span></span>
- <span data-ttu-id="ca8e2-167">`Func<T>` поддерживает отложенную инициализацию</span><span class="sxs-lookup"><span data-stu-id="ca8e2-167">`Func<T>` support for lazy initialization</span></span>
- <span data-ttu-id="ca8e2-168">Регистрация на основе соглашения</span><span class="sxs-lookup"><span data-stu-id="ca8e2-168">Convention-based registration</span></span>

<span data-ttu-id="ca8e2-169">С приложениями ASP.NET Core можно использовать следующие сторонние контейнеры:</span><span class="sxs-lookup"><span data-stu-id="ca8e2-169">The following third-party containers can be used with ASP.NET Core apps:</span></span>

- <span data-ttu-id="ca8e2-170">[Autofac](https://autofac.readthedocs.io/en/latest/integration/aspnetcore.html);</span><span class="sxs-lookup"><span data-stu-id="ca8e2-170">[Autofac](https://autofac.readthedocs.io/en/latest/integration/aspnetcore.html)</span></span>
- <span data-ttu-id="ca8e2-171">[DryIoc](https://www.nuget.org/packages/DryIoc.Microsoft.DependencyInjection);</span><span class="sxs-lookup"><span data-stu-id="ca8e2-171">[DryIoc](https://www.nuget.org/packages/DryIoc.Microsoft.DependencyInjection)</span></span>
- <span data-ttu-id="ca8e2-172">[Grace](https://www.nuget.org/packages/Grace.DependencyInjection.Extensions);</span><span class="sxs-lookup"><span data-stu-id="ca8e2-172">[Grace](https://www.nuget.org/packages/Grace.DependencyInjection.Extensions)</span></span>
- <span data-ttu-id="ca8e2-173">[LightInject](https://github.com/seesharper/LightInject.Microsoft.DependencyInjection);</span><span class="sxs-lookup"><span data-stu-id="ca8e2-173">[LightInject](https://github.com/seesharper/LightInject.Microsoft.DependencyInjection)</span></span>
- <span data-ttu-id="ca8e2-174">[Lamar](https://jasperfx.github.io/lamar/);</span><span class="sxs-lookup"><span data-stu-id="ca8e2-174">[Lamar](https://jasperfx.github.io/lamar/)</span></span>
- <span data-ttu-id="ca8e2-175">[Stashbox](https://github.com/z4kn4fein/stashbox-extensions-dependencyinjection);</span><span class="sxs-lookup"><span data-stu-id="ca8e2-175">[Stashbox](https://github.com/z4kn4fein/stashbox-extensions-dependencyinjection)</span></span>
- [<span data-ttu-id="ca8e2-176">Unity</span><span class="sxs-lookup"><span data-stu-id="ca8e2-176">Unity</span></span>](https://www.nuget.org/packages/Unity.Microsoft.DependencyInjection)

## <a name="thread-safety"></a><span data-ttu-id="ca8e2-177">Потокобезопасность</span><span class="sxs-lookup"><span data-stu-id="ca8e2-177">Thread safety</span></span>

<span data-ttu-id="ca8e2-178">Создавайте потокобезопасные одноэлементные службы.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-178">Create thread-safe singleton services.</span></span> <span data-ttu-id="ca8e2-179">Если одноэлементная служба имеет зависимость от временной службы, с учетом характера использования одноэлементной службой к этой временной службе также может предъявляться требование потокобезопасности.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-179">If a singleton service has a dependency on a transient service, the transient service may also require thread safety depending on how it's used by the singleton.</span></span>

<span data-ttu-id="ca8e2-180">Фабричный метод отдельной службы, например второй аргумент в [AddSingleton\<TService>(IServiceCollection, Func\<IServiceProvider,TService>)](xref:Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddSingleton%2A), не обязательно должен быть потокобезопасным.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-180">The factory method of a singleton service, such as the second argument to [AddSingleton\<TService>(IServiceCollection, Func\<IServiceProvider,TService>)](xref:Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddSingleton%2A), doesn't need to be thread-safe.</span></span> <span data-ttu-id="ca8e2-181">Как и конструктор типов (`static`), он гарантированно будет вызываться только один раз одним потоком.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-181">Like a type (`static`) constructor, it's guaranteed to be called only once by a single thread.</span></span>

## <a name="recommendations"></a><span data-ttu-id="ca8e2-182">Рекомендации</span><span class="sxs-lookup"><span data-stu-id="ca8e2-182">Recommendations</span></span>

- <span data-ttu-id="ca8e2-183">Разрешение служб на основе `async/await` и `Task` не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-183">`async/await` and `Task` based service resolution isn't supported.</span></span> <span data-ttu-id="ca8e2-184">Так как C# не поддерживает асинхронные конструкторы, следует использовать асинхронные методы после асинхронного разрешения службы.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-184">Because C# doesn't support asynchronous constructors, use asynchronous methods after synchronously resolving the service.</span></span>
- <span data-ttu-id="ca8e2-185">Не храните данные и конфигурацию непосредственно в контейнере служб.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-185">Avoid storing data and configuration directly in the service container.</span></span> <span data-ttu-id="ca8e2-186">Например, обычно не следует добавлять корзину пользователя в контейнер служб.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-186">For example, a user's shopping cart shouldn't typically be added to the service container.</span></span> <span data-ttu-id="ca8e2-187">Конфигурация должна использовать шаблон параметров.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-187">Configuration should use the options pattern.</span></span> <span data-ttu-id="ca8e2-188">Аналогичным образом, избегайте объектов "хранения данных", которые служат лишь для доступа к другому объекту.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-188">Similarly, avoid "data holder" objects that only exist to allow access to another object.</span></span> <span data-ttu-id="ca8e2-189">Лучше запросить фактический элемент через внедрение зависимостей.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-189">It's better to request the actual item via DI.</span></span>
- <span data-ttu-id="ca8e2-190">Избегайте статического доступа к службам.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-190">Avoid static access to services.</span></span> <span data-ttu-id="ca8e2-191">Например, не используйте везде [IApplicationBuilder.ApplicationServices](xref:Microsoft.AspNetCore.Builder.IApplicationBuilder.ApplicationServices) в качестве статического поля или свойства.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-191">For example, avoid capturing [IApplicationBuilder.ApplicationServices](xref:Microsoft.AspNetCore.Builder.IApplicationBuilder.ApplicationServices) as a static field or property for use elsewhere.</span></span>
- <span data-ttu-id="ca8e2-192">Обеспечьте высокую скорость и синхронизацию [фабрик DI](#async-di-factories-can-cause-deadlocks).</span><span class="sxs-lookup"><span data-stu-id="ca8e2-192">Keep [DI factories](#async-di-factories-can-cause-deadlocks) fast and synchronous.</span></span>
- <span data-ttu-id="ca8e2-193">Старайтесь не использовать [*шаблон обнаружения служб*](#scoped-service-as-singleton).</span><span class="sxs-lookup"><span data-stu-id="ca8e2-193">Avoid using the [*service locator pattern*](#scoped-service-as-singleton).</span></span> <span data-ttu-id="ca8e2-194">Например, не вызывайте <xref:System.IServiceProvider.GetService%2A> для получения экземпляра службы, когда можно использовать внедрение зависимостей.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-194">For example, don't invoke <xref:System.IServiceProvider.GetService%2A> to obtain a service instance when you can use DI instead.</span></span>
- <span data-ttu-id="ca8e2-195">Другой вариант указателя службы, позволяющий избежать этого, — внедрение фабрики, которая разрешает зависимости во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-195">Another service locator variation to avoid is injecting a factory that resolves dependencies at runtime.</span></span> <span data-ttu-id="ca8e2-196">Оба метода смешивают стратегии [инверсии управления](/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles#dependency-inversion).</span><span class="sxs-lookup"><span data-stu-id="ca8e2-196">Both of these practices mix [Inversion of Control](/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles#dependency-inversion) strategies.</span></span>
- <span data-ttu-id="ca8e2-197">Избегайте вызовов <xref:Microsoft.Extensions.DependencyInjection.ServiceCollectionContainerBuilderExtensions.BuildServiceProvider%2A> в `ConfigureServices`.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-197">Avoid calls to <xref:Microsoft.Extensions.DependencyInjection.ServiceCollectionContainerBuilderExtensions.BuildServiceProvider%2A> in `ConfigureServices`.</span></span> <span data-ttu-id="ca8e2-198">Вызов `BuildServiceProvider` обычно происходит, когда разработчику необходимо разрешить службу в `ConfigureServices`.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-198">Calling `BuildServiceProvider` typically happens when the developer wants to resolve a service in `ConfigureServices`.</span></span>
- <span data-ttu-id="ca8e2-199">[Контейнер собирает удаляемые временные службы](#disposable-transient-services-captured-by-container) для удаления.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-199">[Disposable transient services are captured](#disposable-transient-services-captured-by-container) by the container for disposal.</span></span> <span data-ttu-id="ca8e2-200">Это может привести к утечке памяти, если разрешение выполняется в контейнере верхнего уровня.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-200">This can turn into a memory leak if resolved from the top-level container.</span></span>
- <span data-ttu-id="ca8e2-201">Включите проверку области, чтобы убедиться, что в приложении нет отдельных объектов, записывающих службы с заданной областью.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-201">Enable scope validation to make sure the app doesn't have singletons that capture scoped services.</span></span> <span data-ttu-id="ca8e2-202">Дополнительные сведения см. в разделе [Проверка области](dependency-injection.md#scope-validation).</span><span class="sxs-lookup"><span data-stu-id="ca8e2-202">For more information, see [Scope validation](dependency-injection.md#scope-validation).</span></span>

<span data-ttu-id="ca8e2-203">Как и с любыми рекомендациями, у вас могут возникнуть ситуации, когда нужно отступить от одного из правил.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-203">Like all sets of recommendations, you may encounter situations where ignoring a recommendation is required.</span></span> <span data-ttu-id="ca8e2-204">Исключения возникают редко, — как правило, это особые случаи, связанные с самой платформой.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-204">Exceptions are rare, mostly special cases within the framework itself.</span></span>

<span data-ttu-id="ca8e2-205">Внедрение зависимостей является *альтернативой* для шаблонов доступа к статическим или глобальным объектам.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-205">DI is an *alternative* to static/global object access patterns.</span></span> <span data-ttu-id="ca8e2-206">Вы не сможете воспользоваться преимуществами внедрения зависимостей, если будете сочетать его с доступом к статическим объектам.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-206">You may not be able to realize the benefits of DI if you mix it with static object access.</span></span>

## <a name="example-anti-patterns"></a><span data-ttu-id="ca8e2-207">Примеры антишаблонов</span><span class="sxs-lookup"><span data-stu-id="ca8e2-207">Example anti-patterns</span></span>

<span data-ttu-id="ca8e2-208">В дополнение к основным рекомендациям этой статьи мы рекомендуем изучить несколько антишаблонов, *которых **следует** избегать*.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-208">In addition to the guidelines in this article, there are several anti-patterns *you **should** avoid*.</span></span> <span data-ttu-id="ca8e2-209">Некоторые из этих антишаблонов основаны на опыте, полученном при разработке самих сред выполнения.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-209">Some of these anti-patterns are learnings from developing the runtimes themselves.</span></span>

> [!WARNING]
> <span data-ttu-id="ca8e2-210">Это примеры антишаблонов. *Не* копируйте этот код и ни в коем случае *не* используйте такие действия.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-210">These are example anti-patterns, *do not* copy the code, *do not* use these patterns, and avoid these patterns at all costs.</span></span>

### <a name="disposable-transient-services-captured-by-container"></a><span data-ttu-id="ca8e2-211">Контейнер собирает удаляемые временные службы</span><span class="sxs-lookup"><span data-stu-id="ca8e2-211">Disposable transient services captured by container</span></span>

<span data-ttu-id="ca8e2-212">При регистрации *временных* служб, которые реализуют <xref:System.IDisposable>, по умолчанию контейнер внедрения будет удерживать эти ссылки, не избавляясь от них методом <xref:System.IDisposable.Dispose>, пока не будет удален сам контейнер — то есть когда остановится приложение, если ссылки были разрешены из контейнера, или будет удалена область действия, если они были разрешены из этой области.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-212">When you register *Transient* services that implement <xref:System.IDisposable>, by default the DI container will hold onto these references, and not <xref:System.IDisposable.Dispose> of them until the container is disposed when application stops if they were resolved from the container, or until the scope is disposed if they were resolved from a scope.</span></span> <span data-ttu-id="ca8e2-213">Это может привести к утечке памяти, если разрешение выполняется на уровне контейнера.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-213">This can turn into a memory leak if resolved from container level.</span></span>

:::code language="csharp" source="snippets/configuration/di-anti-patterns/Program.cs" range="18-30":::

<span data-ttu-id="ca8e2-214">В предыдущем антишаблоне создаются и размещаются на корневом уровне экземпляры 1000 объектов `ExampleDisposable`.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-214">In the preceding anti-pattern, 1,000 `ExampleDisposable` objects are instantiated and rooted.</span></span> <span data-ttu-id="ca8e2-215">Они не будут удалены, пока существует экземпляр `serviceProvider`.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-215">They will not be disposed of until the `serviceProvider` instance is disposed.</span></span>

<span data-ttu-id="ca8e2-216">Дополнительные сведения об отладке утечек памяти см. в статье [Отладка утечки памяти в .NET Core](../diagnostics/debug-memory-leak.md).</span><span class="sxs-lookup"><span data-stu-id="ca8e2-216">For more information on debugging memory leaks, see [Debug a memory leak in .NET](../diagnostics/debug-memory-leak.md).</span></span>

### <a name="async-di-factories-can-cause-deadlocks"></a><span data-ttu-id="ca8e2-217">Фабрики асинхронного внедрения могут вызвать взаимоблокировки</span><span class="sxs-lookup"><span data-stu-id="ca8e2-217">Async DI factories can cause deadlocks</span></span>

<span data-ttu-id="ca8e2-218">Термин "фабрики асинхронного внедрения" обозначает методы перегрузки, которые существуют при вызове `Add{LIFETIME}`.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-218">The term "DI factories" refers to the overload methods that exist when calling `Add{LIFETIME}`.</span></span> <span data-ttu-id="ca8e2-219">Некоторые перегрузки принимают `Func<IServiceProvider, T>`, где `T` обозначает регистрируемую службу, а параметр имеет имя `implementationFactory`.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-219">There are overloads accepting a `Func<IServiceProvider, T>` where `T` is the service being registered, and the parameter is named `implementationFactory`.</span></span> <span data-ttu-id="ca8e2-220">`implementationFactory` можно предоставить как лямбда-выражение, локальную функцию или метод.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-220">The `implementationFactory` can be provided as a lambda expression, local function, or method.</span></span> <span data-ttu-id="ca8e2-221">Если фабрика является асинхронной и используется <xref:System.Threading.Tasks.Task%601.Result?displayProperty=nameWithType>, происходит взаимоблокировка.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-221">If the factory is asynchronous, and you use <xref:System.Threading.Tasks.Task%601.Result?displayProperty=nameWithType>, this will cause a deadlock.</span></span>

:::code language="csharp" source="snippets/configuration/di-anti-patterns/Program.cs" range="32-45" highlight="4-8":::

<span data-ttu-id="ca8e2-222">В приведенном выше коде объект `implementationFactory` получает лямбда-выражение, в котором тело вызывает <xref:System.Threading.Tasks.Task%601.Result?displayProperty=nameWithType> для метода возврата `Task<Bar>`.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-222">In the preceding code, the `implementationFactory` is given a lambda expression where the body calls <xref:System.Threading.Tasks.Task%601.Result?displayProperty=nameWithType> on a `Task<Bar>` returning method.</span></span> <span data-ttu-id="ca8e2-223">Это ***вызывает взаимоблокировку***.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-223">This ***causes a deadlock***.</span></span> <span data-ttu-id="ca8e2-224">Метод `GetBarAsync` эмулирует асинхронную работу с использованием <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType>, а затем вызывает <xref:Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService%60%601(System.IServiceProvider)>.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-224">The `GetBarAsync` method simply emulates an asynchronous work operation with <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType>, and then calls <xref:Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService%60%601(System.IServiceProvider)>.</span></span>

:::code language="csharp" source="snippets/configuration/di-anti-patterns/Program.cs" range="47-53":::

<span data-ttu-id="ca8e2-225">Дополнительные сведения об асинхронной работе см. в статье [Асинхронное программирование: важная информация и советы](../../csharp/async.md#important-info-and-advice).</span><span class="sxs-lookup"><span data-stu-id="ca8e2-225">For more information on asynchronous guidance, see [Asynchronous programming: Important info and advice](../../csharp/async.md#important-info-and-advice).</span></span> <span data-ttu-id="ca8e2-226">Дополнительные сведения об отладке взаимоблокировок см. в статье [Отладка взаимоблокировки в .NET Core](../diagnostics/debug-deadlock.md).</span><span class="sxs-lookup"><span data-stu-id="ca8e2-226">For more information debugging deadlocks, see [Debug a deadlock in .NET](../diagnostics/debug-deadlock.md).</span></span>

<span data-ttu-id="ca8e2-227">Когда при использовании этого антишаблона возникает взаимоблокировка, вы можете изучить два ожидающих потока в окне параллельных стеков Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-227">When you're running this anti-pattern and the deadlock occurs, you can view the two threads waiting from Visual Studio's Parallel Stacks window.</span></span> <span data-ttu-id="ca8e2-228">Дополнительные сведения см. в статье о [просмотре потоков и задач в окне "Параллельные стеки"](/visualstudio/debugger/using-the-parallel-stacks-window).</span><span class="sxs-lookup"><span data-stu-id="ca8e2-228">For more information, see [View threads and tasks in the Parallel Stacks window](/visualstudio/debugger/using-the-parallel-stacks-window).</span></span>

### <a name="captive-dependency"></a><span data-ttu-id="ca8e2-229">Зависимость с захватом</span><span class="sxs-lookup"><span data-stu-id="ca8e2-229">Captive dependency</span></span>

<span data-ttu-id="ca8e2-230">Термин ["зависимость с захватом"](https://blog.ploeh.dk/2014/06/02/captive-dependency) был предложен [Марком Симаном](https://blog.ploeh.dk/about) (Mark Seeman) для обозначения ситуаций с неверной настройкой времени существования службы, когда более длительно выполняемая служба "захватывает" службы с более коротким временем существования.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-230">The term ["captive dependency"](https://blog.ploeh.dk/2014/06/02/captive-dependency) was coined by [Mark Seeman](https://blog.ploeh.dk/about), and refers to the misconfiguration of service lifetimes, where a longer-lived service holds a shorter-lived service captive.</span></span>

:::code language="csharp" source="snippets/configuration/di-anti-patterns/Program.cs" range="55-65":::

<span data-ttu-id="ca8e2-231">В приведенном выше коде `Foo` регистрируется как служба с одним экземпляром, а для `Bar` ограничена область действия. На первый взгляд, все нормально.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-231">In the preceding code, `Foo` is registered as a singleton and `Bar` is scoped - which on the surface seems valid.</span></span> <span data-ttu-id="ca8e2-232">Но давайте рассмотрим реализацию `Foo`.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-232">However, consider the implementation of `Foo`.</span></span>

:::code language="csharp" source="snippets/configuration/di-anti-patterns/Foo.cs" highlight="5":::

<span data-ttu-id="ca8e2-233">Объекту `Foo` требуется объект `Bar`, и возникает ошибка конфигурации, так как `Foo` работает с одним экземпляром, а `Bar` имеет ограниченную область действия.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-233">The `Foo` object requires a `Bar` object, and since `Foo` is a singleton, and `Bar` is scoped - this is a misconfiguration.</span></span> <span data-ttu-id="ca8e2-234">В таком варианте экземпляр `Foo` будет создан только один раз, и он будет удерживать `Bar` в течение всего времени существования, что превышает предполагаемое время существования для службы `Bar` с ограниченной областью действия.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-234">As is, `Foo` would only be instantiated once, and it would hold onto `Bar` for its lifetime, which is longer than the intended scoped lifetime of `Bar`.</span></span> <span data-ttu-id="ca8e2-235">Мы рекомендуем проверить области, передав `validateScopes: true` в <xref:Microsoft.Extensions.DependencyInjection.ServiceCollectionContainerBuilderExtensions.BuildServiceProvider(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Boolean)>.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-235">You should consider validating scopes, by passing `validateScopes: true` to the <xref:Microsoft.Extensions.DependencyInjection.ServiceCollectionContainerBuilderExtensions.BuildServiceProvider(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Boolean)>.</span></span> <span data-ttu-id="ca8e2-236">При проверке областей вы получите сообщение <xref:System.InvalidOperationException>, похожее на строку "Не удается использовать службу "Bar" с заданной областью из службы "Foo" с одним экземпляром".</span><span class="sxs-lookup"><span data-stu-id="ca8e2-236">When you validate the scopes, you'd get an <xref:System.InvalidOperationException> with a message similar to "Cannot consume scoped service 'Bar' from singleton 'Foo'.".</span></span>

<span data-ttu-id="ca8e2-237">Дополнительные сведения см. в разделе [Проверка области](dependency-injection.md#scope-validation).</span><span class="sxs-lookup"><span data-stu-id="ca8e2-237">For more information, see [Scope validation](dependency-injection.md#scope-validation).</span></span>

### <a name="scoped-service-as-singleton"></a><span data-ttu-id="ca8e2-238">Выполнение в одном экземпляре службы с заданной областью</span><span class="sxs-lookup"><span data-stu-id="ca8e2-238">Scoped service as singleton</span></span>

<span data-ttu-id="ca8e2-239">При использовании служб с заданной областью, если вы не создаете область или используете ее в существующей области, она становится службой с одним экземпляром.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-239">When using scoped services, if you're not creating a scope or within an existing scope - the service becomes a singleton.</span></span>

:::code language="csharp" source="snippets/configuration/di-anti-patterns/Program.cs" range="68-82" highlight="13-14":::

<span data-ttu-id="ca8e2-240">В приведенном выше коде `Bar` извлекается в <xref:Microsoft.Extensions.DependencyInjection.IServiceScope>, что является верным.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-240">In the preceding code, `Bar` is retrieved within an <xref:Microsoft.Extensions.DependencyInjection.IServiceScope>, which is correct.</span></span> <span data-ttu-id="ca8e2-241">Антишаблоном здесь будет извлечение `Bar` вне пределов области, и имя переменной `avoid` подсказывает нам, какой пример извлечения неправилен.</span><span class="sxs-lookup"><span data-stu-id="ca8e2-241">The anti-pattern is the retrieval of `Bar` outside of the scope, and the variable is named `avoid` to show which example retrieval is incorrect.</span></span>

## <a name="see-also"></a><span data-ttu-id="ca8e2-242">См. также раздел</span><span class="sxs-lookup"><span data-stu-id="ca8e2-242">See also</span></span>

- [<span data-ttu-id="ca8e2-243">Внедрение зависимостей в .NET</span><span class="sxs-lookup"><span data-stu-id="ca8e2-243">Dependency injection in .NET</span></span>](dependency-injection.md)
- [<span data-ttu-id="ca8e2-244">Руководство. Использование внедрения зависимостей в .NET</span><span class="sxs-lookup"><span data-stu-id="ca8e2-244">Tutorial: Use dependency injection in .NET</span></span>](dependency-injection-usage.md)
