---
title: 'CA1033: методы интерфейса должны быть доступны для вызова дочерними типами (анализ кода)'
description: 'Сведения о правиле анализа кода "CA1033: методы интерфейса должны быть доступны для вызова дочерними типами"'
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- InterfaceMethodsShouldBeCallableByChildTypes
- CA1033
helpviewer_keywords:
- CA1033
- InterfaceMethodsShouldBeCallableByChildTypes
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 3ffd037a109153fa5767b74c6d96f19b47e024cb
ms.sourcegitcommit: 05d0087dfca85aac9ca2960f86c5efd218bf833f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/30/2021
ms.locfileid: "99547249"
---
# <a name="ca1033-interface-methods-should-be-callable-by-child-types"></a>CA1033. Методы интерфейса должны быть доступны для вызова дочерними типами

| Элемент                                     | Значение            |
|------------------------------------------|------------------|
| Идентификатор правила                                   | CA1033           |
| Категория                                 | [Microsoft.Design](design-warnings.md) |
| Исправление является критическим или не критическим | Не критическое     |

## <a name="cause"></a>Причина

Незапечатанный тип, доступный для внешнего кода, предоставляет явную реализацию метода открытого интерфейса и не предоставляет доступный для внешнего кода альтернативный метод с тем же именем.

## <a name="rule-description"></a>Описание правила

Рассмотрим базовый тип, который явно реализует общий метод интерфейса. Тип, производный от базового типа, может обращаться к унаследованному методу интерфейса только с помощью ссылки на текущий экземпляр (`this` в C#), приведенный к интерфейсу. Если производный тип повторно реализует (явным образом) наследуемый метод интерфейса, базовая реализация становится недоступной. Вызов с помощью ссылки на текущий экземпляр вызовет производную реализацию. Это приведет к рекурсии и в конечном итоге переполнению стека.

Это правило не сообщает о нарушении явной реализации <xref:System.IDisposable.Dispose%2A?displayProperty=fullName>, если предоставлен видимый снаружи метод `Close()` или `System.IDisposable.Dispose(Boolean)`.

## <a name="how-to-fix-violations"></a>Устранение нарушений

Чтобы устранить нарушение этого правила, реализуйте новый метод, который предоставляет те же функциональные возможности, но при этом является видимым для производных типов, или замените на неявную реализацию. Если критическое изменение допустимо, можно также сделать тип запечатанным.

## <a name="when-to-suppress-warnings"></a>Условия для отключения предупреждений

Предупреждение из этого правила можно отключить, если предоставляется видимый извне метод, имеющий те же функциональные возможности, но с именем, отличным от имени явно реализованного метода.

[!INCLUDE [suppress-warning](../../../../includes/code-analysis/suppress-warning.md)]

## <a name="example"></a>Пример

В следующем примере показан тип `ViolatingBase`, который нарушает правило, и тип `FixedBase`, демонстрирующий исправление нарушения.

:::code language="csharp" source="snippets/csharp/all-rules/ca1033.cs" id="snippet1":::

## <a name="see-also"></a>См. также раздел

- [Интерфейсы](../../../csharp/programming-guide/interfaces/index.md)
