---
title: 'CA2016: переадресовывать параметр CancellationToken методам, которые его принимают (анализ кода)'
description: 'Сведения о правиле анализа кода CA2016: переадресовывать параметр CancellationToken методам, которые его принимают'
ms.date: 06/18/2020
ms.topic: reference
f1_keywords:
- ForwardCancellationTokenToInvocations
- CA2016
helpviewer_keywords:
- ForwardCancellationTokenToInvocations
- CA2016
author: carlossanlop
ms.author: calope
dev_langs:
- CSharp
- VB
ms.openlocfilehash: b4945e35884f76aa28533ebab840b6a4a4cd2518
ms.sourcegitcommit: 05d0087dfca85aac9ca2960f86c5efd218bf833f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/30/2021
ms.locfileid: "99751980"
---
# <a name="ca2016-forward-the-cancellationtoken-parameter-to-methods-that-take-one"></a><span data-ttu-id="b5283-103">CA2016: Переадресовывать параметр CancellationToken методам, которые его принимают</span><span class="sxs-lookup"><span data-stu-id="b5283-103">CA2016: Forward the CancellationToken parameter to methods that take one</span></span>

| | <span data-ttu-id="b5283-104">Значение</span><span class="sxs-lookup"><span data-stu-id="b5283-104">Value</span></span> |
|-|-|
| <span data-ttu-id="b5283-105">**Имя типа**</span><span class="sxs-lookup"><span data-stu-id="b5283-105">**Type name**</span></span> |<span data-ttu-id="b5283-106">ForwardCancellationTokenToInvocations</span><span class="sxs-lookup"><span data-stu-id="b5283-106">ForwardCancellationTokenToInvocations</span></span>|
| <span data-ttu-id="b5283-107">**Идентификатор правила**</span><span class="sxs-lookup"><span data-stu-id="b5283-107">**Rule ID**</span></span> |<span data-ttu-id="b5283-108">CA2016</span><span class="sxs-lookup"><span data-stu-id="b5283-108">CA2016</span></span>|
| <span data-ttu-id="b5283-109">**Категория**</span><span class="sxs-lookup"><span data-stu-id="b5283-109">**Category**</span></span> |[<span data-ttu-id="b5283-110">Производительность</span><span class="sxs-lookup"><span data-stu-id="b5283-110">Performance</span></span>](performance-warnings.md)|
| <span data-ttu-id="b5283-111">**Исправление является критическим или не критическим**</span><span class="sxs-lookup"><span data-stu-id="b5283-111">**Fix is breaking or non-breaking**</span></span> |<span data-ttu-id="b5283-112">Не критическое</span><span class="sxs-lookup"><span data-stu-id="b5283-112">Non-breaking</span></span>|

## <a name="cause"></a><span data-ttu-id="b5283-113">Причина</span><span class="sxs-lookup"><span data-stu-id="b5283-113">Cause</span></span>

<span data-ttu-id="b5283-114">Это правило находит вызовы методов, которые могут принимать параметр <xref:System.Threading.CancellationToken>, но не передают его. Оно предлагает переадресовывать им `CancellationToken` родительского метода.</span><span class="sxs-lookup"><span data-stu-id="b5283-114">This rule locates method invocations that could accept a <xref:System.Threading.CancellationToken> parameter, but are not passing any, and suggests to forward the parent method's `CancellationToken` to them.</span></span>

## <a name="rule-description"></a><span data-ttu-id="b5283-115">Описание правила</span><span class="sxs-lookup"><span data-stu-id="b5283-115">Rule description</span></span>

<span data-ttu-id="b5283-116">Это правило анализирует определения методов, которые принимают `CancellationToken` в качестве последнего параметра, затем анализирует все методы, вызываемые в его теле.</span><span class="sxs-lookup"><span data-stu-id="b5283-116">This rule analyzes method definitions that take a `CancellationToken` as their last parameter, then analyzes all methods invoked in its body.</span></span> <span data-ttu-id="b5283-117">Если какой-либо вызов метода может принять `CancellationToken` в качестве последнего параметра или у него есть перегрузка, которая принимает `CancellationToken` в качестве последнего параметра, правило предлагает использовать этот параметр вместо того, чтобы убедиться, что уведомление об отмене распространяется на все операции, которые могут его прослушивать.</span><span class="sxs-lookup"><span data-stu-id="b5283-117">If any of the method invocations can either accept a `CancellationToken` as the last parameter, or have an overload that takes a `CancellationToken` as the last parameter, then the rule suggests using that option instead to ensure that the cancellation notification gets propagated to all operations that can listen to it.</span></span>

> [!NOTE]
> <span data-ttu-id="b5283-118">Правило CA2016 доступно во всех версиях .NET, где доступен тип `CancellationToken`.</span><span class="sxs-lookup"><span data-stu-id="b5283-118">Rule CA2016 is available in all .NET versions where the `CancellationToken` type is available.</span></span> <span data-ttu-id="b5283-119">См. [раздел "Применяется к" в статье о CancellationToken](/dotnet/api/system.threading.cancellationtoken#moniker-applies-to)</span><span class="sxs-lookup"><span data-stu-id="b5283-119">See [CancellationToken "Applies to" section](/dotnet/api/system.threading.cancellationtoken#moniker-applies-to)</span></span>

## <a name="how-to-fix-violations"></a><span data-ttu-id="b5283-120">Устранение нарушений</span><span class="sxs-lookup"><span data-stu-id="b5283-120">How to fix violations</span></span>

<span data-ttu-id="b5283-121">Вы можете устранить их вручную или позволить Visual Studio сделать это автоматически, наведя указатель мыши на лампочку рядом с вызовом метода и выбрав предлагаемое изменение.</span><span class="sxs-lookup"><span data-stu-id="b5283-121">You can either fix them manually, or you can opt to let Visual Studio do it for you, by hovering over the light bulb that shows up next to the method invocation, and selecting the suggested change.</span></span>

<span data-ttu-id="b5283-122">В следующем примере показаны два предлагаемых изменения.</span><span class="sxs-lookup"><span data-stu-id="b5283-122">The following example shows two suggested changes:</span></span>

![Правило CA2016: переадресовывать параметр CancellationToken методам, которые его принимают](media/ca2016-diagnose.png)

<span data-ttu-id="b5283-124">Вывод предупреждений для этого правила можно отключить, если вас не беспокоит сокращение числа вызовов методов из-за пересылки уведомлений об отмене операций.</span><span class="sxs-lookup"><span data-stu-id="b5283-124">It's safe to suppress a violation of this rule if you're not concerned about forwarding the canceled operation notification to lower method invocations.</span></span> <span data-ttu-id="b5283-125">Кроме того, можно явным образом передать `default` в C# (`Nothing` в Visual Basic) или <xref:System.Threading.CancellationToken.None>.</span><span class="sxs-lookup"><span data-stu-id="b5283-125">You can also explicitly pass `default` in C# (`Nothing` in Visual Basic) or <xref:System.Threading.CancellationToken.None> to suppress the rule violation.</span></span>

<span data-ttu-id="b5283-126">Правило может обнаруживать различные нарушения.</span><span class="sxs-lookup"><span data-stu-id="b5283-126">The rule can detect a variety of violations.</span></span> <span data-ttu-id="b5283-127">Ниже приведены примеры случаев, которые может обнаруживать это правило.</span><span class="sxs-lookup"><span data-stu-id="b5283-127">The following examples show cases that the rule can detect:</span></span>

### <a name="example-1"></a><span data-ttu-id="b5283-128">Пример 1</span><span class="sxs-lookup"><span data-stu-id="b5283-128">Example 1</span></span>

<span data-ttu-id="b5283-129">Правило предложит переслать параметр `c` из `MyMethod` в вызов `MyMethodWithDefault`, так как метод определяет дополнительный параметр токена:</span><span class="sxs-lookup"><span data-stu-id="b5283-129">The rule will suggest forwarding the `c` parameter from `MyMethod` to the `MyMethodWithDefault` invocation, because the method defines an optional token parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken ct = default)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="b5283-130">Исправление:</span><span class="sxs-lookup"><span data-stu-id="b5283-130">Fix:</span></span>

<span data-ttu-id="b5283-131">Перешлите параметр `c`:</span><span class="sxs-lookup"><span data-stu-id="b5283-131">Forward the `c` parameter:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault(c);
        }
```

<span data-ttu-id="b5283-132">Если вас не беспокоит сокращение числа вызовов методов из-за пересылки уведомлений об отмене, можно выполнить одно из следующих действий.</span><span class="sxs-lookup"><span data-stu-id="b5283-132">If you are not concerned about forwarding cancellation notifications to lower invocations, you can either:</span></span>

<span data-ttu-id="b5283-133">Явным образом передайте `default`:</span><span class="sxs-lookup"><span data-stu-id="b5283-133">Explicitly pass `default`:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault(default);
        }
```

<span data-ttu-id="b5283-134">Или явным образом передайте `CancellationToken.None`:</span><span class="sxs-lookup"><span data-stu-id="b5283-134">Or explicitly pass `CancellationToken.None`:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault(CancellationToken.None);
        }
```

### <a name="example-2"></a><span data-ttu-id="b5283-135">Пример 2</span><span class="sxs-lookup"><span data-stu-id="b5283-135">Example 2</span></span>

<span data-ttu-id="b5283-136">Правило предложит переслать параметр `c` из `MyMethod` в вызов `MyMethodWithDefault`, так как у метода есть перегрузка, которая принимает параметр `CancellationToken`:</span><span class="sxs-lookup"><span data-stu-id="b5283-136">The rule will suggest forwarding the `c` parameter from `MyMethod` to the `MyMethodWithDefault` invocation, because the method has an overload that takes a `CancellationToken` parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithOverload()
        {
        }

        public static void MyMethodWithOverload(CancellationToken ct = default)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload();
        }
    }
}
```

<span data-ttu-id="b5283-137">Исправление:</span><span class="sxs-lookup"><span data-stu-id="b5283-137">Fix:</span></span>

<span data-ttu-id="b5283-138">Перешлите параметр `c`:</span><span class="sxs-lookup"><span data-stu-id="b5283-138">Forward the `c` parameter:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload(c);
        }
```

<span data-ttu-id="b5283-139">Если вас не беспокоит сокращение числа вызовов методов из-за пересылки уведомлений об отмене, можно выполнить одно из следующих действий.</span><span class="sxs-lookup"><span data-stu-id="b5283-139">If you are not concerned about forwarding cancellation notifications to lower invocations, you can either:</span></span>

<span data-ttu-id="b5283-140">Явным образом передайте `default`:</span><span class="sxs-lookup"><span data-stu-id="b5283-140">Explicitly pass `default`:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload(default);
        }
```

<span data-ttu-id="b5283-141">Или явным образом передайте `CancellationToken.None`:</span><span class="sxs-lookup"><span data-stu-id="b5283-141">Or explicitly pass `CancellationToken.None`:</span></span>

```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload(CancellationToken.None);
        }
```

## <a name="non-violation-examples"></a><span data-ttu-id="b5283-142">Примеры ненарушений</span><span class="sxs-lookup"><span data-stu-id="b5283-142">Non-violation examples</span></span>

<span data-ttu-id="b5283-143">Параметр `CancellationToken` в родительском методе не находится в последней позиции:</span><span class="sxs-lookup"><span data-stu-id="b5283-143">The `CancellationToken` parameter in the parent method is not in the last position:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken ct = default)
        {
        }

        public static void MyMethod(CancellationToken c, int lastParameter)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="b5283-144">Параметр `CancellationToken` в методе по умолчанию не находится в последней позиции:</span><span class="sxs-lookup"><span data-stu-id="b5283-144">The `CancellationToken` parameter in the default method is not in the last position:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken ct = default, int lastParameter = 0)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="b5283-145">Параметр `CancellationToken` в методе перегрузки не находится в последней позиции:</span><span class="sxs-lookup"><span data-stu-id="b5283-145">The `CancellationToken` parameter in the overload method is not in the last position:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithOverload(int lastParameter)
        {
        }
        public static void MyMethodWithOverload(CancellationToken ct, int lastParameter)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload();
        }
    }
}
```

<span data-ttu-id="b5283-146">Родительский метод определяет несколько параметров `CancellationToken`:</span><span class="sxs-lookup"><span data-stu-id="b5283-146">The parent method defines more than one `CancellationToken` parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken ct = default)
        {
        }

        public static void MyMethod(CancellationToken c1, CancellationToken c2)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="b5283-147">Метод с настройками по умолчанию определяет несколько параметров `CancellationToken`:</span><span class="sxs-lookup"><span data-stu-id="b5283-147">The method with defaults defines more than one `CancellationToken` parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken c1 = default, CancellationToken c2 = default)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault();
        }
    }
}
```

<span data-ttu-id="b5283-148">Перегрузка метода определяет несколько параметров `CancellationToken`:</span><span class="sxs-lookup"><span data-stu-id="b5283-148">The method overload defines more than one `CancellationToken` parameter:</span></span>

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithOverload(CancellationToken c1, CancellationToken c2)
        {
        }

        public static void MyMethodWithOverload()
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload();
        }
    }
}
```
