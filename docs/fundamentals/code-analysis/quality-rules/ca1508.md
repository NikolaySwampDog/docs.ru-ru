---
title: 'CA1508: избегайте неиспользуемого кода условия (анализ кода)'
description: Дополнительные сведения о правиле анализа кода CA1508 — избегайте неиспользуемого кода условия
ms.date: 04/23/2020
ms.topic: reference
f1_keywords:
- CA1508
- AvoidDeadConditionalCode
helpviewer_keywords:
- CA1508
- AvoidDeadConditionalCode
author: mavasani
ms.author: mavasani
ms.openlocfilehash: 8782a28a2095b91f382f55b940c42d910e880d53
ms.sourcegitcommit: 05d0087dfca85aac9ca2960f86c5efd218bf833f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/30/2021
ms.locfileid: "99643167"
---
# <a name="ca1508-avoid-dead-conditional-code"></a>CA1508: Избегайте появления неиспользуемого условного кода

| | Значение |
|-|-|
| **Идентификатор правила** |CA1508|
| **Категория** |[Удобство обслуживания](maintainability-warnings.md)|
| **Исправление является критическим или не критическим** |Не критическое|

## <a name="cause"></a>Причина

Метод имеет код условия, который всегда вычисляется как `true` или `false` в среде выполнения. Это приводит к неиспользуемому коду в ветви `false` условия.

По умолчанию это правило анализирует всю базу кода, но такое поведение [можно настроить](#configure-code-to-analyze).

## <a name="rule-description"></a>Описание правила

Методы могут иметь код условия, например операторы If, двоичные выражения (`==`, `!=`, `<`, `>`), проверки значений NULL и т. д. Например, рассмотрим следующий код:

```csharp
public void M(int i, int j)
{
    if (i != 0)
    {
        return;
    }

    if (j != 0)
    {
        return;
    }

    // Below condition will always evaluate to 'false' as 'i' and 'j' are both '0' here.
    if (i != j)
    {
        // Code in this 'if' branch is dead code.
        // It can either be removed or refactored.
        ...
    }
}
```

Компиляторы C# и VB выполняют анализ условных проверок с использованием _значений констант_ во время компиляции, которые всегда имеют значение `true` или `false`. Этот анализатор выполняет анализ потока данных переменных, не являющихся константами, чтобы определить избыточные условные проверки, включающие _неконстантные значения_. В приведенном выше коде анализатор определяет, что `i` и `j` являются `0` для всех путей к коду, которые достигают проверки `i != j`. Таким образом, эта проверка всегда будет оцениваться как `false` во время выполнения. Код в операторе If является неиспользуемым кодом и может быть удален или подвергнут рефакторингу. Аналогичным образом, анализатор отслеживает значения NULL переменных и сообщает об избыточных проверках значений NULL.

> [!NOTE]
> Этот анализатор выполняет ресурсоемкий анализ потоков данных со значениями, не являющимися константными. Это может увеличить общее время компиляции для определенных баз кода.

## <a name="when-to-suppress-warnings"></a>Условия для отключения предупреждений

Нарушение этого правила можно безопасно скрыть, если вы не беспокоитесь об удобстве обслуживания кода. Также можно игнорировать нарушения, если это ложноположительный результат. Это возможно при наличии параллельного кода, который может выполняться из нескольких потоков.

## <a name="configure-code-to-analyze"></a>Настройка кода для анализа

Используйте следующие параметры, чтобы указать части базы кода, к которым будет применяться это правило.

- [Исключить определенные символы](#exclude-specific-symbols)
- [Исключить определенные типы и их производные типы](#exclude-specific-types-and-their-derived-types)

Эти параметры можно настроить только для указанного правила, для всех правил или для всех правил в этой категории ([возможность обслуживания](maintainability-warnings.md)). Дополнительные сведения см. в статье [Параметры конфигурации правила качества кода](../code-quality-rule-options.md).

[!INCLUDE[excluded-symbol-names](~/includes/code-analysis/excluded-symbol-names.md)]

[!INCLUDE[excluded-type-names-with-derived-types](~/includes/code-analysis/excluded-type-names-with-derived-types.md)]

## <a name="see-also"></a>См. также раздел

- [Правила удобства поддержки](maintainability-warnings.md)
