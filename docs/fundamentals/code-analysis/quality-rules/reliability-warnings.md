---
title: Правила надежности (анализ кода)
description: Сведения о правилах надежности анализа кода.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.reliabilityrules
helpviewer_keywords:
- rules, reliability
- reliability rules
- managed code analysis rules, reliability rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: a747dd4dcda351a1ddb0f3d069bb7bac895c32f8
ms.sourcegitcommit: 05d0087dfca85aac9ca2960f86c5efd218bf833f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/30/2021
ms.locfileid: "96593245"
---
# <a name="reliability-rules"></a><span data-ttu-id="1b556-103">Правила надежности</span><span class="sxs-lookup"><span data-stu-id="1b556-103">Reliability rules</span></span>

<span data-ttu-id="1b556-104">Правила надежности поддерживают безотказность библиотек и приложений, например посредством правильного использования памяти и потоков.</span><span class="sxs-lookup"><span data-stu-id="1b556-104">Reliability rules support library and application reliability, such as correct memory and thread usage.</span></span> <span data-ttu-id="1b556-105">Ниже приведены правила надежности.</span><span class="sxs-lookup"><span data-stu-id="1b556-105">The reliability rules include:</span></span>

|<span data-ttu-id="1b556-106">Правило</span><span class="sxs-lookup"><span data-stu-id="1b556-106">Rule</span></span>|<span data-ttu-id="1b556-107">Описание</span><span class="sxs-lookup"><span data-stu-id="1b556-107">Description</span></span>|
|----------|-----------------|
|[<span data-ttu-id="1b556-108">CA2000. Ликвидируйте объекты перед потерей области</span><span class="sxs-lookup"><span data-stu-id="1b556-108">CA2000: Dispose objects before losing scope</span></span>](ca2000.md)|<span data-ttu-id="1b556-109">Необходимо явно удалить объект до того, как все ссылки на него окажутся вне области действия, так как может произойти исключительное событие, которое воспрепятствует выполнению метода завершения объекта.</span><span class="sxs-lookup"><span data-stu-id="1b556-109">Because an exceptional event might occur that will prevent the finalizer of an object from running, the object should be explicitly disposed before all references to it are out of scope.</span></span>|
|[<span data-ttu-id="1b556-110">CA2002. Не блокируйте объекты с ненадежными удостоверениями</span><span class="sxs-lookup"><span data-stu-id="1b556-110">CA2002: Do not lock on objects with weak identity</span></span>](ca2002.md)|<span data-ttu-id="1b556-111">К объекту со слабой идентификацией может быть получен прямой доступ через границы домена приложения.</span><span class="sxs-lookup"><span data-stu-id="1b556-111">An object is said to have a weak identity when it can be directly accessed across application domain boundaries.</span></span> <span data-ttu-id="1b556-112">Поток пытается получить блокировку объекта со слабой идентификацией, который может быть заблокирован вторым потоком в другом домене приложения, имеющим блокировку того же объекта.</span><span class="sxs-lookup"><span data-stu-id="1b556-112">A thread that tries to acquire a lock on an object that has a weak identity can be blocked by a second thread in a different application domain that has a lock on the same object.</span></span>|
|[<span data-ttu-id="1b556-113">CA2007. Не следует напрямую ожидать Task</span><span class="sxs-lookup"><span data-stu-id="1b556-113">CA2007: Do not directly await a Task</span></span>](ca2007.md)|<span data-ttu-id="1b556-114">Асинхронный метод [ожидает](../../../csharp/language-reference/operators/await.md) класс <xref:System.Threading.Tasks.Task> напрямую.</span><span class="sxs-lookup"><span data-stu-id="1b556-114">An asynchronous method [awaits](../../../csharp/language-reference/operators/await.md) a <xref:System.Threading.Tasks.Task> directly.</span></span>|
|[<span data-ttu-id="1b556-115">CA2008. Не создавайте задачи без передачи TaskScheduler</span><span class="sxs-lookup"><span data-stu-id="1b556-115">CA2008: Do not create tasks without passing a TaskScheduler</span></span>](ca2008.md)|<span data-ttu-id="1b556-116">Операция создания или продолжения задачи использует перегрузку метода, в которой не указан параметр <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="1b556-116">A task creation or continuation operation uses a method overload that does not specify a <xref:System.Threading.Tasks.TaskScheduler> parameter.</span></span>|
|[<span data-ttu-id="1b556-117">CA2009: Не вызывайте ToImmutableCollection для значения ImmutableCollection</span><span class="sxs-lookup"><span data-stu-id="1b556-117">CA2009: Do not call ToImmutableCollection on an ImmutableCollection value</span></span>](ca2009.md)|<span data-ttu-id="1b556-118">Метод `ToImmutable` был без необходимости вызван для неизменяемой коллекции из пространства имен <xref:System.Collections.Immutable>.</span><span class="sxs-lookup"><span data-stu-id="1b556-118">`ToImmutable` method was unnecessarily called on an immutable collection from <xref:System.Collections.Immutable> namespace.</span></span>|
|[<span data-ttu-id="1b556-119">CA2011: не присваивайте свойство в методе задания</span><span class="sxs-lookup"><span data-stu-id="1b556-119">CA2011: Do not assign property within its setter</span></span>](ca2011.md) | <span data-ttu-id="1b556-120">Свойству было случайно присвоено значение в его [методе доступа set](../../../csharp/programming-guide/classes-and-structs/using-properties.md#the-set-accessor).</span><span class="sxs-lookup"><span data-stu-id="1b556-120">A property was accidentally assigned a value within its own [set accessor](../../../csharp/programming-guide/classes-and-structs/using-properties.md#the-set-accessor).</span></span> |
|[<span data-ttu-id="1b556-121">CA2012: используйте ValueTasks правильно</span><span class="sxs-lookup"><span data-stu-id="1b556-121">CA2012: Use ValueTasks correctly</span></span>](ca2012.md) | <span data-ttu-id="1b556-122">Экземпляры ValueTask, возвращаемые из вызовов элементов, предназначены для непосредственного ожидания.</span><span class="sxs-lookup"><span data-stu-id="1b556-122">ValueTasks returned from member invocations are intended to be directly awaited.</span></span>  <span data-ttu-id="1b556-123">Попытки использовать ValueTask несколько раз или для прямого доступа к результату до его завершения могут привести к возникновению исключения или повреждения.</span><span class="sxs-lookup"><span data-stu-id="1b556-123">Attempts to consume a ValueTask multiple times or to directly access one's result before it's known to be completed may result in an exception or corruption.</span></span>  <span data-ttu-id="1b556-124">Игнорирование ValueTask, скорее всего, указывает на функциональную ошибку и может привести к снижению производительности.</span><span class="sxs-lookup"><span data-stu-id="1b556-124">Ignoring such a ValueTask is likely an indication of a functional bug and may degrade performance.</span></span> |
|[<span data-ttu-id="1b556-125">CA2013: не используйте ReferenceEquals с типами значений</span><span class="sxs-lookup"><span data-stu-id="1b556-125">CA2013: Do not use ReferenceEquals with value types</span></span>](ca2013.md) | <span data-ttu-id="1b556-126">Если при сравнении значений с помощью <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName> objA и objB являются типами значений, то перед передачей они упаковываются в метод <xref:System.Object.ReferenceEquals%2A>.</span><span class="sxs-lookup"><span data-stu-id="1b556-126">When comparing values using <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName>, if objA and objB are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="1b556-127">Это означает, что даже если и objA, и objB представляют один и тот же экземпляр типа значения, метод <xref:System.Object.ReferenceEquals%2A> все равно возвращает значение false.</span><span class="sxs-lookup"><span data-stu-id="1b556-127">This means that even if both objA and objB represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns false.</span></span> |
|[<span data-ttu-id="1b556-128">CA2014: не используйте stackalloc в циклах.</span><span class="sxs-lookup"><span data-stu-id="1b556-128">CA2014: Do not use stackalloc in loops.</span></span>](ca2014.md) | <span data-ttu-id="1b556-129">Пространство стека, выделенное stackalloc, освобождается только в конце вызова текущего метода.</span><span class="sxs-lookup"><span data-stu-id="1b556-129">Stack space allocated by a stackalloc is only released at the end of the current method's invocation.</span></span>  <span data-ttu-id="1b556-130">Использование его в цикле может привести к неограниченному росту стека и появлению условий переполнения стека.</span><span class="sxs-lookup"><span data-stu-id="1b556-130">Using it in a loop can result in unbounded stack growth and eventual stack overflow conditions.</span></span> |
|[<span data-ttu-id="1b556-131">CA2015: не определяйте методы завершения для типов, производных от MemoryManager&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="1b556-131">CA2015: Do not define finalizers for types derived from MemoryManager&lt;T&gt;</span></span>](ca2015.md) | <span data-ttu-id="1b556-132">Добавление метода завершения к типу, производному от <xref:System.Buffers.MemoryManager%601>, может привести к освобождению памяти, пока она еще используется <xref:System.Span%601>.</span><span class="sxs-lookup"><span data-stu-id="1b556-132">Adding a finalizer to a type derived from <xref:System.Buffers.MemoryManager%601> may permit memory to be freed while it is still in use by a <xref:System.Span%601>.</span></span> |
|[<span data-ttu-id="1b556-133">CA2016: Переадресовывать параметр CancellationToken методам, которые его принимают</span><span class="sxs-lookup"><span data-stu-id="1b556-133">CA2016: Forward the CancellationToken parameter to methods that take one</span></span>](ca2016.md) | <span data-ttu-id="1b556-134">Перенаправьте параметр `CancellationToken` в методы, чтобы обеспечить правильное распространение уведомлений об отмене операции, или явно передайте `CancellationToken.None`, чтобы указать, что маркер не распространяется намеренно.</span><span class="sxs-lookup"><span data-stu-id="1b556-134">Forward the `CancellationToken` parameter to methods that take one to ensure the operation cancellation notifications gets properly propagated, or pass in `CancellationToken.None` explicitly to indicate intentionally not propagating the token.</span></span> |
