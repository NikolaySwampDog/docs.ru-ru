---
title: Правила использования (анализ кода)
description: Сведения о правилах использования анализа кода.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.usagerules
helpviewer_keywords:
- rules, usage
- managed code analysis rules, usage rules
- usage rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: b05edde3c6faef39aa724dd49d159abe23d049f5
ms.sourcegitcommit: 05d0087dfca85aac9ca2960f86c5efd218bf833f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/30/2021
ms.locfileid: "102102975"
---
# <a name="usage-rules"></a><span data-ttu-id="3fc52-103">Правила использования</span><span class="sxs-lookup"><span data-stu-id="3fc52-103">Usage rules</span></span>

<span data-ttu-id="3fc52-104">Правила использования поддерживают надлежащее использование .NET.</span><span class="sxs-lookup"><span data-stu-id="3fc52-104">Usage rules support proper usage of .NET.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="3fc52-105">Содержание раздела</span><span class="sxs-lookup"><span data-stu-id="3fc52-105">In this section</span></span>

|<span data-ttu-id="3fc52-106">Правило</span><span class="sxs-lookup"><span data-stu-id="3fc52-106">Rule</span></span>|<span data-ttu-id="3fc52-107">Описание</span><span class="sxs-lookup"><span data-stu-id="3fc52-107">Description</span></span>|
|----------|-----------------|
|[<span data-ttu-id="3fc52-108">CA1801. Проверьте неиспользуемые параметры</span><span class="sxs-lookup"><span data-stu-id="3fc52-108">CA1801: Review unused parameters</span></span>](ca1801.md)|<span data-ttu-id="3fc52-109">Сигнатура метода включает параметр, не использующийся в основной части метода.</span><span class="sxs-lookup"><span data-stu-id="3fc52-109">A method signature includes a parameter that is not used in the method body.</span></span>|
|[<span data-ttu-id="3fc52-110">CA1816. Вызов GC.SuppressFinalize должен осуществляться правильно</span><span class="sxs-lookup"><span data-stu-id="3fc52-110">CA1816: Call GC.SuppressFinalize correctly</span></span>](ca1816.md)|<span data-ttu-id="3fc52-111">Метод, который является реализацией Dispose, не вызывает `GC.SuppressFinalize`; или метод, который не является реализацией `Dispose`, вызывает `GC.SuppressFinalize`; или метод вызывает `GC.SuppressFinalize` и передает нечто, отличное от `this` (`Me` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="3fc52-111">A method that is an implementation of Dispose does not call `GC.SuppressFinalize`; or a method that is not an implementation of `Dispose` calls `GC.SuppressFinalize`; or a method calls `GC.SuppressFinalize` and passes something other than `this` (`Me` in Visual Basic).</span></span>|
|[<span data-ttu-id="3fc52-112">CA2200. Повторно порождайте исключения для сохранения сведений стека</span><span class="sxs-lookup"><span data-stu-id="3fc52-112">CA2200: Rethrow to preserve stack details</span></span>](ca2200.md)|<span data-ttu-id="3fc52-113">В операторе throw повторно создается и явным образом задается исключение.</span><span class="sxs-lookup"><span data-stu-id="3fc52-113">An exception is rethrown and the exception is explicitly specified in the throw statement.</span></span> <span data-ttu-id="3fc52-114">Если исключение повторно создается заданием исключения в операторе throw, список вызовов метода между исходным методом, создавшим исключение, и текущим методом будет утерян.</span><span class="sxs-lookup"><span data-stu-id="3fc52-114">If an exception is rethrown by specifying the exception in the throw statement, the list of method calls between the original method that threw the exception and the current method is lost.</span></span>|
|[<span data-ttu-id="3fc52-115">CA2201. Не порождайте исключения зарезервированных типов</span><span class="sxs-lookup"><span data-stu-id="3fc52-115">CA2201: Do not raise reserved exception types</span></span>](ca2201.md)|<span data-ttu-id="3fc52-116">Из-за этого становится трудно обнаружить и отладить изначальную ошибку.</span><span class="sxs-lookup"><span data-stu-id="3fc52-116">This makes the original error hard to detect and debug.</span></span>|
|[<span data-ttu-id="3fc52-117">CA2207. Используйте встроенную инициализацию статических полей типов значений</span><span class="sxs-lookup"><span data-stu-id="3fc52-117">CA2207: Initialize value type static fields inline</span></span>](ca2207.md)|<span data-ttu-id="3fc52-118">Тип значения объявляет явный статический конструктор.</span><span class="sxs-lookup"><span data-stu-id="3fc52-118">A value type declares an explicit static constructor.</span></span> <span data-ttu-id="3fc52-119">Чтобы устранить нарушение данного правила, выполните инициализацию всех статических данных при их объявлении и удалите статический конструктор.</span><span class="sxs-lookup"><span data-stu-id="3fc52-119">To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.</span></span>|
|[<span data-ttu-id="3fc52-120">CA2208. Правильно создавайте экземпляры исключений аргументов</span><span class="sxs-lookup"><span data-stu-id="3fc52-120">CA2208: Instantiate argument exceptions correctly</span></span>](ca2208.md)|<span data-ttu-id="3fc52-121">Вызывается конструктор по умолчанию (без параметров), принадлежащий к типу исключения ArgumentException или унаследованный от него, или неправильный аргумент строки передается параметризованному конструктору, принадлежащему к типу исключения ArgumentException или унаследованному от него.</span><span class="sxs-lookup"><span data-stu-id="3fc52-121">A call is made to the default (parameterless) constructor of an exception type that is or derives from ArgumentException, or an incorrect string argument is passed to a parameterized constructor of an exception type that is or derives from ArgumentException.</span></span>|
|[<span data-ttu-id="3fc52-122">CA2211. Поля, не являющиеся константами, не должны быть видимыми</span><span class="sxs-lookup"><span data-stu-id="3fc52-122">CA2211: Non-constant fields should not be visible</span></span>](ca2211.md)|<span data-ttu-id="3fc52-123">Для статических полей, которые не являются константными и доступными только для чтения, невозможно обеспечить потокобезопасность.</span><span class="sxs-lookup"><span data-stu-id="3fc52-123">Static fields that are not constants or read-only are not thread-safe.</span></span> <span data-ttu-id="3fc52-124">Доступ к подобным полям должен тщательно контролироваться, и для синхронизации доступа к такому объекту класса требуются дополнительные методы программирования.</span><span class="sxs-lookup"><span data-stu-id="3fc52-124">Access to such a field must be carefully controlled and requires advanced programming techniques for synchronizing access to the class object.</span></span>|
|[<span data-ttu-id="3fc52-125">CA2213. Следует высвобождать высвобождаемые поля</span><span class="sxs-lookup"><span data-stu-id="3fc52-125">CA2213: Disposable fields should be disposed</span></span>](ca2213.md)|<span data-ttu-id="3fc52-126">Тип, реализующий <xref:System.IDisposable?displayProperty=fullName>, объявляет поля, имеющие типы, которые также реализуют `IDisposable`.</span><span class="sxs-lookup"><span data-stu-id="3fc52-126">A type that implements <xref:System.IDisposable?displayProperty=fullName> declares fields that are of types that also implement `IDisposable`.</span></span> <span data-ttu-id="3fc52-127">Метод `Dispose` поля не вызывается методом `Dispose` объявляющего типа.</span><span class="sxs-lookup"><span data-stu-id="3fc52-127">The `Dispose` method of the field is not called by the `Dispose` method of the declaring type.</span></span>|
|[<span data-ttu-id="3fc52-128">CA2214. Не вызывайте переопределяемые методы в конструкторах</span><span class="sxs-lookup"><span data-stu-id="3fc52-128">CA2214: Do not call overridable methods in constructors</span></span>](ca2214.md)|<span data-ttu-id="3fc52-129">Когда конструктор вызывает виртуальный метод, возможна ситуация, когда конструктор для экземпляра, вызывающего метод, не выполняется.</span><span class="sxs-lookup"><span data-stu-id="3fc52-129">When a constructor calls a virtual method, it is possible that the constructor for the instance that invokes the method has not executed.</span></span>|
|[<span data-ttu-id="3fc52-130">CA2215. Метод Dispose должен вызывать базовый класс Dispose</span><span class="sxs-lookup"><span data-stu-id="3fc52-130">CA2215: Dispose methods should call base class dispose</span></span>](ca2215.md)|<span data-ttu-id="3fc52-131">Если тип наследует от освобождаемого типа, он должен вызывать метод `Dispose` базового типа из собственного метода `Dispose`.</span><span class="sxs-lookup"><span data-stu-id="3fc52-131">If a type inherits from a disposable type, it must call the `Dispose` method of the base type from its own `Dispose` method.</span></span>|
|[<span data-ttu-id="3fc52-132">CA2216. Высвобождаемые типы должны объявлять методы завершения</span><span class="sxs-lookup"><span data-stu-id="3fc52-132">CA2216: Disposable types should declare finalizer</span></span>](ca2216.md)|<span data-ttu-id="3fc52-133">Тип, который реализует <xref:System.IDisposable?displayProperty=fullName> и имеет поля, предусматривающие использование неуправляемых ресурсов, не реализует метод завершения, как описано в `Object.Finalize`.</span><span class="sxs-lookup"><span data-stu-id="3fc52-133">A type that implements <xref:System.IDisposable?displayProperty=fullName>, and has fields that suggest the use of unmanaged resources, does not implement a finalizer as described by `Object.Finalize`.</span></span>|
|[<span data-ttu-id="3fc52-134">CA2217. Не помечайте перечисляемые типы с помощью FlagsAttribute</span><span class="sxs-lookup"><span data-stu-id="3fc52-134">CA2217: Do not mark enums with FlagsAttribute</span></span>](ca2217.md)|<span data-ttu-id="3fc52-135">Видимое извне перечисление помечено атрибутом `FlagsAttribute` и имеет одно или несколько значений, которые не являются степенью двух или сочетанием других определенных значений в перечислении.</span><span class="sxs-lookup"><span data-stu-id="3fc52-135">An externally visible enumeration is marked with `FlagsAttribute`, and it has one or more values that are not powers of two or a combination of the other defined values on the enumeration.</span></span>|
|[<span data-ttu-id="3fc52-136">CA2218. Переопределяйте GetHashCode при переопределении Equals</span><span class="sxs-lookup"><span data-stu-id="3fc52-136">CA2218: Override GetHashCode on overriding Equals</span></span>](ca2218.md)|<span data-ttu-id="3fc52-137">Открытый тип переопределяет <xref:System.Object.Equals%2A?displayProperty=fullName>, но не <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</span><span class="sxs-lookup"><span data-stu-id="3fc52-137">A public type overrides <xref:System.Object.Equals%2A?displayProperty=fullName> but does not override <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</span></span>|
|[<span data-ttu-id="3fc52-138">CA2219. В предложениях с исключениями не должны порождаться исключения</span><span class="sxs-lookup"><span data-stu-id="3fc52-138">CA2219: Do not raise exceptions in exception clauses</span></span>](ca2219.md)|<span data-ttu-id="3fc52-139">Если исключение создается в предложении finally или fault, новое исключение скрывает активное исключение.</span><span class="sxs-lookup"><span data-stu-id="3fc52-139">When an exception is raised in a finally or fault clause, the new exception hides the active exception.</span></span> <span data-ttu-id="3fc52-140">Если исключение создается в предложении filter, среда выполнения перехватывает исключение без оповещения.</span><span class="sxs-lookup"><span data-stu-id="3fc52-140">When an exception is raised in a filter clause, the run time silently catches the exception.</span></span> <span data-ttu-id="3fc52-141">Из-за этого становится трудно обнаружить и отладить изначальную ошибку.</span><span class="sxs-lookup"><span data-stu-id="3fc52-141">This makes the original error hard to detect and debug.</span></span>|
|[<span data-ttu-id="3fc52-142">CA2224. Переопределяйте Equals при перегрузке оператора равенства</span><span class="sxs-lookup"><span data-stu-id="3fc52-142">CA2224: Override equals on overloading operator equals</span></span>](ca2224.md)|<span data-ttu-id="3fc52-143">Открытый тип реализует оператор равенства, но не переопределяет <xref:System.Object.Equals%2A?displayProperty=fullName>.</span><span class="sxs-lookup"><span data-stu-id="3fc52-143">A public type implements the equality operator but doesn't override <xref:System.Object.Equals%2A?displayProperty=fullName>.</span></span>|
|[<span data-ttu-id="3fc52-144">CA2225. Для перегрузок операторов существуют варианты с именами</span><span class="sxs-lookup"><span data-stu-id="3fc52-144">CA2225: Operator overloads have named alternates</span></span>](ca2225.md)|<span data-ttu-id="3fc52-145">Обнаружена перегрузка оператора, однако не найден ожидаемый именованный альтернативный метод.</span><span class="sxs-lookup"><span data-stu-id="3fc52-145">An operator overload was detected, and the expected named alternative method was not found.</span></span> <span data-ttu-id="3fc52-146">Именованный альтернативный член предоставляет те же функции, что и основной оператор, и его могут использовать разработчики, которые программируют на языках, не поддерживающих перегрузку операторов.</span><span class="sxs-lookup"><span data-stu-id="3fc52-146">The named alternative member provides access to the same functionality as the operator, and is provided for developers who program in languages that do not support overloaded operators.</span></span>|
|[<span data-ttu-id="3fc52-147">CA2226. Перегрузки операторов должны быть симметричными</span><span class="sxs-lookup"><span data-stu-id="3fc52-147">CA2226: Operators should have symmetrical overloads</span></span>](ca2226.md)|<span data-ttu-id="3fc52-148">Тип реализует оператор равенства или неравенства, но не реализует противоположный оператор.</span><span class="sxs-lookup"><span data-stu-id="3fc52-148">A type implements the equality or inequality operator, and does not implement the opposite operator.</span></span>|
|[<span data-ttu-id="3fc52-149">CA2227. Свойства, возвращающие коллекции, должны быть доступными только для чтения</span><span class="sxs-lookup"><span data-stu-id="3fc52-149">CA2227: Collection properties should be read only</span></span>](ca2227.md)|<span data-ttu-id="3fc52-150">Свойство коллекции, допускающее запись, позволяет пользователю заменять одну коллекцию другой.</span><span class="sxs-lookup"><span data-stu-id="3fc52-150">A writable collection property allows a user to replace the collection with a different collection.</span></span> <span data-ttu-id="3fc52-151">Свойство только для чтения предотвращает замену коллекции, но по-прежнему допускает установку, настройку отдельных членов.</span><span class="sxs-lookup"><span data-stu-id="3fc52-151">A read-only property stops the collection from being replaced but still allows the individual members to be set.</span></span>|
|[<span data-ttu-id="3fc52-152">CA2229. Реализуйте конструкторы сериализации</span><span class="sxs-lookup"><span data-stu-id="3fc52-152">CA2229: Implement serialization constructors</span></span>](ca2229.md)|<span data-ttu-id="3fc52-153">Чтобы устранить нарушение этого правила, реализуйте конструктор сериализации.</span><span class="sxs-lookup"><span data-stu-id="3fc52-153">To fix a violation of this rule, implement the serialization constructor.</span></span> <span data-ttu-id="3fc52-154">Для запечатанного класса конструктор должен быть закрытым, а в иных случаях — защищенным.</span><span class="sxs-lookup"><span data-stu-id="3fc52-154">For a sealed class, make the constructor private; otherwise, make it protected.</span></span>|
|[<span data-ttu-id="3fc52-155">CA2231. Перегрузите оператор равенства на переопределяющем типе ValueType.Equals</span><span class="sxs-lookup"><span data-stu-id="3fc52-155">CA2231: Overload operator equals on overriding ValueType.Equals</span></span>](ca2231.md)|<span data-ttu-id="3fc52-156">Тип значения переопределяет `Object.Equals`, но не реализует оператор равенства.</span><span class="sxs-lookup"><span data-stu-id="3fc52-156">A value type overrides `Object.Equals` but does not implement the equality operator.</span></span>|
|[<span data-ttu-id="3fc52-157">CA2234. Передавайте объекты System.Uri вместо строк</span><span class="sxs-lookup"><span data-stu-id="3fc52-157">CA2234: Pass System.Uri objects instead of strings</span></span>](ca2234.md)|<span data-ttu-id="3fc52-158">Вызывается метод, имеющий параметр строки, имя которого содержит uri, URI, urn, URN, url или URL.</span><span class="sxs-lookup"><span data-stu-id="3fc52-158">A call is made to a method that has a string parameter whose name contains "uri", "URI", "urn", "URN", "url", or "URL".</span></span>  <span data-ttu-id="3fc52-159">Объявляющий тип метода содержит соответствующую перегрузку метода, которая имеет параметр <xref:System.Uri?displayProperty=fullName>.</span><span class="sxs-lookup"><span data-stu-id="3fc52-159">The declaring type of the method contains a corresponding method overload that has a <xref:System.Uri?displayProperty=fullName> parameter.</span></span>|
|[<span data-ttu-id="3fc52-160">CA2235. Пометьте все несериализуемые поля</span><span class="sxs-lookup"><span data-stu-id="3fc52-160">CA2235: Mark all non-serializable fields</span></span>](ca2235.md)|<span data-ttu-id="3fc52-161">Экземпляр поля несериализуемого типа объявлен в сериализуемом типе.</span><span class="sxs-lookup"><span data-stu-id="3fc52-161">An instance field of a type that is not serializable is declared in a type that is serializable.</span></span>|
|[<span data-ttu-id="3fc52-162">CA2237. Пометьте типы ISerializable атрибутом SerializableAttribute</span><span class="sxs-lookup"><span data-stu-id="3fc52-162">CA2237: Mark ISerializable types with SerializableAttribute</span></span>](ca2237.md)|<span data-ttu-id="3fc52-163">Чтобы среда CLR распознавала тип как сериализуемый, он должен быть помечен атрибутом SerializableAttribute, даже если тип использует пользовательскую процедуру сериализации посредством реализации интерфейса `ISerializable`.</span><span class="sxs-lookup"><span data-stu-id="3fc52-163">To be recognized by the common language runtime as serializable, types must be marked with the SerializableAttribute attribute even if the type uses a custom serialization routine through implementation of the `ISerializable` interface.</span></span>|
|[<span data-ttu-id="3fc52-164">CA2241. Задайте правильные аргументы для методов форматирования</span><span class="sxs-lookup"><span data-stu-id="3fc52-164">CA2241: Provide correct arguments to formatting methods</span></span>](ca2241.md)|<span data-ttu-id="3fc52-165">Аргумент формата, переданный методу <xref:System.String.Format%2A?displayProperty=nameWithType>, не содержит элемент форматирования, соответствующий каждому аргументу объекта, или наоборот.</span><span class="sxs-lookup"><span data-stu-id="3fc52-165">The format argument passed to <xref:System.String.Format%2A?displayProperty=nameWithType> does not contain a format item that corresponds to each object argument, or vice versa.</span></span>|
|[<span data-ttu-id="3fc52-166">CA2242. Правильно выполняйте проверку NaN</span><span class="sxs-lookup"><span data-stu-id="3fc52-166">CA2242: Test for NaN correctly</span></span>](ca2242.md)|<span data-ttu-id="3fc52-167">Это выражение проверяет значение на соответствие `Single.Nan` или `Double.Nan`.</span><span class="sxs-lookup"><span data-stu-id="3fc52-167">This expression tests a value against `Single.Nan` or `Double.Nan`.</span></span> <span data-ttu-id="3fc52-168">Используйте `Single.IsNan(Single)` или `Double.IsNan(Double)` для проверки значения.</span><span class="sxs-lookup"><span data-stu-id="3fc52-168">Use `Single.IsNan(Single)` or `Double.IsNan(Double)` to test the value.</span></span>|
|[<span data-ttu-id="3fc52-169">CA2243. Синтаксический разбор строковых литералов должен осуществляться правильно</span><span class="sxs-lookup"><span data-stu-id="3fc52-169">CA2243: Attribute string literals should parse correctly</span></span>](ca2243.md)|<span data-ttu-id="3fc52-170">Не удается правильно выполнить синтаксический анализ параметра строкового литерала атрибута для URL-адреса, идентификатора GUID или версии.</span><span class="sxs-lookup"><span data-stu-id="3fc52-170">An attribute's string literal parameter does not parse correctly for a URL, a GUID, or a version.</span></span>|
|[<span data-ttu-id="3fc52-171">CA2244: не повторяйте инициализацию индексируемых элементов</span><span class="sxs-lookup"><span data-stu-id="3fc52-171">CA2244: Do not duplicate indexed element initializations</span></span>](ca2244.md)|<span data-ttu-id="3fc52-172">Инициализатор объектов имеет несколько инициализаторов индексированных элементов с одинаковым индексом константы.</span><span class="sxs-lookup"><span data-stu-id="3fc52-172">An object initializer has more than one indexed element initializer with the same constant index.</span></span> <span data-ttu-id="3fc52-173">Все инициализаторы, кроме последнего, являются избыточными.</span><span class="sxs-lookup"><span data-stu-id="3fc52-173">All but the last initializer are redundant.</span></span>|
|[<span data-ttu-id="3fc52-174">CA2245: не назначайте свойство самому себе</span><span class="sxs-lookup"><span data-stu-id="3fc52-174">CA2245: Do not assign a property to itself</span></span>](ca2245.md)|<span data-ttu-id="3fc52-175">Свойство было случайно назначено самому себе.</span><span class="sxs-lookup"><span data-stu-id="3fc52-175">A property was accidentally assigned to itself.</span></span>|
|[<span data-ttu-id="3fc52-176">CA2246: не присваивайте значения символу и его элементу в одном операторе</span><span class="sxs-lookup"><span data-stu-id="3fc52-176">CA2246: Do not assign a symbol and its member in the same statement</span></span>](ca2246.md)|<span data-ttu-id="3fc52-177">Не рекомендуется назначать символ и его член, то есть поле или свойство в одном операторе.</span><span class="sxs-lookup"><span data-stu-id="3fc52-177">Assigning a symbol and its member, that is, a field or a property, in the same statement is not recommended.</span></span> <span data-ttu-id="3fc52-178">Неясно, предназначался ли доступ к члену для использования старого значения символа до назначения или нового значения из назначения в этом операторе.</span><span class="sxs-lookup"><span data-stu-id="3fc52-178">It is not clear if the member access was intended to use the symbol's old value prior to the assignment or the new value from the assignment in this statement.</span></span>|
|[<span data-ttu-id="3fc52-179">CA2247: аргумент, переданный в конструктор TaskCompletionSource, должен быть перечислением TaskCreationOptions, а не TaskContinuationOptions</span><span class="sxs-lookup"><span data-stu-id="3fc52-179">CA2247: Argument passed to TaskCompletionSource constructor should be TaskCreationOptions enum instead of TaskContinuationOptions enum</span></span>](ca2247.md)|<span data-ttu-id="3fc52-180">TaskCompletionSource имеет конструкторы, принимающие TaskCreationOptions, которые управляют базовой задачей, и конструкторы, которые принимают состояние объекта, сохраненное в задаче.</span><span class="sxs-lookup"><span data-stu-id="3fc52-180">TaskCompletionSource has constructors that take TaskCreationOptions that control the underlying Task, and constructors that take object state that's stored in the task.</span></span>  <span data-ttu-id="3fc52-181">Случайная передача TaskContinuationOptions вместо TaskCreationOptions приведет к тому, что вызов будет рассматривать параметры как состояние.</span><span class="sxs-lookup"><span data-stu-id="3fc52-181">Accidentally passing a TaskContinuationOptions instead of a TaskCreationOptions will result in the call treating the options as state.</span></span>|
|[<span data-ttu-id="3fc52-182">CA2248: укажите правильный аргумент enum для Enum.HasFlag</span><span class="sxs-lookup"><span data-stu-id="3fc52-182">CA2248: Provide correct 'enum' argument to 'Enum.HasFlag'</span></span>](ca2248.md)|<span data-ttu-id="3fc52-183">Тип перечисления, переданный в качестве аргумента вызову метода `HasFlag`, отличается от вызывающего типа перечисления.</span><span class="sxs-lookup"><span data-stu-id="3fc52-183">The enum type passed as an argument to the `HasFlag` method call is different from the calling enum type.</span></span>|
|[<span data-ttu-id="3fc52-184">CA2249. Попробуйте использовать String.Contains вместо String.IndexOf.</span><span class="sxs-lookup"><span data-stu-id="3fc52-184">CA2249: Consider using String.Contains instead of String.IndexOf</span></span>](ca2249.md)|<span data-ttu-id="3fc52-185">Вызовы `string.IndexOf`, где результат используется для проверки на наличие или отсутствия подстроки, можно заменить `string.Contains`.</span><span class="sxs-lookup"><span data-stu-id="3fc52-185">Calls to `string.IndexOf` where the result is used to check for the presence or absence of a substring can be replaced by `string.Contains`.</span></span>|
