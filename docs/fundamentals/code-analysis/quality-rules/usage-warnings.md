---
title: Правила использования (анализ кода)
description: Сведения о правилах использования анализа кода.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.usagerules
helpviewer_keywords:
- rules, usage
- managed code analysis rules, usage rules
- usage rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: b05edde3c6faef39aa724dd49d159abe23d049f5
ms.sourcegitcommit: 05d0087dfca85aac9ca2960f86c5efd218bf833f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/30/2021
ms.locfileid: "102102975"
---
# <a name="usage-rules"></a>Правила использования

Правила использования поддерживают надлежащее использование .NET.

## <a name="in-this-section"></a>Содержание раздела

|Правило|Описание|
|----------|-----------------|
|[CA1801. Проверьте неиспользуемые параметры](ca1801.md)|Сигнатура метода включает параметр, не использующийся в основной части метода.|
|[CA1816. Вызов GC.SuppressFinalize должен осуществляться правильно](ca1816.md)|Метод, который является реализацией Dispose, не вызывает `GC.SuppressFinalize`; или метод, который не является реализацией `Dispose`, вызывает `GC.SuppressFinalize`; или метод вызывает `GC.SuppressFinalize` и передает нечто, отличное от `this` (`Me` в Visual Basic).|
|[CA2200. Повторно порождайте исключения для сохранения сведений стека](ca2200.md)|В операторе throw повторно создается и явным образом задается исключение. Если исключение повторно создается заданием исключения в операторе throw, список вызовов метода между исходным методом, создавшим исключение, и текущим методом будет утерян.|
|[CA2201. Не порождайте исключения зарезервированных типов](ca2201.md)|Из-за этого становится трудно обнаружить и отладить изначальную ошибку.|
|[CA2207. Используйте встроенную инициализацию статических полей типов значений](ca2207.md)|Тип значения объявляет явный статический конструктор. Чтобы устранить нарушение данного правила, выполните инициализацию всех статических данных при их объявлении и удалите статический конструктор.|
|[CA2208. Правильно создавайте экземпляры исключений аргументов](ca2208.md)|Вызывается конструктор по умолчанию (без параметров), принадлежащий к типу исключения ArgumentException или унаследованный от него, или неправильный аргумент строки передается параметризованному конструктору, принадлежащему к типу исключения ArgumentException или унаследованному от него.|
|[CA2211. Поля, не являющиеся константами, не должны быть видимыми](ca2211.md)|Для статических полей, которые не являются константными и доступными только для чтения, невозможно обеспечить потокобезопасность. Доступ к подобным полям должен тщательно контролироваться, и для синхронизации доступа к такому объекту класса требуются дополнительные методы программирования.|
|[CA2213. Следует высвобождать высвобождаемые поля](ca2213.md)|Тип, реализующий <xref:System.IDisposable?displayProperty=fullName>, объявляет поля, имеющие типы, которые также реализуют `IDisposable`. Метод `Dispose` поля не вызывается методом `Dispose` объявляющего типа.|
|[CA2214. Не вызывайте переопределяемые методы в конструкторах](ca2214.md)|Когда конструктор вызывает виртуальный метод, возможна ситуация, когда конструктор для экземпляра, вызывающего метод, не выполняется.|
|[CA2215. Метод Dispose должен вызывать базовый класс Dispose](ca2215.md)|Если тип наследует от освобождаемого типа, он должен вызывать метод `Dispose` базового типа из собственного метода `Dispose`.|
|[CA2216. Высвобождаемые типы должны объявлять методы завершения](ca2216.md)|Тип, который реализует <xref:System.IDisposable?displayProperty=fullName> и имеет поля, предусматривающие использование неуправляемых ресурсов, не реализует метод завершения, как описано в `Object.Finalize`.|
|[CA2217. Не помечайте перечисляемые типы с помощью FlagsAttribute](ca2217.md)|Видимое извне перечисление помечено атрибутом `FlagsAttribute` и имеет одно или несколько значений, которые не являются степенью двух или сочетанием других определенных значений в перечислении.|
|[CA2218. Переопределяйте GetHashCode при переопределении Equals](ca2218.md)|Открытый тип переопределяет <xref:System.Object.Equals%2A?displayProperty=fullName>, но не <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.|
|[CA2219. В предложениях с исключениями не должны порождаться исключения](ca2219.md)|Если исключение создается в предложении finally или fault, новое исключение скрывает активное исключение. Если исключение создается в предложении filter, среда выполнения перехватывает исключение без оповещения. Из-за этого становится трудно обнаружить и отладить изначальную ошибку.|
|[CA2224. Переопределяйте Equals при перегрузке оператора равенства](ca2224.md)|Открытый тип реализует оператор равенства, но не переопределяет <xref:System.Object.Equals%2A?displayProperty=fullName>.|
|[CA2225. Для перегрузок операторов существуют варианты с именами](ca2225.md)|Обнаружена перегрузка оператора, однако не найден ожидаемый именованный альтернативный метод. Именованный альтернативный член предоставляет те же функции, что и основной оператор, и его могут использовать разработчики, которые программируют на языках, не поддерживающих перегрузку операторов.|
|[CA2226. Перегрузки операторов должны быть симметричными](ca2226.md)|Тип реализует оператор равенства или неравенства, но не реализует противоположный оператор.|
|[CA2227. Свойства, возвращающие коллекции, должны быть доступными только для чтения](ca2227.md)|Свойство коллекции, допускающее запись, позволяет пользователю заменять одну коллекцию другой. Свойство только для чтения предотвращает замену коллекции, но по-прежнему допускает установку, настройку отдельных членов.|
|[CA2229. Реализуйте конструкторы сериализации](ca2229.md)|Чтобы устранить нарушение этого правила, реализуйте конструктор сериализации. Для запечатанного класса конструктор должен быть закрытым, а в иных случаях — защищенным.|
|[CA2231. Перегрузите оператор равенства на переопределяющем типе ValueType.Equals](ca2231.md)|Тип значения переопределяет `Object.Equals`, но не реализует оператор равенства.|
|[CA2234. Передавайте объекты System.Uri вместо строк](ca2234.md)|Вызывается метод, имеющий параметр строки, имя которого содержит uri, URI, urn, URN, url или URL.  Объявляющий тип метода содержит соответствующую перегрузку метода, которая имеет параметр <xref:System.Uri?displayProperty=fullName>.|
|[CA2235. Пометьте все несериализуемые поля](ca2235.md)|Экземпляр поля несериализуемого типа объявлен в сериализуемом типе.|
|[CA2237. Пометьте типы ISerializable атрибутом SerializableAttribute](ca2237.md)|Чтобы среда CLR распознавала тип как сериализуемый, он должен быть помечен атрибутом SerializableAttribute, даже если тип использует пользовательскую процедуру сериализации посредством реализации интерфейса `ISerializable`.|
|[CA2241. Задайте правильные аргументы для методов форматирования](ca2241.md)|Аргумент формата, переданный методу <xref:System.String.Format%2A?displayProperty=nameWithType>, не содержит элемент форматирования, соответствующий каждому аргументу объекта, или наоборот.|
|[CA2242. Правильно выполняйте проверку NaN](ca2242.md)|Это выражение проверяет значение на соответствие `Single.Nan` или `Double.Nan`. Используйте `Single.IsNan(Single)` или `Double.IsNan(Double)` для проверки значения.|
|[CA2243. Синтаксический разбор строковых литералов должен осуществляться правильно](ca2243.md)|Не удается правильно выполнить синтаксический анализ параметра строкового литерала атрибута для URL-адреса, идентификатора GUID или версии.|
|[CA2244: не повторяйте инициализацию индексируемых элементов](ca2244.md)|Инициализатор объектов имеет несколько инициализаторов индексированных элементов с одинаковым индексом константы. Все инициализаторы, кроме последнего, являются избыточными.|
|[CA2245: не назначайте свойство самому себе](ca2245.md)|Свойство было случайно назначено самому себе.|
|[CA2246: не присваивайте значения символу и его элементу в одном операторе](ca2246.md)|Не рекомендуется назначать символ и его член, то есть поле или свойство в одном операторе. Неясно, предназначался ли доступ к члену для использования старого значения символа до назначения или нового значения из назначения в этом операторе.|
|[CA2247: аргумент, переданный в конструктор TaskCompletionSource, должен быть перечислением TaskCreationOptions, а не TaskContinuationOptions](ca2247.md)|TaskCompletionSource имеет конструкторы, принимающие TaskCreationOptions, которые управляют базовой задачей, и конструкторы, которые принимают состояние объекта, сохраненное в задаче.  Случайная передача TaskContinuationOptions вместо TaskCreationOptions приведет к тому, что вызов будет рассматривать параметры как состояние.|
|[CA2248: укажите правильный аргумент enum для Enum.HasFlag](ca2248.md)|Тип перечисления, переданный в качестве аргумента вызову метода `HasFlag`, отличается от вызывающего типа перечисления.|
|[CA2249. Попробуйте использовать String.Contains вместо String.IndexOf.](ca2249.md)|Вызовы `string.IndexOf`, где результат используется для проверки на наличие или отсутствия подстроки, можно заменить `string.Contains`.|
