---
title: Правила разработки (анализ кода)
description: Сведения о правилах разработки для анализа кода.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.designrules
helpviewer_keywords:
- design rules
- managed code analysis rules, design rules
- rules, design
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 548e0eaaa6239a9b9ee6a08677cd720710bb48c2
ms.sourcegitcommit: 05d0087dfca85aac9ca2960f86c5efd218bf833f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/30/2021
ms.locfileid: "99714135"
---
# <a name="design-rules"></a>Правила разработки

Правила разработки поддерживают соблюдение [рекомендаций по разработке для .NET Framework](../../../standard/design-guidelines/index.md).

## <a name="in-this-section"></a>Содержание раздела

| Правило | Описание |
| - | - |
| [CA1000. Не объявляйте статические члены в универсальных типах](ca1000.md) | При вызове статического элемента универсального типа нужно указать аргумент этого типа. При вызове универсального экземпляра элемента, не поддерживающего вывод типа, для элемента нужно указать аргумент типа. В этих двух случаях синтаксис для определения аргумента типа различен, и его можно легко спутать. |
| [CA1001. Типы, которым принадлежат освобождаемые поля, должны быть освобождаемыми](ca1001.md) | В классе объявляется и реализуется поле экземпляра, которое принадлежит типу System.IDisposable, однако класс не реализует интерфейс IDisposable. Класс, в котором объявляется поле IDisposable, неявно владеет неуправляемым ресурсом и должен реализовывать интерфейс IDisposable. |
| [CA1002. Не предоставляйте универсальные списки](ca1002.md) | System.Collections.Generic.List<(Of \<(T>)>) — это универсальная коллекция, предназначенная не для наследования, а для повышения производительности. Поэтому виртуальные элементы в списке отсутствуют. Вместо этого для наследования следует предоставить универсальную коллекцию. |
| [CA1003. Используйте экземпляры обработчика универсальных событий](ca1003.md) | Тип содержит делегат, возвращающий значение void, сигнатура которого содержит два параметра (первый — объект, а второй — тип, который может быть назначен EventArgs), а включающая сборка предназначена для платформы .NET Framework 2.0. |
| [CA1005. Не используйте слишком много параметров в универсальных типах](ca1005.md) | Чем больше параметров типов содержит универсальный тип, тем сложнее знать и запоминать, что представляет каждый параметр типа. Обычно ситуация очевидна при использовании одного параметра типа, как в List\<T>, и в ряде случаев с двумя параметрами типов, как в Dictionary\<TKey, TValue>. Если же используется более двух параметров типов, многие пользователи начинают испытывать большие трудности. |
| [CA1008. Перечисляемые типы должны иметь нулевое значение](ca1008.md) | Значение по умолчанию неинициализированного перечисления, как и других типов значений, равно нулю. Перечисление без флагов в качестве атрибутов должно определять член с использованием нулевого значения так, чтобы значение по умолчанию было допустимым значением перечисления. Если перечисление с примененным атрибутом FlagsAttribute определяет член с нулевым значением, для него должно быть задано имя None, свидетельствующее о том, что в перечислении не были заданы значения. |
| [CA1010. Коллекции должны реализовать универсальный интерфейс](ca1010.md) | Чтобы расширить возможности использования коллекции, реализуйте один из универсальных интерфейсов коллекции. Затем данную коллекцию можно использовать для заполнения универсальных типов коллекции. |
| [CA1012. Абстрактные типы не должны иметь конструкторы](ca1012.md) | Конструкторы абстрактных типов могут быть вызваны только производными типами. Открытые конструкторы создают экземпляры типа. Невозможно создавать экземпляры абстрактного типа; абстрактный тип с открытым конструктором является недопустимым. |
| [CA1014. Пометьте сборки с помощью CLSCompliantAttribute](ca1014.md) | Спецификация среды CLS определяет ограничения по именованию, типам данных и правилам, которым должны соответствовать сборки, предназначенные для использования в нескольких языках программирования. Для всех сборок рекомендуется явным образом указывать совместимость с CLS с помощью атрибута CLSCompliantAttribute. Если этот атрибут у сборки отсутствует, сборка несовместима. |
| [CA1016. Пометьте сборки с помощью AssemblyVersionAttribute](ca1016.md) | .NET использует номер версии для уникального обозначения сборки и для привязки к типам в сборках со строгими именами. Номер версии используется наряду с политикой версий и издателя. По умолчанию приложения выполняются только с версией сборки, которая использовалась для их построения. |
| [CA1017. Пометьте сборки с помощью ComVisibleAttribute](ca1017.md) | Атрибут ComVisibleAttribute определяет порядок обращения клиентов COM к управляемому коду. Для правильной разработки сборки должны явным образом указывать видимость COM. Можно задать видимость COM для всей сборки, а затем переопределить ее для отдельных типов и элементов типов. Если атрибут отсутствует, содержимое сборки будет видимым клиентам COM. |
| [CA1018. Пометьте атрибуты с помощью AttributeUsageAttribute](ca1018.md) | При определении настраиваемого атрибута его нужно пометить атрибутом AttributeUsageAttribute, чтобы указать, где можно применять этот настраиваемый атрибут в исходном коде. Допустимое положение атрибута в коде зависит от значения атрибута и его применения. |
| [CA1019. Определите методы доступа для аргументов атрибута](ca1019.md) | Атрибуты могут определять обязательные аргументы, которые должны быть указаны при применении атрибута к целевому объекту. Они также известны как позиционные аргументы, поскольку предоставляются для конструкторов атрибутов в качестве позиционных параметров. Для каждого обязательного аргумента атрибут должен предоставлять соответствующее свойство, доступное только для чтения, чтобы извлечь значение аргумента во время выполнения. Кроме того, атрибуты могут определять дополнительные параметры, известные как именованные аргументы. Эти аргументы предоставляются для конструкторов атрибутов по имени и должны иметь соответствующее свойство чтения/записи. |
| [CA1021. Не используйте параметры out](ca1021.md) | Для реализации передачи типов по ссылке (с помощью ключевого слова out или ref) от разработчика требуется опыт работы с указателями, понимание отличия между типами значения и ссылочными типами и умение работать с методами с несколькими возвращаемыми значениями. Кроме того, далеко не все понимают разницу между параметрами out и ref. |
| [CA1024. По возможности используйте свойства](ca1024.md) | Имя открытого или защищенного метода начинается с Get, он не принимает параметры и возвращает значение, не являющееся массивом. Возможно, этот метод лучше преобразовать в свойство. |
| [CA1027. Пометьте перечисляемые типы с помощью FlagsAttribute](ca1027.md) | Перечисление является типом значения, которое определяет набор связанных именованных констант. Атрибут FlagsAttribute применяется к перечислению, когда его именованные константы могут быть объединены осмысленным образом. |
| [CA1028. Хранилище перечисляемых типов должно относиться к типу Int32](ca1028.md) | Перечисление является типом значения, которое определяет набор связанных именованных констант. По умолчанию для хранения значения константы используется тип данных System.Int32. Этот базовый тип можно изменить, но это не требуется и в большинстве случаев не рекомендуется. |
| [CA1030. По возможности используйте события](ca1030.md) | Данное правило отслеживает методы с именами, которые, как правило, используются для событий. Если метод вызывается в ответ на четко определенное изменение состояния, то этот вызов должен осуществляться с помощью обработчика событий. Объекты, вызывающие методы, должны создавать события, а не вызывать методы напрямую. |
| [CA1031. Не перехватывайте типы общих исключений](ca1031.md) | Общие исключения не должны перехватываться. Нужно перехватить исключение более конкретного характера или повторно выдать общее исключение в последнем операторе блока catch. |
| [CA1032. Реализуйте стандартные конструкторы исключений](ca1032.md) | Для правильной обработки исключений необходимо предоставить полный набор конструкторов. |
| [CA1033. Методы интерфейса должны быть доступны для вызова дочерними типами](ca1033.md) | Незапечатанный тип, доступный для внешнего кода, предоставляет явную реализацию метода открытого интерфейса и не предоставляет доступный для внешнего кода альтернативный метод с тем же именем. |
| [CA1034. Вложенные типы не должны быть видимыми](ca1034.md) | Вложенный тип — это тип, объявленный внутри области другого типа. Вложенные типы удобно использовать для инкапсуляции закрытых сведений о реализациях содержащего их типа. В силу этого вложенные типы не должны быть видимыми для внешнего кода. |
| [CA1036. Переопределите методы в сопоставимых типах](ca1036.md) | Открытый или защищенный тип реализует интерфейс System.IComparable. Он не переопределяет метод Object.Equals и не перегружает языковой оператор равенства, неравенства, "больше" или "меньше". |
| [CA1040. Не используйте пустые интерфейсы](ca1040.md) | Интерфейсы определяют члены, предоставляющие поведение или соглашение об использовании. Функциональность, описанная интерфейсом, может быть использована любым типом вне зависимости от расположения типа в иерархии интерфейса. Тип реализует интерфейс путем предоставления реализаций для членов интерфейса. Пустой интерфейс не определяет никаких элементов, поэтому он не определяет контракт, который можно реализовать. |
| [CA1041. Укажите сообщение ObsoleteAttribute](ca1041.md) | Тип или элемент помечен атрибутом System.ObsoleteAttribute, для которого не указано свойство ObsoleteAttribute.Message. При компиляции типа или члена, помеченного с помощью атрибута ObsoleteAttribute, отображается свойство Message атрибута, которое предоставляет пользователю сведения об устаревшем типе или члене. |
| [CA1043. Используйте целый или строковый аргумент для индексаторов](ca1043.md) | Индексаторы (индексированные свойства) должны использовать для индекса целочисленные или строковые типы. Эти типы обычно используются для индексации структур данных и повышения удобства использования библиотеки. Тип Object следует использовать только в том случае, если во время разработки невозможно указать определенный целочисленный или строковый тип. |
| [CA1044. Свойства не должны быть доступными только для записи](ca1044.md) | Несмотря на то, что допустимо, а часто и необходимо иметь свойство, доступное только на чтение, рекомендации по разработке запрещают использование свойств, доступных только на запись. Это связано с тем, что если позволить пользователю задать значение, а затем запретить ему просматривать это значение, то таким образом не будет обеспечиваться какая-либо безопасность. Кроме того, при отсутствии доступа на чтение нельзя просмотреть состояние общих объектов, что снижает их полезность. |
| [CA1045. Не передавайте типы по ссылке](ca1045.md) | Для реализации передачи типов по ссылке (с помощью ключевого слова out или ref) от разработчика требуется опыт работы с указателями, понимание отличия между типами значения и ссылочными типами и умение работать с методами с несколькими возвращаемыми значениями. Архитекторам, разрабатывающим библиотеки для широкого использования, не следует рассчитывать, что пользователи прекрасно разбираются в использовании параметров out и ref. |
| [CA1046. Не перегружайте оператор равенства для ссылочных типов](ca1046.md) | Реализация оператора равенства по умолчанию почти всегда правильно работает для ссылочных типов. По умолчанию две ссылки равны, если они указывают на один объект. |
| [CA1047. Не объявляйте защищенные члены в запечатанных типах](ca1047.md) | Типы объявляют защищенный члены таким образом, чтобы наследующие типы могли получить доступ к члену или переопределить его. По определению наследовать запечатанные типы нельзя; это означает, что вызов защищенных методов для запечатанных типов невозможен. |
| [CA1050. Объявите типы в пространствах имен](ca1050.md) | Типы объявляются в пространствах имен во избежание конфликтов имен и с целью упорядочения связанных типов в иерархии объектов. |
| [CA1051. Не объявляйте видимые поля экземпляров](ca1051.md) | Поля главным образом следует использовать для данных реализации. Поля должны быть помечены как private или internal и должны быть представлены с помощью свойств. |
| [CA1052. Типы со статическими заполнителями должны быть запечатаны](ca1052.md) | Открытый или защищенный тип содержит только статические элементы и не объявлен с модификатором sealed (C#) или NotInheritable (Visual Basic). Тип, для которого нельзя создавать унаследованные типы, должен быть помечен модификатором sealed, чтобы его нельзя было использовать как базовый тип. |
| [CA1053. Типы со статическими заполнителями не должны иметь конструкторы](ca1053.md) | В открытом или вложенном открытом типе объявляются только статические элементы и имеется открытый или защищенный конструктор по умолчанию. Конструктор не нужен, поскольку при вызове статических членов не требуется экземпляр типа. Для обеспечения безопасности перегруженная строка должна вызывать перегрузку универсального кода ресурса (URI), используя строковый аргумент. |
| [CA1054. Параметры URI не должны быть строками](ca1054.md) | Если метод принимает строковое представление универсального кода ресурса (URI), необходимо предоставить соответствующую перегрузку, принимающую экземпляр класса URI, который предоставляет эти услуги безопасным образом. |
| [CA1055. Возвращаемые значения URI не должны быть строками](ca1055.md) | В этом правиле предполагается, что метод возвращает универсальный код ресурса (URI). В строковых представлениях кода URI часто встречаются ошибки синтаксического анализа и кодирования, которые могут привести к уязвимостям системы безопасности. Класс System.Uri предоставляет аналогичные услуги более надежным и безопасным способом. |
| [CA1056. Свойства URI не должны быть строками](ca1056.md) | В этом правиле предполагается, что свойство представляет URI. В строковых представлениях кода URI часто встречаются ошибки синтаксического анализа и кодирования, которые могут привести к уязвимостям системы безопасности. Класс System.Uri предоставляет аналогичные услуги более надежным и безопасным способом. |
| [CA1058. Типы не должны расширять определенные базовые типы](ca1058.md) | Видимый извне тип расширяет некоторые базовые типы. Используйте только один вариант. |
| [CA1060: переместите P/Invokes в класс NativeMethods](ca1060.md) | Методы вызова платформы, например помеченные <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName>, или методы, определенные с помощью ключевого слова Declare в Visual Basic, обращаются к неуправляемому коду. Эти методы должны относиться к классу NativeMethods, SafeNativeMethods или UnsafeNativeMethods. |
| [CA1061. Не скрывайте методы базовых классов](ca1061.md) | Метод в базовом типе скрыт методом с таким же именем в производном типе. Сигнатура параметра производного метода отличается только типами, которые являются более слабыми, чем соответствующие типы в сигнатуре параметра базового метода. |
| [CA1062. Проверьте аргументы или открытые методы](ca1062.md) | Все ссылочные аргументы, передаваемые в видимые для внешнего кода методы, должны проверяться на равенство значению NULL. |
| [CA1063. Правильно реализуйте IDisposable](ca1063.md) | Все типы IDisposable должны правильно реализовывать шаблон "Dispose". |
| [CA1064. Исключения должны быть общими](ca1064.md) | Внутреннее исключение видно только внутри своей внутренней области. После выхода исключения за пределы внутренней области для перехвата исключения можно использовать только базовое исключение. Если внутреннее исключение унаследовано от <xref:System.Exception?displayProperty=fullName>, <xref:System.SystemException?displayProperty=fullName> или <xref:System.ApplicationException?displayProperty=fullName>, внешний код не имеет достаточных данных для обработки этого исключения. |
| [CA1065. Не вызывайте исключения в непредвиденных местах](ca1065.md) | Метод вызывает исключение, хотя не должен этого делать. |
| [CA1066: реализация IEquatable при переопределении Equals](ca1066.md) | Тип значения переопределяет метод <xref:System.Object.Equals%2A>, но не реализует <xref:System.IEquatable%601>. |
| [CA1067: переопределение Equals при реализации IEquatable](ca1067.md) | Тип реализует <xref:System.IEquatable%601>, но не переопределяет метод <xref:System.Object.Equals%2A>. |
| [CA1068: Параметры CancellationToken должны быть последними](ca1068.md) | Метод имеет параметр CancellationToken, который не является последним параметром. |
| [CA1069: перечисления не должны иметь повторяющихся значений](ca1069.md) | Перечисление содержит несколько элементов, которым явным образом присвоено одно и то же значение константы. |
| [CA1070: не объявляйте поля событий как виртуальные](ca1070.md) | [Событие, похожее на поле](../../../csharp/event-pattern.md#defining-and-raising-field-like-events), было объявлено как виртуальное. |
