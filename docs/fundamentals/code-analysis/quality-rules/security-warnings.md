---
title: Правила безопасности (анализ кода)
description: Сведения о правилах безопасности анализа кода.
ms.date: 10/02/2019
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security rules
- managed code analysis rules, security rules
- rules, security
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 861827662a771ec7cc1827cdd8125be6c05bf05c
ms.sourcegitcommit: 05d0087dfca85aac9ca2960f86c5efd218bf833f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/30/2021
ms.locfileid: "99719725"
---
# <a name="security-rules"></a>Правила безопасности

Правила безопасности поддерживают безопасность библиотек и приложений. Эти предупреждения помогают устранить уязвимости в программе. Если вы отключаете какое-либо из этих правил, вы должны четко обозначить в коде причину этого отключения, а также оповестить сотрудника, отвечающего за безопасность проекта разработки.

## <a name="in-this-section"></a>Содержание раздела

|Правило|Описание|
|----------|-----------------|
|[CA2100. Проверьте запросы SQL на наличие уязвимостей системы безопасности](ca2100.md)|Метод задает свойство System.Data.IDbCommand.CommandText с использованием строки, созданной из строкового аргумента метода. Это правило предполагает, что строковый аргумент содержит введенные пользователем данные. Созданная из введенных пользователем данных командная строка SQL уязвима перед атаками путем внедрения кода SQL.|
|[CA2109. Проверьте видимые обработчики событий](ca2109.md)|Обнаружен открытый или защищенный метод обработки событий. Методы обработки событий следует раскрывать только в тех случаях, когда это совершенно необходимо.|
|[CA2119. Запечатайте методы, соответствующие частным интерфейсам](ca2119.md)|Наследуемый открытый тип предоставляет реализацию переопределяемого метода внутреннего (Friend в Visual Basic) интерфейса. Для устранения нарушения данного правила следует исключить возможность переопределения метода за пределами сборки.|
|[CA2153. Не используйте обработку исключений поврежденного состояния](ca2153.md)|[Исключения сбоя состояния (CSE)](/archive/msdn-magazine/2009/february/clr-inside-out-handling-corrupted-state-exceptions) указывают на то, что в процессе имеется повреждение памяти. Если перехватывать их вместо того, чтобы позволить процессу завершиться сбоем, это может привести к уязвимостям в системе безопасности, если злоумышленнику удастся поместить эксплойт в поврежденную область памяти.|
|[CA2300. Не используйте небезопасный десериализатор BinaryFormatter](ca2300.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные и включить в них непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2301. Не вызывайте BinaryFormatter.Deserialize, не задав предварительно BinaryFormatter.Binder](ca2301.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные и включить в них непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2302. Убедитесь, что BinaryFormatter.Binder задан перед вызовом BinaryFormatter.Deserialize](ca2302.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные и включить в них непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2305. Не используйте небезопасный десериализатор LosFormatter](ca2305.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные и включить в них непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2310. Не используйте небезопасный десериализатор NetDataContractSerializer](ca2310.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные и включить в них непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2311. Не десериализируйте, не задав предварительно NetDataContractSerializer.Binder](ca2311.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные и включить в них непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2312. Убедитесь, что NetDataContractSerializer.Binder задан перед десериализацией](ca2312.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные и включить в них непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2315. Не используйте небезопасный десериализатор ObjectStateFormatter](ca2315.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные и включить в них непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2321. Не десериализируйте с помощью JavaScriptSerializer, используя SimpleTypeResolver](ca2321.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные и включить в них непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2322. Убедитесь, что JavaScriptSerializer не был инициализирован с помощью SimpleTypeResolver до десериализации](ca2322.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные и включить в них непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2326. Не используйте значения TypeNameHandling, отличные от None](ca2326.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные и включить в них непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2327. Не используйте небезопасные JsonSerializerSettings](ca2327.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные и включить в них непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2328. Убедитесь в безопасности JsonSerializerSettings](ca2328.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные и включить в них непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2329. Не выполняйте десериализацию с помощью JsonSerializer, используя небезопасную конфигурацию](ca2329.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные и включить в них непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2330. Убедитесь, что в JsonSerializer есть безопасная конфигурация при десериализации](ca2330.md)|Небезопасные десериализаторы уязвимы при десериализации ненадежных данных. Злоумышленник может изменить сериализованные данные и включить в них непредвиденные типы для внедрения объектов с вредоносными побочными эффектами.|
|[CA2350. Убедитесь, что входные данные DataTable.ReadXml() являются доверенными](ca2350.md)|При десериализации <xref:System.Data.DataTable> с недоверенными входными данными злоумышленник может создавать вредоносные входные данные для проведения атаки типа "отказ в обслуживании". Могут существовать неизвестные уязвимости удаленного выполнения кода.|
|[CA2351. Убедитесь, что входные данные DataSet.ReadXml() являются доверенными](ca2351.md)|При десериализации <xref:System.Data.DataSet> с недоверенными входными данными злоумышленник может создавать вредоносные входные данные для проведения атаки типа "отказ в обслуживании". Могут существовать неизвестные уязвимости удаленного выполнения кода.|
|[CA2352. Ненадежные данные DataSet или DataTable в сериализуемом типе могут быть уязвимыми для атак удаленного выполнения кода](ca2352.md)|Класс или структура с пометкой <xref:System.SerializableAttribute> содержит поле или свойство <xref:System.Data.DataSet> или <xref:System.Data.DataTable> и не имеет <xref:System.CodeDom.Compiler.GeneratedCodeAttribute>.|
|[CA2353. Ненадежные данные DataSet или DataTable в сериализуемом типе](ca2353.md)|Класс или структура, помеченная атрибутом сериализации XML или атрибутом контракта данных, содержит поле или свойство <xref:System.Data.DataSet> или <xref:System.Data.DataTable>.|
|[CA2354. Ненадежные данные DataSet или DataTable в графе десериализованных объектов могут быть уязвимыми для атаки удаленного выполнения кода](ca2354.md)|Десериализация с сериализованным <xref:System.Runtime.Serialization.IFormatter?displayProperty=nameWithType>, и граф объектов приведенного типа может включать <xref:System.Data.DataSet> или <xref:System.Data.DataTable>.|
|[CA2355. Ненадежные данные DataSet или DataTable в графе десериализованных объектов](ca2355.md)|Десериализация, когда граф объектов приведенного или указанного типа может включать <xref:System.Data.DataSet> или <xref:System.Data.DataTable>.|
|[CA2356: ненадежные данные DataSet или DataTable в графе десериализованных веб-объектов](ca2356.md)|Метод с <xref:System.Web.Services.WebMethodAttribute?displayProperty=nameWithType> или <xref:System.ServiceModel.OperationContractAttribute?displayProperty=nameWithType> имеет параметр, который может ссылаться на <xref:System.Data.DataSet> или <xref:System.Data.DataTable>.|
|[CA2361. Проверка того, что автоматически сформированный класс, который содержит DataSet.ReadXml(), не используется с ненадежными данными](ca2361.md)|При десериализации <xref:System.Data.DataSet> с недоверенными входными данными злоумышленник может создавать вредоносные входные данные для проведения атаки типа "отказ в обслуживании". Могут существовать неизвестные уязвимости удаленного выполнения кода.|
|[CA2362. Ненадежные данные DataSet или DataTable в автоматически созданном сериализуемом типе могут быть уязвимыми для атак удаленного выполнения кода](ca2362.md)|В случае десериализации ненадежных входных данных с помощью класса <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> и если граф десериализованных объектов содержит <xref:System.Data.DataSet> или <xref:System.Data.DataTable>, злоумышленник может создавать вредоносные данные для проведения атаки удаленного выполнения кода.|
|[CA3001. Проверьте код на наличие уязвимостей к внедрению кода SQL](ca3001.md)|При работе с ненадежными входными данными и командами SQL следует учитывать вероятность атак путем внедрения кода SQL. Атака путем внедрения кода SQL позволяет выполнять вредоносные команды SQL, нарушая безопасность и целостность приложения.|
|[CA3002. Проверьте код на наличие уязвимостей к межсайтовым сценариям (XSS)](ca3002.md)|При работе с ненадежными входными данными из веб-запросов следует учитывать возможность атак с использованием межсайтовых сценариев (XSS). При атаке XSS ненадежные входные данные внедряются в необработанные выходные данные HTML-ответа, что позволяет злоумышленнику выполнять вредоносные сценарии или умышленно изменять содержимое на веб-странице.|
|[CA3003. Проверьте код на наличие уязвимостей к внедрению пути к файлу](ca3003.md)|При работе с ненадежными входными данными из веб-запросов важно с осторожностью использовать вводимые пользователем данные при указании путей к файлам.|
|[CA3004. Проверьте код на наличие уязвимостей к раскрытию информации](ca3004.md)|Раскрытие сведений об исключениях дает злоумышленникам сведения о внутренних компонентах приложения, что может помочь им найти другие уязвимости для эксплойта.|
|[CA3006. Проверьте код на наличие уязвимостей к внедрению команд процесса](ca3006.md)|При работе с ненадежными входными данными следует учитывать вероятность атак путем внедрения команд. Атака путем внедрения команды может выполнять вредоносные команды в базовой операционной системе, нарушая безопасность и целостность сервера.|
|[CA3007. Проверьте код на наличие уязвимостей к открытому перенаправлению](ca3007.md)|При работе с ненадежными входными данными не забывайте об уязвимостях открытых перенаправлений. Злоумышленник может воспользоваться уязвимостью открытого перенаправления, чтобы через URL-адреса правильного вида перенаправлять посетителей вашего веб-сайта на веб-страницу для фишинга или других вредоносных действий.|
|[CA3008. Проверьте код на наличие уязвимостей к внедрению кода XPath](ca3008.md)|При работе с ненадежными входными данными следует учитывать вероятность атак путем внедрения кода XPath. Создание запросов XPath с использованием ненадежных входных данных может позволить злоумышленнику манипулировать запросом, возвращая неправильные результаты или даже раскрывая содержимое запрашиваемого XML.|
|[CA3009. Проверьте код на наличие уязвимостей к внедрению кода XML](ca3009.md)|При работе с ненадежными входными данными следует учитывать вероятность атак путем внедрения кода XML.|
|[CA3010. Проверьте код на наличие уязвимостей к внедрению кода XAML](ca3010.md)|При работе с ненадежными входными данными следует учитывать вероятность атак путем внедрения кода XAML. XAML — это язык разметки, непосредственно представляющий создание и выполнение объекта. Это означает, что элементы, созданные в XAML, могут взаимодействовать с системными ресурсами (например, сетевым доступом и операциями ввода-вывода файловой системы).|
|[CA3011. Проверьте код на наличие уязвимостей к внедрению DLL](ca3011.md)|При работе с ненадежными входными данными следует учитывать возможность загрузки недоверенного кода. Если веб-приложение загружает недоверенный код, злоумышленник может внедрить вредоносные библиотеки DLL в процесс и выполнить вредоносный код.|
|[CA3012. Проверьте код на наличие уязвимостей к внедрению регулярных выражений](ca3012.md)|При работе с ненадежными входными данными следует учитывать вероятность атак путем внедрения кода в регулярные выражения. Злоумышленник может использовать внедрение кода в регулярное выражение для злонамеренных изменений, например чтобы регулярное выражение возвращало некорректные результаты или использовало чрезмерное количество ресурсов ЦП для создания атаки типа "отказ в обслуживании".|
|[CA3061. Не добавлять схему по URL-адресу](ca3061.md)|Не используйте небезопасную перегрузку метода Add, так как она может вызвать опасные внешние ссылки.|
|[CA3075. Обработка небезопасных DTD](ca3075.md)|Если вы используете небезопасные экземпляры DTDProcessing или ссылаетесь на источники внешних сущностей, средство синтаксического анализа может принять недоверенные входные данные и раскрыть конфиденциальную информацию злоумышленникам.|
|[CA3076. Выполнение небезопасного скрипта XSLT](ca3076.md)|При небезопасном выполнении XSLT в приложениях .NET обработчик может разрешить недоверенные ссылки URI, раскрывающие конфиденциальную информацию злоумышленникам, что приведет к атакам типа "отказ в обслуживании" и межсайтовым атакам.|
|[CA3077. Небезопасная обработка в структуре API средств чтения документов и текста XML](ca3077.md)|При разработке API, производных от XMLDocument и XMLTextReader, обратите внимание на DtdProcessing. Использование небезопасных экземпляров DTDProcessing при ссылке на источники внешних сущностей или их разрешении, а также при задании небезопасных значений в XML может привести к раскрытию информации.|
|[CA3147. Присвоение метки ValidateAntiForgeryToken обработчикам команд](ca3147.md)|При разработке контроллера MVC ASP.NET следует учитывать атаки с подделкой межсайтовых запросов (CSRF). Атака с использованием подделки межсайтовых запросов позволяет отправлять вредоносные запросы от пользователя, прошедшего проверку подлинности, в контроллер MVC ASP.NET.|
|[CA5350. Не используйте ненадежные алгоритмы шифрования](ca5350.md)|Ненадежные алгоритмы шифрования и функции хэширования еще используются сегодня по ряду причин, но они не должны использоваться для обеспечения конфиденциальности или целостности данных, которые они защищают. Это правило срабатывает при обнаружении в коде алгоритмов TripleDES, SHA1 или RIPEMD160.|
|[CA5351: не используйте ослабленные алгоритмы шифрования](ca5351.md)|Ослабленные алгоритмы шифрования не считаются безопасными, и их использование настоятельно не рекомендуется. Это правило срабатывает при обнаружении в коде хэш-алгоритма MD5 или алгоритмов шифрования RC2 или DES.|
|[CA5358. Не используйте небезопасные режимы шифрования](ca5358.md)|Не используйте небезопасные режимы шифрования|
|[CA5359: не отключайте проверку сертификатов](ca5359.md)|Сертификат может помочь при проверке подлинности удостоверения сервера. Клиенты должны проверить сертификат сервера, чтобы обеспечить отправку запросов на нужный сервер. Если ServerCertificateValidationCallback всегда возвращает значение `true`, любой сертификат будет проходить проверку.|
|[CA5360: не вызывайте опасные методы десериализации](ca5360.md)|Небезопасная десериализация — это уязвимость, которая возникает, когда недоверенные данные используются для нарушения логики приложения, проведения атаки типа "отказ в обслуживании" или даже для выполнения произвольного кода после десериализации. Злоумышленники часто могут злоупотреблять этими функциями десериализации, когда приложение десериализует недоверенные данные, которые находятся под контролем злоумышленников. В частности, они могут вызывать опасные методы в процессе десериализации. Успешные атаки небезопасной десериализации могут позволить злоумышленнику выполнять такие действия, как атаки типа "отказ в обслуживании", обходы проверки подлинности и удаленное выполнение кода.|
|[CA5361: не отключайте использование стойкого шифрования SChannel](ca5361.md)|Установка `Switch.System.Net.DontEnableSchUseStrongCrypto` в `true` ослабляет шифрование, используемое в исходящих подключениях по протоколу TLS. Более слабое шифрование может нарушить конфиденциальность взаимодействия между приложением и сервером, что облегчит злоумышленникам перехват конфиденциальных данных.|
|[CA5362: потенциальный цикл ссылок в графе десериализованных объектов](ca5362.md)|При десериализации недоверенных данных любой код, обрабатывающий десериализованный граф объекта, должен обрабатывать циклы ссылок без перехода в бесконечные циклы. Сюда входит код, который является частью обратного вызова десериализации, и код, обрабатывающий граф объекта после завершения десериализации. В противном случае злоумышленник может выполнить атаку типа "отказ в обслуживании" с вредоносными данными, содержащими цикл ссылок.|
|[CA5363. Не отключать проверку запросов](ca5363.md)|Проверка запросов — это функция в ASP.NET, которая проверяет HTTP-запросы и определяет, включают ли они потенциально опасное содержимое, которое может привести к атакам путем внедрения кода, включая подделку межсайтовых запросов.|
|[CA5364. Не используйте нерекомендуемые протоколы безопасности](ca5364.md)|Протокол TLS обеспечивает безопасность взаимодействия между компьютерами, чаще всего с помощью протокола HTTPS. Более ранние версии протокола TLS менее безопасны, чем TLS 1.2 и TLS 1.3, и, скорее всего, будут подвержены новым уязвимостям. Избегайте использования более ранних версий протокола, чтобы снизить риск.|
|[CA5365: не отключайте проверку заголовков HTTP](ca5365.md)|Проверка HTTP-заголовка позволяет кодировать символы возврата каретки \r и новой строки \n, которые находятся в заголовках ответа. Эта кодировка помогает избежать атак путем внедрения, эксплуатирующих приложение, которое выводит на экран недоверенные данные, содержащиеся в заголовке.|
|[CA5366: используйте XmlReader для чтения XML из набора данных](ca5366.md)|Использование <xref:System.Data.DataSet> для чтения XML с ненадежными данными может привести к загрузке опасных внешних ссылок, что следует ограничить, используя <xref:System.Xml.XmlReader> с безопасным сопоставителем или отключив обработку DTD.|
|[CA5367: не сериализуйте типы с полями указателей](ca5367.md)|Это правило проверяет, существует ли сериализуемый класс с полем указателя или свойством. Элементы, которые не могут быть сериализованы, могут быть указателями, такими как статические члены или поля, помеченные атрибутом <xref:System.NonSerializedAttribute>.|
|[CA5368: задайте ViewStateUserKey для классов, производных от Page](ca5368.md)|Установка свойства <xref:System.Web.UI.Page.ViewStateUserKey> поможет предотвратить атаки на приложение, позволяя назначить идентификатор переменной состояния представления для отдельных пользователей, чтобы злоумышленники не могли использовать эту переменную для создания атаки. В противном случае будут обнаружены уязвимости для подделки межсайтовых запросов.|
|[CA5369. Использование XmlReader для десериализации](ca5369.md)|Обработка недоверенных DTD и схем XML может разрешить загрузку опасных внешних ссылок, которые должны быть ограничены с помощью XmlReader с безопасным распознавателем или с отключенной обработкой DTD и встроенных схем DTD.|
|[CA5370. Использование XmlReader для проверки модуля чтения](ca5370.md)|Обработка недоверенных DTD и схем XML может разрешить загрузку опасных внешних ссылок. Эту опасную загрузку можно ограничить, используя XmlReader с защищенным распознавателем или с отключенной обработкой встроенных схем DTD и XML.|
|[CA5371. Использование XmlReader для чтения схемы](ca5371.md)|Обработка недоверенных DTD и схем XML может разрешить загрузку опасных внешних ссылок. Использование XmlReader с защищенным распознавателем или с отключенной обработкой встроенных схем DTD и XML позволяет ограничить эту возможность.|
|[CA5372. Использование XmlReader для XPathDocument](ca5372.md)|Обработка XML-кода из ненадежных данных может привести к загрузке опасных внешних ссылок, что можно ограничить, используя XmlReader с безопасным сопоставителем или отключив обработку DTD.|
|[CA5373. Не использовать устаревшую функцию формирования ключа](ca5373.md)|Это правило обнаруживает вызов методов наследования слабых ключей <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> и `Rfc2898DeriveBytes.CryptDeriveKey`. Метод <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> использовал слабый алгоритм PBKDF1.|
|[CA5374: не используйте XslTransform](ca5374.md)|Это правило проверяет, создается ли экземпляр <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> в коде. <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> теперь является устаревшим и не должен использоваться.|
|[CA5375: не используйте подписанный URL-адрес учетной записи](ca5375.md)|Подписанный URL-адрес (SAS) учетной записи может делегировать доступ к операциям чтения, записи и удаления в контейнерах больших двоичных объектов, таблицах, очередях и общих папках, которые запрещены в SAS службы. Однако он не поддерживает политики уровня контейнеров и обладает меньшей гибкостью и уровнем контроля предоставленных разрешений. Если злоумышленники его получат, они смогут с легкостью взломать вашу учетную запись хранения.|
|[CA5376: используйте SharedAccessProtocol HttpsOnly](ca5376.md)|SAS — это конфиденциальные данные, которые нельзя передавать в виде обычного текста по протоколу HTTP.|
|[CA5377: используйте политику доступа на уровне контейнера](ca5377.md)|Политику доступа на уровне контейнера можно изменить или отозвать в любое время. Она обеспечивает большую гибкость и контроль над предоставляемыми разрешениями.|
|[CA5378. Не отключайте ServicePointManagerSecurityProtocols](ca5378.md)|Задание для `DisableUsingServicePointManagerSecurityProtocols` значения `true` разрешает использовать только протокол TLS 1.0 в Windows Communication Framework. Эта версия TLS будет считаться нерекомендуемой.|
|[CA5379: убедитесь, что алгоритм функции формирования ключа достаточно надежен](ca5379.md)|Класс <xref:System.Security.Cryptography.Rfc2898DeriveBytes> по умолчанию использует алгоритм <xref:System.Security.Cryptography.HashAlgorithmName.SHA1>. Вам нужно указать хэш-алгоритм для использования в некоторых перегрузках конструктора с помощью <xref:System.Security.Cryptography.HashAlgorithmName.SHA256> или выше. Обратите внимание, что свойство <xref:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm> имеет только метод доступа `get` и не имеет модификатор `overriden`.|
|[CA5380. Не добавлять сертификаты в корневое хранилище](ca5380.md)|Это правило обнаруживает код, который добавляет сертификат в хранилище сертификатов Доверенных корневых центров сертификации. По умолчанию хранилище сертификатов Доверенных корневых центров сертификации настроено с набором общедоступных центров сертификации, удовлетворяющих требованиям Программы корневых сертификатов Майкрософт.|
|[CA5381. Убедиться, что сертификаты не добавлены в корневое хранилище](ca5381.md)|Это правило обнаруживает код, который может добавлять сертификат в хранилище сертификатов Доверенных корневых центров сертификации. По умолчанию хранилище сертификатов Доверенных корневых центров сертификации настроено с набором общедоступных центров сертификации, удовлетворяющих требованиям Программы корневых сертификатов Майкрософт.|
|[CA5382: используйте защищенные файлы cookie в ASP.NET Core](ca5382.md)|Приложения, доступные по протоколу HTTPS, должны использовать защищенные файлы cookie, что указывает браузеру на то, что файлы cookie следует передавать только по протоколу TLS.|
|[CA5383: убедитесь в использовании защищенных файлов cookie в ASP.NET Core](ca5383.md)|Приложения, доступные по протоколу HTTPS, должны использовать защищенные файлы cookie, что указывает браузеру на то, что файлы cookie следует передавать только по протоколу TLS.|
|[CA5384: не используйте алгоритм DSA](ca5384.md)|DSA — это слабый алгоритм асимметричного шифрования.|
|[CA5385: используйте алгоритм шифрования RSA с достаточным размером ключа](ca5385.md)|Ключ RSA, размер которого меньше 2048 бит, более уязвим для атак методом подбора.|
|[CA5386. Не встраивайте значение SecurityProtocolType](ca5386.md)|Протокол TLS обеспечивает безопасность взаимодействия между компьютерами, чаще всего с помощью протокола HTTPS. Протоколы версии TLS 1.0 и TLS 1.1 являются устаревшими, а TLS 1.2 и TLS 1.3 являются актуальными. В будущем протоколы TLS 1.2 и TLS 1.3 могут быть отмечены как нерекомендуемые. Чтобы обеспечить безопасность приложения, не следует жестко задавать версию протокола, и рекомендуется использовать по крайней мере .NET Framework версии 4.7.1.|
|[CA5387: не используйте ненадежную функцию формирования ключа с недостаточным числом итераций](ca5387.md)|Это правило проверяет, был ли криптографический ключ создан классом <xref:System.Security.Cryptography.Rfc2898DeriveBytes> с числом итераций менее 100 000. Более высокие значения позволяют устранять словарные атаки, которые пытаются угадать созданный криптографический ключ.|
|[CA5388: обеспечьте достаточное число итераций при использовании ненадежной функции формирования ключа](ca5388.md)|Это правило проверяет, был ли криптографический ключ создан классом <xref:System.Security.Cryptography.Rfc2898DeriveBytes> с числом итераций менее 100 000. Более высокие значения позволяют устранять словарные атаки, которые пытаются угадать созданный криптографический ключ.|
|[CA5389. Не добавлять путь к элементу архива в путь целевой файловой системы](ca5389.md)|Путь к файлу может быть относительным и привести к доступу к файловой системе за пределами ожидаемого целевого пути, повышая риск вредоносного изменения конфигурации и удаленного выполнения кода с помощью метода выжидания.|
|[CA5390: не используйте жестко заданный ключ шифрования](ca5390.md)|Для успешного выполнения симметричного алгоритма секретный ключ должен быть известен только отправителю и получателю. Если ключ жестко задан, его легко обнаружить. Даже если используются скомпилированные двоичные файлы, злоумышленники могут легко его извлечь. После компрометации закрытого ключа текст шифра может быть расшифрован напрямую и больше не является защищенным.|
|[CA5391: используйте маркеры защиты от подделки в контроллерах MVC ASP.NET Core](ca5391.md)|Обработка запроса `POST`, `PUT`, `PATCH` или `DELETE` без проверки маркера для защиты от подделки может стать уязвимой для атак с использованием подделки межсайтовых запросов. Атака с использованием подделки межсайтовых запросов позволяет отправлять вредоносные запросы от пользователя, прошедшего проверку подлинности, в контроллер MVC ASP.NET Core.|
|[CA5392: используйте атрибут DefaultDllImportSearchPaths для методов P/Invoke](ca5392.md)|По умолчанию функции P/Invoke используют пробу <xref:System.Runtime.InteropServices.DllImportAttribute> нескольких каталогов, включая текущий рабочий каталог для загрузки библиотеки. Это может быть проблемой безопасности для некоторых приложений, приводящей к перехвату библиотеки DLL.|
|[CA5393: не используйте небезопасное значение DllImportSearchPath](ca5393.md)|В каталогах поиска DLL по умолчанию и каталогах сборок может находиться вредоносная библиотека DLL. Или в зависимости от того, откуда запускается приложение, в каталоге приложения может быть вредоносная библиотека DLL.|
|[CA5394: не используйте небезопасные генераторы случайных чисел](ca5394.md)|Использование криптографически слабого генератора случайных чисел может позволить злоумышленнику предсказать, какое чувствительное к безопасности значение будет создано.|
|[CA5395: отсутствует атрибут HttpVerb для методов действия](ca5395.md)|Все методы действий, которые создают, изменяют, удаляют или иным образом модифицируют данные, должны быть защищены с помощью атрибута защиты от подделки межсайтовых запросов. Операция GET должна выполняться безопасным способом, то есть не иметь побочных эффектов и не изменять существующие данные.|
|[CA5396: установите для параметра HttpOnly объекта HttpCookie значение true](ca5396.md)|Для обеспечения глубокого уровня защиты HTTP-файлы cookie, чувствительные к безопасности, должны быть помечены как HttpOnly. Это означает, что веб-браузеры должны запрещать скриптам доступ к файлам cookie. Внедренные скрипты являются распространенным способом кражи файлов cookie.|
|[CA5397. Не используйте нерекомендуемые значения SslProtocols](ca5397.md)|Протокол TLS обеспечивает безопасность взаимодействия между компьютерами, чаще всего с помощью протокола HTTPS. Более ранние версии протокола TLS менее безопасны, чем TLS 1.2 и TLS 1.3, и, скорее всего, будут подвержены новым уязвимостям. Избегайте использования более ранних версий протокола, чтобы снизить риск.|
|[CA5398. Избегайте жестко зафиксированных значений SslProtocols](ca5398.md)|Протокол TLS обеспечивает безопасность взаимодействия между компьютерами, чаще всего с помощью протокола HTTPS. Протоколы версии TLS 1.0 и TLS 1.1 являются устаревшими, а TLS 1.2 и TLS 1.3 являются актуальными. В будущем протоколы TLS 1.2 и TLS 1.3 могут быть отмечены как нерекомендуемые. Чтобы обеспечить безопасность приложения, не следует жестко задавать версию протокола.|
|[CA5399: явно отключите проверку списка отзыва сертификатов HttpClient](ca5399.md)|Отозванный сертификат больше не является доверенным. Злоумышленники могут использовать его для передачи вредоносных данных или кражи конфиденциальных данных при взаимодействии по протоколу HTTPS.|
|[CA5400: убедитесь, что проверка списка отзыва сертификатов HttpClient не отключена](ca5400.md)|Отозванный сертификат больше не является доверенным. Злоумышленники могут использовать его для передачи вредоносных данных или кражи конфиденциальных данных при взаимодействии по протоколу HTTPS.|
|[CA5401: не используйте CreateEncryptor с вектором инициализации, отличным от значения по умолчанию](ca5401.md)|Для предотвращения атак перебором по словарю в симметричном шифровании всегда нужно использовать невоспроизводимый вектор инициализации.|
|[CA5402: используйте CreateEncryptor с вектором инициализации по умолчанию](ca5402.md)|Для предотвращения атак перебором по словарю в симметричном шифровании всегда нужно использовать невоспроизводимый вектор инициализации.|
|[CA5403: Не используйте жестко заданный сертификат](ca5403.md)|Параметр `data` или `rawData` конструктора <xref:System.Security.Cryptography.X509Certificates.X509Certificate> или <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> жестко задан.|
