---
title: 'CA1835: предпочитать перегрузки методов ReadAsync/WriteAsync, основанные на памяти, в классах, основанных на потоках (анализ кода)'
description: 'Дополнительные сведения о правиле анализа кода "CA1835: предпочитать перегрузки методов ReadAsync/WriteAsync, основанные на памяти, в классах, основанных на потоках"'
ms.date: 05/11/2020
ms.topic: reference
f1_keywords:
- PreferStreamAsyncMemoryOverloads
- CA1835
helpviewer_keywords:
- PreferStreamAsyncMemoryOverloads
- CA1835
author: carlossanlop
ms.author: calope
dev_langs:
- CSharp
- VB
ms.openlocfilehash: 5febce07d38bd3781601d6d70a663c779eaa6d66
ms.sourcegitcommit: 05d0087dfca85aac9ca2960f86c5efd218bf833f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/27/2021
ms.locfileid: "105637277"
---
# <a name="ca1835-prefer-the-memory-based-overloads-of-readasyncwriteasync-methods-in-stream-based-classes"></a>CA1835: предпочитать перегрузки методов ReadAsync/WriteAsync, основанные на памяти, в классах, основанных на потоках

| | Значение |
|-|-|
| **Имя типа** |PreferStreamAsyncMemoryOverloads|
| **Идентификатор правила** |CA1835|
| **Категория** |[Производительность](performance-warnings.md)|
| **Исправление является критическим или не критическим** |Не критическое|

## <a name="cause"></a>Причина

Это правило находит ожидающие вызовы перегрузок методов на основе массивов байтов для `ReadAsync` и `WriteAsync` и предлагает использовать перегрузки методов на основе памяти, так как они более эффективны.

## <a name="rule-description"></a>Описание правила

Перегрузки методов на основе памяти используют память более эффективно по сравнению с перегрузками методов на основе массивов байтов.

Правило работает с вызовами `ReadAsync` и `WriteAsync` любого класса, наследуемого от <xref:System.IO.Stream>.

Правило работает только в том случае, если перед методом стоит ключевое слово `await`.

|Обнаруженный метод|Предлагаемый метод|
|-|-|
|<xref:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)>|<xref:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)>|
|<xref:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)>|<xref:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)> с параметром `CancellationToken`, имеющим значение `default` в C# или `Nothing` в Visual Basic.|
|<xref:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)>|<xref:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)>|
|<xref:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)>|<xref:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)> с параметром `CancellationToken`, имеющим значение `default` в C# или `Nothing` в Visual Basic.|

> [!IMPORTANT]
> Не забудьте передать целочисленные аргументы `offset` и `count` в созданные экземпляры `Memory` или `ReadOnlyMemory`.

> [!NOTE]
> Правило CA1835 доступно во всех версиях .NET, в которых имеются перегрузки на основе памяти:
>
> - .NET Standard 2.1 и более поздние версии.
> - .NET Core 2.1 и более поздние версии.

## <a name="how-to-fix-violations"></a>Устранение нарушений

Вы можете устранить их вручную или позволить Visual Studio сделать это автоматически, наведя указатель мыши на лампочку рядом с вызовом метода и выбрав предлагаемое изменение. Пример.

![Исправление кода для правила "CA1835: предпочитать перегрузки методов ReadAsync/WriteAsync, основанные на памяти, в классах, основанных на потоках"](media/ca1835-codefix.png)

Правило может обнаруживать различные нарушения для методов `ReadAsync` и `WriteAsync`. Ниже приведены примеры случаев, которые может обнаружить это правило:

### <a name="example-1"></a>Пример 1

Вызовы `ReadAsync` с аргументом `CancellationToken` и без него:

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod(CancellationToken ct)
    {
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            byte[] buffer = new byte[s.Length];
            await s.ReadAsync(buffer, 0, buffer.Length);
            await s.ReadAsync(buffer, 0, buffer.Length, ct);
        }
    }
}
```

Исправление:

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod(CancellationToken ct)
    {
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            byte[] buffer = new byte[s.Length];
            await s.ReadAsync(buffer.AsMemory(0, buffer.Length));
            await s.ReadAsync(buffer.AsMemory(0, buffer.Length), ct);
        }
    }
}
```

### <a name="example-2"></a>Пример 2

Вызовы `WriteAsync` с аргументом `CancellationToken` и без него:

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod(CancellationToken ct)
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer, 0, buffer.Length);
            await s.WriteAsync(buffer, 0, buffer.Length, ct);
        }
    }
}
```

Исправление:

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod()
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer.AsMemory(0, buffer.Length));
            await s.WriteAsync(buffer.AsMemory(0, buffer.Length), ct);
        }
    }
}
```

### <a name="example-3"></a>Пример 3

Вызовы с `ConfigureAwait`:

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod()
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer1 = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer1, 0, buffer1.Length).ConfigureAwait(false);

            byte[] buffer2 = new byte[s.Length];
            await s.ReadAsync(buffer2, 0, buffer2.Length).ConfigureAwait(true);
        }
    }
}
```

Исправление:

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod()
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer1 = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer1.AsMemory(0, buffer1.Length)).ConfigureAwait(false);

            byte[] buffer2 = new byte[s.Length];
            await s.ReadAsync(buffer2.AsMemory(0, buffer.Length)).ConfigureAwait(true);
        }
    }
}
```

## <a name="non-violations"></a>Случаи, не являющиеся нарушениями

Ниже приведены некоторые примеры вызовов, в которых правило **не** будет использовано.

Возвращаемое значение не ожидается, а сохраняется в переменной `Task`:

```cs
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

class MyClass
{
    public void MyMethod()
    {
        byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            Task t = s.WriteAsync(buffer, 0, buffer.Length);
        }
    }
}
```

Возвращаемое значение не ожидается, а возвращается методом переноса:

```cs
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

class MyClass
{
    public Task MyMethod(FileStream s, byte[] buffer)
    {
        return s.WriteAsync(buffer, 0, buffer.Length);
    }
}
```

Возвращаемое значение используется для вызова `ContinueWith`, который является ожидаемым методом:

```cs
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

class MyClass
{
    public void MyMethod()
    {
        byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            await s.WriteAsync(buffer, 0, buffer.Length).ContinueWith(c => { /* ... */ });
        }
    }
}
```

## <a name="when-to-suppress-warnings"></a>Условия для отключения предупреждений

Нарушение этого правила можно подавить, если вы не беспокоитесь о повышении производительности при чтении или записи буферов в классах, основанных на потоках.

## <a name="see-also"></a>См. также раздел

- [Правила производительности](performance-warnings.md)
