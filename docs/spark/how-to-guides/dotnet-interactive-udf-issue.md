---
title: Написание и вызов определяемых пользователем функций в .NET для интерактивных сред Apache Spark.
description: Узнайте, как писать и вызывать определяемые пользователем функции в .NET для интерактивных оболочек Apache Spark.
ms.author: nidutta
author: Niharikadutta
ms.date: 10/09/2020
ms.topic: conceptual
ms.custom: mvc,how-to
ms.openlocfilehash: c29c3a9f6269a342d1051d6d979a4e3adb42da02
ms.sourcegitcommit: c7f0beaa2bd66ebca86362ca17d673f7e8256ca6
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/23/2021
ms.locfileid: "104875555"
---
# <a name="write-and-call-udfs-in-net-for-apache-spark-interactive-environments"></a>Написание и вызов определяемых пользователем функций в .NET для интерактивных сред Apache Spark

В этой статье вы узнаете, как использовать определяемые пользователем функции (UDF) в .NET для интерактивной среды Apache Spark.

## <a name="prerequisites"></a>Предварительные требования

1. Установите [.NET Interactive](https://github.com/dotnet/interactive)
2. Установите [Jupyter Lab](https://jupyter.org/)

## <a name="net-for-apache-spark-interactive-experience"></a>.NET для интерактивной среды Apache Spark

[.NET для Apache Spark](https://github.com/dotnet/spark) использует [.NET Interactive](https://devblogs.microsoft.com/dotnet/net-interactive-is-here-net-notebooks-preview-2/) для предоставления поддержки .NET интерактивному интерфейсу в Spark. Сведения о том, как настроить среду для работы с Jupyter Notebooks в .NET Interactive, см. в статье [Репозиторий .NET Interactive](https://github.com/dotnet/interactive).

Кроме того, рекомендуется ознакомиться с [этой статьей, посвященной сериализации UDF в .NET для Apache Spark](udf-guide.md), чтобы понять, что такое определяемые пользователем функции и как они сериализуются в .NET для Apache Spark.
В этом руководстве используются записные книжки Jupyter Notebook для демонстрации использования UDF в интерактивной среде.

## <a name="define-a-udf-in-net-interactive"></a>Определение UDF в .NET Interactive

В интерактивной среде ячейка может рассматриваться как фрагмент кода, отправляемый в рамках одной итерации [REPL](https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop). Например, рассмотрим следующую записную книжку, чтобы понять, что это означает:

![Ячейки Jupyter Notebook](./media/dotnet-interactive/dotnet-interactive-cells.png)

Каждый из этих блоков, отмеченных красной стрелкой, является одной ячейкой или одной отправкой кода в Spark. Теперь при определении UDF, ссылающейся на пользовательский объект, она должна быть определена в той же ячейке, где определен объект, на который ссылается функция. Давайте посмотрим, как это выглядит на примере:

![Рабочая определяемая пользователем функция](./media/dotnet-interactive/working-udf.png)

## <a name="call-a-udf-on-a-dataframe"></a>Вызов определяемой пользователем функции в кадре данных

При вызове определенной ранее UDF для `DataFrame` важно убедиться, что функция определена в ранее отправленной ячейке, прежде чем вызывать ее, как видно в предыдущем примере.

Теперь давайте посмотрим, что происходит при вызове определяемой пользователем функции в той же ячейке, где она определена.

![Сбой вызова UDF](./media/dotnet-interactive/udf_fails.png)

Выделенная выше ошибка связана с тем, что сборки UDF сначала должны быть скомпилированы и отправлены в рабочие роли, прежде чем ее можно будет вызвать для таблицы данных.

Ниже приведены некоторые важные моменты, которые следует учитывать при реализации определяемых пользователем функций в .NET для интерактивной среды Apache Spark (например, для [записных книжек Azure Synapse](/azure/synapse-analytics/spark/apache-spark-development-using-notebooks)).

## <a name="faqs"></a>Часто задаваемые вопросы

1. **Почему моя определяемая пользователем функция, ссылающаяся на пользовательский объект, приводит к ошибке `Type Submission#_ is not marked as serializable`?**
    .NET Interactive упаковывает каждую из этих ячеек с помощью класса-оболочки номера отправки ячейки, чтобы однозначно идентифицировать каждую отправляемую ячейку. Теперь, как подробно описано в [этом руководстве](udf-guide.md), при сериализации определяемой пользователем функции, ссылающейся на настраиваемый объект, также выполняется сериализация, которая в случае с .NET Interactive переносится классом-оболочкой ячейки, в которой определен пользовательский объект.
    Теперь давайте посмотрим, как это влияет на определение UDF в записной книжке:

    ![Ошибка сериализации UDF](./media/dotnet-interactive/udf-serialization-error.png)

    Как можно увидеть в случае `udf2_fails`, отображается сообщение об ошибке "Тип `Submission#7` не помечен как сериализуемый". Это связано с тем, что .NET Interactive заключает каждый объект, определенный в ячейке, с помощью класса `Submission#`, который создается на ходу и, следовательно, не отмечен как `Serializable`.

    По этой причине **требуется, чтобы определяемая пользователем функция, ссылающаяся на пользовательский объект, была определена в той же ячейке, что и этот объект**.

2. **Почему широковещательные переменные не работают с .NET Interactive?**
    По причинам, описанным выше, широковещательные переменные не работают с .NET Interactive. Рекомендуется ознакомиться с [этим руководством по широковещательным переменным](broadcast-guide.md), чтобы получить более глубокое представление о том, что такое широковещательные переменные и как их использовать. Причины, по которым широковещательные переменные не работают с интерактивными сценариями, обусловлены тем, что в NET Interactive каждый объект, определенный в ячейке с помощью класса отправки ячейки, и поэтому не помеченный как сериализуемый, завершается с тем же исключением, как показано выше.
    Давайте немного подробнее рассмотрим следующий пример:

    ![Сбой широковещательных переменных](./media/dotnet-interactive/broadcast-fails.png)

    Как рекомендуется в предыдущих разделах, мы определим UDF и объект, на который она ссылается (в данном случае это широковещательная переменная), в одной и той же ячейке, однако по-прежнему отображается ошибка `SerializationException`, в которой указывается, что `Microsoft.Spark.Sql.Session` не помечен как сериализуемый. Это происходит потому, что когда компилятор пытается сериализовать объект широковещательной переменной `bv`, он находит имя, которое добавляется к `spark` объекта [`SparkSession`](https://github.com/dotnet/spark/blob/main/src/csharp/Microsoft.Spark/Sql/SparkSession.cs#L20), который требуется пометить как сериализуемый. Это можно продемонстрировать с помощью декомпилированной сборки этой ячейки:

    ![Код декомпилированной сборки](./media/dotnet-interactive/decompiledAssembly.png)

    Если пометить класс [`SparkSession`](https://github.com/dotnet/spark/blob/main/src/csharp/Microsoft.Spark/Sql/SparkSession.cs#L20) как `[Serializable]`, то его можно будет использовать, но это не идеальное решение, поскольку мы не хотим дать пользователю возможности сериализовать объект SparkSession, так как это может привести к нежелательному поведению. Это [известная проблема](https://github.com/dotnet/spark/issues/619), и она будет устранена в будущих версиях.
